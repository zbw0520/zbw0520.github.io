<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>王氏代数和T-Coil的历史故事</title>
      <link href="/2023/11/06/wangalgebra-tcoil/"/>
      <url>/2023/11/06/wangalgebra-tcoil/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近看到一篇很有意思的关于Tcoil的文章，这篇文章主要讲述了Tcoil的历史，以前导师曾经提过Tcoil的发明要依赖一位民国的老先生，但是一直没有提过其具体姓名和所作的工作。现在，我偶然间看到了这个先生的名字叫（Wang Ki-Tung，王季同）。他所发明的王氏代数能够以非常简单的方式求解Tcoil。Tcoil的发明者也毫不忌讳的说其理论来源就是这位老先生的王氏代数。让人不禁感叹民国时期的学者王季同在当时能够钻研出如此方法是多么不易。</p><h3 id="王季同先生的一生"><a href="#王季同先生的一生" class="headerlink" title="王季同先生的一生"></a>王季同先生的一生</h3><p>王季同出生于1875年，去世于1948年，享年73岁，在我看来是，属于是长寿的了。他是中国数学家、电气工程师、哲学家。并且这位先生应该是历史上第一位在国际期刊上发表数学文章的中国学者，意义非常重大，他因为他的王氏代数工作而出名，并且他还对佛教和科学之间的关系展开了研究。</p><p>王季同出生于苏州的一个富裕家庭，他的祖先王鳌在1450-1524年间在明代科举考试中获得第三名，并且官位至相当于今日的首相，他的父亲王颂蔚也在科举考试中获得了进士。</p><p>1895年王季同从北京大学毕业，随后被北京大学聘为数学讲师。他已经发表了好几篇数学上的中文文章，并且研究了传统中文数学和现代数学。</p><p>在1909年，王季同担任欧洲中国学生管理员，在这段时间内，王季同在英国电器公司和西门子做了两段实习工作。在这段时间内，他在Royal Irish Academy发表了一篇文章，这篇文章被认为是中国数学家在国际期刊上发表的第一篇论文。</p><p>在1914年，王季同在镇江电力厂工作。1928年，王季同被国家工程院聘为院士。他提出了一种新的方法来推导电气网络的阻抗，这种方法相对于传统方法有较大的优势。在1950年，Duffin和Bott发现了王氏代数，并将其推广开来。</p><h3 id="从前辈的理论到现代的应用"><a href="#从前辈的理论到现代的应用" class="headerlink" title="从前辈的理论到现代的应用"></a>从前辈的理论到现代的应用</h3><p>从王氏代数被推出以来，这个理论在许多领域中都有大量的应用，从图理论到电气电子工程。本文作为这个理论的一个综述，写了关于它的历史、理论以及现代的一些应用。</p><p>本文将Tcoil作为应用的一个案例进行了案例分析，这种电路在宽带放大器中有非常广泛的应用。这种电路通常和Distributed Amplification、Peaking网络、Termination network以及传输线equalization一起使用。在近几年间、高速IC设计由于以下的三个原因需要使用Tcoil：</p><ul><li>恒定的输入阻抗</li><li>超过两倍的带宽扩展能力</li><li>二阶传输函数</li></ul><p>Tektronix作为最先使用Tcoil进行带宽扩展的应用，在1960年使用桥式Tcoil获得了相比于传统RC网络来说巨大的带宽提升优势，精确地说是$2\sqrt{2}$倍地带宽提升。这种电路在Tektronix示波器中被广泛地应用，但是设计细节一直被作为商业机密。直到1990年，Tektronix地工程师Feucht提供了Tcoil的设计公式，这个秘密才被公开，但是当时没有提供任何推导。</p><p>在这篇文章中，主要使用符号描述了设计恒定阻抗Tcoil网络的通用方法。对于其中元件关系的通式都是使用王氏代数推导而来的。<strong>恒定阻抗的限制是使用额外一个元件来平衡桥式电路</strong>（这句话我没有看懂，后面再回过头来看看）。这简化了计算传输函数的过程，并且用一个简化的戴维南等效电路来展现。</p><h3 id="本文内容"><a href="#本文内容" class="headerlink" title="本文内容"></a>本文内容</h3><p>先给出了一个王氏代数的简介，并且给出了使用群论进行证明的过程；接下去给出了王氏代数在电子工程以及图论中的应用；接下去给出了使用王氏代数进行Tcoil设计的过程。</p><h2 id="王氏代数"><a href="#王氏代数" class="headerlink" title="王氏代数"></a>王氏代数</h2><p>本质上王氏代数提供了一种计算对称矩阵行列式的方法，在一些情形下可能会非常好用。证明就略过了，本人数学不是特别好，所以对于证明内容看得也是云里雾里。直接进入到应用部分。</p><h2 id="桥式T-coil"><a href="#桥式T-coil" class="headerlink" title="桥式T-coil"></a>桥式T-coil</h2><p>恒定R的Tcoil提供了理想的负载或者端接，Tcoil可以提供2.73倍的带宽提升，并且将阶跃响应的过冲控制在0.4%以内。目前Tcoil有两个应用，一个是高速Buffer；另一个是ESD保护的带宽提升。</p><h3 id="Tcoil在Tek公司中的历史以及后续发展"><a href="#Tcoil在Tek公司中的历史以及后续发展" class="headerlink" title="Tcoil在Tek公司中的历史以及后续发展"></a>Tcoil在Tek公司中的历史以及后续发展</h3>]]></content>
      
      
      <categories>
          
          <category> 模拟集成电路设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟集成电路设计 </tag>
            
            <tag> Tcoil </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2b/Cycle的ADC的版图电路调试分析</title>
      <link href="/2023/10/27/adc2bpcycleanalysis/"/>
      <url>/2023/10/27/adc2bpcycleanalysis/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本人最近在设计2b/Cycle的SAR ADC版图，在这一过程中遇到了很多的问题，特别写了一篇博客总结了我遇到的这些问题，以供之后参考。</p><h2 id="2b-x2F-Cycle的设计目的"><a href="#2b-x2F-Cycle的设计目的" class="headerlink" title="2b/Cycle的设计目的"></a>2b/Cycle的设计目的</h2><p>本项目中的2b/Cycle的设计目的在于给后面ADC提供两个余量，通过两组差分CDAC实现对输入信号的阈值在一个Cycle中进行两次比较，最终给出2位的结果。最后的余量为差分的形式，并且存在两个差分余量，提供给作为第二级ADC的Reference。这种设计的好处在于不需要在乎中间余量放大器的的绝对增益误差，并且这种设计对余量放大器的相对增益误差也不敏感。</p><h2 id="2b-x2F-Cycle的开销巨大"><a href="#2b-x2F-Cycle的开销巨大" class="headerlink" title="2b/Cycle的开销巨大"></a>2b/Cycle的开销巨大</h2><h3 id="Input-Buffer直接面对巨大的电容负载"><a href="#Input-Buffer直接面对巨大的电容负载" class="headerlink" title="Input Buffer直接面对巨大的电容负载"></a>Input Buffer直接面对巨大的电容负载</h3><p>在本次版图绘制过程中，由于需要进行交织操作，需要限制单通道ADC的高度，由于2b/Cycle的CDAC总共有四组相同的结构，这就意味着CDAC不可以进行三维设计。在这里，我们采用了一字排开的方案，并且为了减小走线的复杂度，采用了一个开关对应一个CDAC单位电容的操作。这种操作下，整个单通道的高度虽然得到了限制，但是其宽度却是非常巨大的，达到了200um，根据走线上的经验，1um的走线大概贡献1fF的寄生电容，这里就意味着输入信号上挂载的寄生电容大大增大了。我们可以进行一个简单的计算，单侧单边的CDAC的大小约为256fF，走线上的寄生大约为200fF左右，与CDAC的寄生相当，这是非常巨大的，再来，由于一个开关对应了一个单位电容，这就造成了开关的数量也非常巨大。假设一个开关上贡献1fF的寄生电容，那么开关上总共贡献的寄生电容大约为256fF，也相当于提供了一个CDAC的寄生电容。把上述的计算统计起来，就可以发现，2b/Cycle这种布局下的电路会导致输入上挂在的负载电容增大为原先的3倍，大约为750fF左右，在考虑到要驱动两组差分的CDAC，该结构需要翻倍，最终通过计算可以得到需要驱动大约1.5pF的电容负载，这对于需要高线性度的输入信号无疑是一个巨大的打击。</p><h3 id="Reference-Buffer需要驱动巨大的电容负载"><a href="#Reference-Buffer需要驱动巨大的电容负载" class="headerlink" title="Reference Buffer需要驱动巨大的电容负载"></a>Reference Buffer需要驱动巨大的电容负载</h3><p>根据先前的分析可以看到，由于2b/Cycle的架构导致寄生电容会变为原先的3倍，对于输入来说是这样，对于Reference来说也是这样，我们的Reference电压需要驱动的负载也翻为了原先的3倍，这就意味着原先的既定设计目标速度很有可能无法达到，再者，Reference Buffer的功耗为了达到性能很有可能需要加倍。</p><h3 id="逻辑过于复杂"><a href="#逻辑过于复杂" class="headerlink" title="逻辑过于复杂"></a>逻辑过于复杂</h3><p>在我们的设计中，2b/Cycle在每一个CDAC内部都需要对应的逻辑，这个逻辑一方面占据了巨大的面积；另一方面，还需要高层金属来实现低电阻的走线，以保证一定的CDAC拨动速度。在这里我们采用过两种逻辑排布的方案，一种是2行的排布方案，这种方案会导致逻辑本身的宽度非常巨大，比CDAC还要长，版图非常不紧凑，会多出来许多不规则的面积，给整体的ADC版图设计带来了非常大的不便；另一种方案是8行的排布方案，这种方案减小了逻辑的横向宽度，将整个CDAC的版图变为一个规则的长方形，减小了后期排布的不便。逻辑的另一个阻碍是走线问题，2b/Cycle的走线非常复杂，一组CDAC内有32组逻辑输出先，16组逻辑输入线，这些线需要考虑到速度问题从而需要在高层进行布线，高层走线的问题是，其最小宽度和最小间距问题，在我们使用的T工艺中，最高层低电阻金属的方块组织大约为$0.05m\Omega/\mu m$，是一般走线的$1/10$，在这样的条件下，走一根$200\mu m$的金属线对应的电阻大约为$10\Omega$，假设我们驱动了大约30fF的电容，那么对应的延迟大约可以控制在1ps以内，是可以接受的。在我们使用的T工艺中，高层金属的pitch为0.9，乘以32根线，大约为28.8um，再考虑到16根控制线，大约为50um，需要特别的策略来降低高层金属的宽度。</p>]]></content>
      
      
      <categories>
          
          <category> 模拟IC设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2b/Cycle </tag>
            
            <tag> SAR ADC </tag>
            
            <tag> 版图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bandgap的反馈极性以及稳定点问题</title>
      <link href="/2023/09/16/bandgap-de-fan-kui-ji-xing-yi-ji-wen-ding-dian-wen-ti/"/>
      <url>/2023/09/16/bandgap-de-fan-kui-ji-xing-yi-ji-wen-ding-dian-wen-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>最近在工作中遇到了一个关于Bandgap的问题，问：如下两个电路，$Q1:Q2=1:8$，其余所有MOS管的尺寸均一致，问哪一个电路是正确的？</p><img src="/2023/09/16/bandgap-de-fan-kui-ji-xing-yi-ji-wen-ding-dian-wen-ti/c3a465a80ea61ff8f84e348f2fbde1aee13ea42989036535400ae3054d860cf7.png" class="" title="picture 0">  <p>我从来没有思考过这个问题，于是，我仔细思考，将思考的过程和结果记录在此博客中，以供之后查看。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>这两个电路中存在一个差分转单端运算放大器，这个运算放大器是由两个NMOS管构成的，NMOS管构成共栅放大器，其中，栅极接收来自下方的Bipolar和电阻组成的网络的输出电压；从其中一个NMOS的漏极产生输出电压，具体的等效电路如下图所示，</p><img src="/2023/09/16/bandgap-de-fan-kui-ji-xing-yi-ji-wen-ding-dian-wen-ti/567fd1036f91911dea02f07e7f7a046c6c7ab23ed6bb569d9b7ffd1f3481f7bd.png" class="" title="picture 1">  <p>可以看到，上面连个电路的区别在于左右两个支路反馈的极性，其中（a）图中的极性分别为右侧支路的反馈为负反馈，左侧支路的反馈为正反馈；（b）图则相反，右侧支路的反馈为正反馈，左侧支路的反馈为负反馈。要搞清楚上面两中反馈的机制到底对电路会产生怎么样的影响，应该先写出电路的电压-电流表达式，先有一个数学层面的感受。</p><p>解出下面的电路图中的电压表达式，</p><img src="/2023/09/16/bandgap-de-fan-kui-ji-xing-yi-ji-wen-ding-dian-wen-ti/4bc24649a91958ae949860f6da137c7c99488aa5d2c428e41b044ba037d4463d.png" class="" title="picture 2"><p>由于Bipolar的特性为指数特性，其电流来自于基极的少子的扩散运动，扩散运动来自于BE界面和BC界面浓度的不一致，其中BC界面的浓度可以忽略，基本为零，BE界面的浓度服从Fermi-Dirac分布，可以做Boltzmann近似，得到近似指数的分布，其表达式如下，</p><p>$$<br>I_C=I_Se^\frac{V_{BE}}{V_T}<br>$$</p><p>根据上述分析，在（a）图中，$V_1$的表达式如下所示，</p><p>$$<br>V_1=V_Tln\frac{I_C}{I_S}<br>$$</p><p>在（a）图中，$V_2$的表达式如下所示，</p><p>$$<br>V_2=I_CR+V_Tln\frac{I_C}{nI_S}<br>$$</p><p>我们可以在数学上绘制出这两个点的$V-I$特性曲线，如下所示，</p><img src="/2023/09/16/bandgap-de-fan-kui-ji-xing-yi-ji-wen-ding-dian-wen-ti/23093cde13f72e3b53f14501a2457a78cc11c794171b85f1450ed9d7f1919a0e.png" class="" title="picture 3">  <p>可以看到这两个特性曲线存在两个交点，即存在两个状态，使得电压相等且电流相等。在运算放大器控制下，这两个点都可能存在稳定的工作可能性。这里就解释了为什么Bandgap需要一个启动电路的原因。</p><p>接下去我们对$V_2-V_1$关于$I_C$求导，如下所示，</p><p>$$<br>\frac{\partial (V_2-V1)}{\partial I_C}=R+V_T\frac{nI_S}{I_C}-V_T\frac{I_S}{I_C}=R+(n-1)\frac{I_S}{I_C}&gt;0<br>$$</p><p>可以看出，上面的导数的结果，只要保证$n&gt;1$的条件，在我们的案例中$n=8$，就可以保证当$I_C\uparrow$时，一定有$(V_2-V_1)\uparrow$。</p><p>所以当我们再看如下这两个电路图时，在（a）图中，当$(V_2-V_1)\uparrow$时，运算放大器的输出增大，迫使$MP1$和$MP2$的栅极电压上升，从而流过$MP1$和$MP2$的电流下降，即，使得$I_C\downarrow$，从而使得$(V_2-V_1)\downarrow$，逆转原先的增大趋势，形成负反馈，最终电路趋于稳定。</p><img src="/2023/09/16/bandgap-de-fan-kui-ji-xing-yi-ji-wen-ding-dian-wen-ti/4bc24649a91958ae949860f6da137c7c99488aa5d2c428e41b044ba037d4463d.png" class="" title="picture 2"><p>再来看在（b）图中，当$(V_2-V_1)\uparrow$时，运算放大器的输出降低，迫使$MP1$和$MP2$的栅极电压下降，从而流过$MP1$和$MP2$的电流上升，即，使得$I_C\uparrow$，从而使得$(V_2-V_1)\uparrow$，形成正反馈，最终$(V_2-V_1)$的值会越来越大，导致电路不能正常工作。</p><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>这篇文章总结了Bandgap电路的工作特性，主要说明了Bandgap电路中的反馈极性的分析问题，以及电路中的稳定点存在两个的问题，从数学上证明了这两个问题的结果。</p><p>最后，让我们从直观的理解上，分析一下为什么随着电流的增大，$V_2-V_1$会越来越大。本质上是因为电阻的$V-I$特性是线性的，而Bipolar的$V-I$特性是对数的，对数的关系要弱于指数的关系，而$V_2$中的对数成分由于比例关系$n$的存在，而形成了一个更加弱的对数关系。从这个角度来看，我们可以认为$V_2$完全由线性关系主导（当然，实际情况并不是如此），而$V_1$则是由一个对数关系主导的。由于对数关系的关联性要弱于线性关系，所以，$V_2$对变量$I_C$对的耦合程度要远大于$V_1$对变量$I_C$的耦合关系。</p><p>让我们再从直观的角度来看一下为什么电路存在两个稳定的工作点，我们可以直接绘制出如下的电压电流关系图，</p><img src="/2023/09/16/bandgap-de-fan-kui-ji-xing-yi-ji-wen-ding-dian-wen-ti/460108a66cece8b1c7dfa31f2ea2f2f183bd22cb807caae8cd4ac18247f664de.png" class="" title="picture 4">  <p>可以很明显的看到，这两个$V-I$特性曲线存在两个交点。</p><p>到这里，我们分析了两个我从来没有考虑过的问题，解决了之前仿真过程中一直困扰我的两个问题，在此记录一下，以供未来查阅。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>最近同学又告诉我了一种新的分析方法，在此总结一下，以供之后参考。这种分析方法将整个电路的正反馈环路进行了分析，假设在输入对管的栅极上存在一个电压，如下图所示，</p><img src="/2023/09/16/bandgap-de-fan-kui-ji-xing-yi-ji-wen-ding-dian-wen-ti/c3a465a80ea61ff8f84e348f2fbde1aee13ea42989036535400ae3054d860cf7.png" class="" title="picture 0"> <h4 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h4><p>在（a）的案例中，信号经由MN2的栅极-&gt;MN2的漏-&gt;MP2的栅-&gt;MP1的漏-&gt;MN1的栅，这个环路进行运作，在这个环路上，我们先给出由MN2的栅到MN2的漏的表达式，这时候，MN2管的跨导由于源退化电阻的存在，导致跨导减小了，</p><p>$$<br>G_1=\frac{-g_{mN}}{1+g_{mN}(R+1/g_{mQ})}\frac{1}{g_{mP}}<br>$$</p><p>其中，$g_{mQ}$为双极型晶体管的跨导。接下去我们再计算从MP2的栅到MP1的漏的表达式，</p><p>$$<br>G_2=-g_{mP}(1/g_{mN}+1/g_{mQ})<br>$$</p><p>将上述两个增益乘起来，得到如下的总增益，</p><p>$$<br>G=G_1G_2=\frac{g_{mN}(1/g_{mN}+1/g_{mQ})}{1+g_{mN}(R+1/g_{mQ})}<br>$$</p><p>假设$g_{mN}:g_{mQ}=k$，那么，上面的表达式可以化简为如下，</p><p>$$<br>G=\frac{1+k}{1+k+g_{mN}R}<br>$$</p><h4 id="三极管的跨导-g-mQ-与MOS管的跨导-g-m-之间的关系"><a href="#三极管的跨导-g-mQ-与MOS管的跨导-g-m-之间的关系" class="headerlink" title="三极管的跨导$g_{mQ}$与MOS管的跨导$g_m$之间的关系"></a>三极管的跨导$g_{mQ}$与MOS管的跨导$g_m$之间的关系</h4><p>一般来说，三极管的跨导的表达式如下所示，</p><p>$$<br>g_{mQ}=\frac{I_C}{V_T}\approx40I_d<br>$$</p><p>这个跨导在我的”PaulGray经典著作读书笔记第一章”的阅读笔记里面有提到，这个跨导只与电流和温度有关，与双极型晶体管采用的材质、尺寸、型号（PNP or NPN）都是无关的。</p><p>对于处在饱和区的MOS管来说，其跨导可以使用下面的表达式表达，</p><p>$$<br>g_m=10I_d<br>$$</p><p>对于亚阈值区的器件来说，$I_d$与$V_{gs}$的关系如下，</p><p>$$<br>I_d=I_0e^{\frac{V_{gs}}{\zeta V_T}}<br>$$</p><p>其中，$\zeta&gt;1$，相当于在亚阈值区的器件基本可以视为三极管，但是其等效热电压会更高，对应出的跨导表达式如下所示，因此，其跨导也就更小，</p><p>$$<br>g_m=\frac{I_d}{\zeta V_T}\approx\frac{40I_d}{\zeta}<br>$$</p><p>因此，一般来说，$g_{mN}:g_{mQ}=k$，其中，$k\in(0,1)$</p><p>再回到我们的增益表达式，如下所示，</p><p>$$<br>G=\frac{1+k}{1+k+g_{mN}R}<br>$$</p><p>这个表达式的取值范围为$G\in [0,1]$，说明在这个电路的配置下，正反馈的回路表现为对信号的衰减，其增益小于1。</p><h4 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h4><p>我们再来看另外一种情况，如下图的b所示，</p><img src="/2023/09/16/bandgap-de-fan-kui-ji-xing-yi-ji-wen-ding-dian-wen-ti/c3a465a80ea61ff8f84e348f2fbde1aee13ea42989036535400ae3054d860cf7.png" class="" title="picture 0"> <p>在这种情况下，信号由MN1的栅-&gt;MP1的漏-&gt;MP2的栅-&gt;MN2的漏-&gt;MN1的栅这一正反馈回路传递，我们先计算一下由MN1的栅到MP1的漏的增益，</p><p>$$<br>G_1=\frac{g_{mN}}{1+g_{mN}(1/g_{mQ})}\frac{1}{g_{mP}}<br>$$</p><p>我们再来计算由MP2的栅到到MN2的漏的表达式，如下所示，</p><p>$$<br>G_2=g_{mP}(1/g_{mN}+R+1/g_{mQ})<br>$$</p><p>当我们把上面的两个表达式写在一起时，可以得到如下的表达式，</p><p>$$<br>G=G_1G_2=\frac{g_{mN}(1/g_{mN}+R+1/g_{mQ})}{1+g_{mN}(1/g_{mQ})}<br>$$</p><p>将关系$g_{mN}:g_{mQ}=k$代入表达式后，可以得到如下的表达式，</p><p>$$<br>G=\frac{1+k+g_{mN}R}{1+k}<br>$$</p><p>从这个表达式中，可以发现，这种电路配置下，正反馈环路的增益大于1，使得电路会产生不稳定的情况。</p><h3 id="总结一下-1"><a href="#总结一下-1" class="headerlink" title="总结一下"></a>总结一下</h3><p>我们可以现在总结一下这两个电路的异同，这两个电路的区别在于，正反馈回路最一开始的跨导很重要，其决定了电路的增益。如果需要抑制正反馈环路的增益，需要在环路最开始的跨导上应用源退化电阻，也就是（a）电阻，从而使得跨导降低，降低正反馈环路的增益大小。从公式上来看，源退化电阻会导致$G_1$的增益中的跨导部分降低一定的倍数；然而另一侧的源退化电阻会导致$G_2$的增益中的负载部分上升一定的倍数。如果要使增益小于一，则要令增益中降低的倍数大于上升的倍数，因此，在产生$G_1$增益的一侧要应用更大的源退化电阻，因为两个三极管的$g_{mQ}$的值一样，所以源退化电阻大的支路是存在电阻的一侧。自然，为了保证一开始的跨导在电阻一侧，所以电阻一侧的PMOS负载应为二极管连接型。</p>]]></content>
      
      
      <categories>
          
          <category> Bandgap问题分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bandgap </tag>
            
            <tag> 稳定性分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Razavi——CMOS锁相环设计第一章（振荡器基本概念）</title>
      <link href="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/"/>
      <url>/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近都Pual Gray的基本书之后，发现这种读书方法非常有效，可以记住很多内容，于是，我决定开启一个新的篇章，来记录我的锁相环基础学习之路。</p><h2 id="振荡器基础理论"><a href="#振荡器基础理论" class="headerlink" title="振荡器基础理论"></a>振荡器基础理论</h2><p>在锁相环中，振荡器起到了非常重要的作用，作者前五章都在叙述振荡器设计。本章主要给出一些学习更加高级的内容的基础知识。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/6cb86bf0b9ebb563a87df98f312f983265e05d9347a21988aac4ed0c07fe13cd.png" class="" title="picture 0">  <p>振荡器和一个钟摆模型非常类似，钟摆模型是将能量在重力势能和动能之间来回转换，使得它能够来回摆动，钟摆最终会停下来源于铰链的摩擦和空气阻力在每一个振动周期中都将此系统的部分能量转换为了热能。为了维持住这部分振荡，需要在外部对振荡器施加能量。注意：钟摆的周期与振幅无关。</p><h3 id="振荡反馈系统"><a href="#振荡反馈系统" class="headerlink" title="振荡反馈系统"></a>振荡反馈系统</h3><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/f18c4d9ebdd65c5ad0842d51f59d88b6ae073e8a4abaef5e6f3a78128fc8c409.png" class="" title="picture 1">  <p>对于上面这个反馈系统来说，其传输函数如下所示，</p><p>$$<br>\frac{Y(s)}{X(s)}=\frac{H(s)}{1+H(s)}<br>$$</p><p>如果分母（denominator）变为零，即$H(s)=-1$的条件，会导致传输函数趋于无穷大。在这种情形下，开环传输函数表现为增益为1且存在180度的相位移动，变现为如下的幅频-相频响应。</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/e00d70c79306e88cf85bee193d036ebc12a43fe748fe89541ad39b7f245349b8.png" class="" title="picture 2">  <p>上面的条件称为巴克豪森准则（Barkhausen’s Criteria），总结下来的数学表达式如下所示，</p><p>$$<br>|H(j\omega)|=1<br>$$</p><p>$$<br>\angle H(j\omega)=180\deg<br>$$</p><p>另一方面，思考这一个问题，如果这个系统没有输入，那么，这个系统还会振荡起来吗？答案是肯定的，因为系统的宽带白噪声会被当作是输入，在整个系统的环路中，不断地被放大，最终形成振荡。</p><h3 id="更加深刻的理解"><a href="#更加深刻的理解" class="headerlink" title="更加深刻的理解"></a>更加深刻的理解</h3><p>对振荡器的分析步骤：</p><ol><li>打开环路，分析环路增益。</li><li>设置初始条件。</li><li>将一个正弦波注入到闭环电路中，并且计算使得该点阻抗变为无穷大的DC工作点。</li></ol><h4 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h4><p>分析下面的电路，观察其是否可以振荡？</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/03f16f0018898d3c7d3026a87cb0b052dbd03cec0f15e43301ca41cf0b419c88.png" class="" title="picture 3">  <p>该电路为无源负载CS放大器，挂载了输出电容，可以直接写出该点的表达式$H(s)$，如下所示，</p><p>$$<br>H(s)=-g_m(R_D||\frac{1}{sC_L})<br>$$</p><p>可以看出，该表达式最多提供不超过270度的相移，无法使得相移为360度，因此无法产生振荡。</p><p>我们再从阻抗的角度来分析一下这个电路，该电路的M1的漏极（输出）位置的阻抗大小为，</p><p>$$<br>Z(s)=R_D||\frac{1}{g_m}||\frac{1}{sC_L}=\frac{R_D}{R_D(sC_L+g_m)+1}<br>$$</p><p>可以看出，这个表达式无论取什么值，都不会使得阻抗的模趋于无穷大，所以自然不会产生振荡。</p><h4 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h4><p>下面这个这个电路通过一个延时线的作用，将信号延迟$\Delta T$，从MOS管漏出发的电压经过了$\Delta T$的时间才会到达栅极，下面我们来研究一下这个电路的起振条件和振荡频率。</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/7a8841504d4f9a0709bf58f6c557bfb6057cefa9d7012d573b9bc9979778a754.png" class="" title="picture 4">  <p>首先，先求出电路的开环增益，如下所示，因为做了延时$\Delta T$，所以，其相位要往后推移$s\Delta T$，即$\Delta \phi=-s\Delta T$，可以把$e^{s\Delta \phi}$想象成一个单位相量，其角度为$\angle e^{s\Delta \phi}=\angle(cos\Delta \phi+jsin\Delta \phi)=\Delta \phi$，即使得原先的相量移动了$\Delta \phi$的相位，如下所示，</p><p>$$<br>H(s)=-g_mR_De^{-s\Delta T}<br>$$</p><p>如果需要起振，则需要$H(s)=1$，即，</p><p>$$<br>\angle e^{-s\Delta T}=\omega_0 \Delta T=\pi<br>$$</p><p>化简一下就得到了如下的关系，</p><p>$$<br>f_0=\frac{1}{2\Delta T}<br>$$</p><p>我们也可以从阻抗的角度来分析这个问题，计算一下该电路输出点的闭环阻抗，从如下图中进行考虑，</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/e7ac348aa3c415c921371651bb814d0ac27a3b71cede8422a020f76fa65d57c2.png" class="" title="picture 5">  <p>$$<br>\underbrace{\frac{v_x}{R_D}}+\underbrace{g_me^{-s\Delta T}v_x}=i_x<br>$$</p><p>化简上面的式子，得到如下的阻抗表达式，</p><p>$$<br>Z(s)=\frac{v_x}{i_x}=\frac{R_D}{1+\underbrace{g_mR_D}<em>{Magnitude}\underbrace{e^{-s\Delta T}}</em>{Phase}}<br>$$</p><p>所以根据先前的振荡条件，我们需要如下的两个条件，使得振荡存在并且一直持续下去，</p><p>$$<br>g_mR_D=1<br>$$</p><p>$$<br>e^{-s\Delta T}=-1<br>$$</p><p>其中第二个式子只要保证$f_0=\frac{1}{2\Delta T}$即可，与我们之前推导的一样。</p><h4 id="环路振荡器的输入激励"><a href="#环路振荡器的输入激励" class="headerlink" title="环路振荡器的输入激励"></a>环路振荡器的输入激励</h4><p>这里需要特别注意，当环路增益为1时，并且处于正反馈时，两种不同的输入会产生不同的输出。当激励为冲激信号时，输出为稳定的正弦波；但当输入为稳定正弦波的时候，输出为不断增大的正弦波（除非存在某种非线性导致增长被抑制）。</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/a37e50d7f9ea65ef96b089fda86e348ef8aef104445cd0f76a383ed5a71b0a3e.png" class="" title="picture 12">  <h4 id="重新分析起振条件"><a href="#重新分析起振条件" class="headerlink" title="重新分析起振条件"></a>重新分析起振条件</h4><p>我们需要注意$H(j\omega_0)=1$的条件意味着电路在振荡的边缘，如果PVT略微发生变化，使得$H(j\omega_0)&lt;1$，那么这种振荡都会不复存在。进一步来说，这种条件意味着大信号振荡是非常困难的：如果振荡幅度大到电路出现了非线性，那么，电路的环路增益都会小于1，不满足振荡条件。由于上述的两种原因：1. PVT变化 2. 非线性导致增益下降；振荡器通常的环路增益要大于1。</p><p>对于$H(j\omega_0)&gt;1$的条件来说，读者可能会产生其他的疑惑。举个例子，当环路增益为$H(j\omega_0)=2$时，闭环增益为$H(j\omega_0)/[1-H(j\omega_0)]=2$，这个值并不是无穷大，那么这个电路如何震荡呢？实际上电路会重新调整自己找到一个新的频率，使得闭环增益趋于无穷大，这时候的频率的实部不一定为零，表示了其幅度不断增大的特征。具体计算内容可以查阅本书的附录1.</p><h4 id="在DC处正反馈无穷大"><a href="#在DC处正反馈无穷大" class="headerlink" title="在DC处正反馈无穷大"></a>在DC处正反馈无穷大</h4><p>我们知道如果在特定频率$\omega_0$处观察到了正反馈，那么会引起在该频率处的振荡发生。但如果是在DC处存在负反馈呢？举个例子，可以观察下图所示的电路，</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/978a598bc61f0a335f70b06db18afbb2d88cdf7c32aa045bcae8229af4998614.png" class="" title="picture 13">  <p>该电路在DC处存在正反馈，为两级共源放大器的级联，该电路的低频环路增益比1要大，这个电路会直接Latch up，直接锁死，这个电路其实是一个典型的锁存器。我们称这个电路再生（regenerates）到VDD和VSS，常用作记忆模块。为了避免发生锁死，振荡器常常设计成在DC处是负反馈，或者在DC处是正反馈，但反馈的环路增益比一小很多。</p><h3 id="基本环形振荡器（Ring-Oscillators）"><a href="#基本环形振荡器（Ring-Oscillators）" class="headerlink" title="基本环形振荡器（Ring Oscillators）"></a>基本环形振荡器（Ring Oscillators）</h3><p>环形振荡器有两个优点：设计起来非常灵活；频率调谐范围很广。这一部分仅仅是建立一些基础知识，但在后面的章节中，会介绍更加高级的环形振荡器的概念。</p><p>根据先前的分析，单级和双级的共源放大器都不能够实现稳定的振荡，让我们来看看三级的共源放大器的级联是否可以实现稳定的振荡呢？</p><p>下图给出了具体的三级级联的共源放大器的电路图，</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/7a24afa9ba98c827bfbacc15d51e0a0f0cccbcad701110618e0cb343c83626e4.png" class="" title="picture 15">  <p>该电路的DC处的环路增益为负，因此为负反馈，其环路增益如下所示，</p><p>$$<br>LG(s)=[-g_m\frac{R_D}{1+sC_LR_D}]^3=-\frac{(g_mR_D)^3}{(1+sC_LR_D)^3}<br>$$</p><p>为了保证在$\omega_0$处起振，需要满足下面的两个条件，</p><p>$$<br>|LG(\omega_0)|=\frac{(g_mR_D)^3}{(1+sC_LR_D)^3}=1<br>$$</p><p>$$<br>\angle(LG(\omega_0))=arctan(\omega_0C_LR_D)=\frac{\pi}{3}<br>$$</p><p>根据相角条件可知下面的关系，</p><p>$$<br>\omega_0C_LR_D=\sqrt{3}<br>$$</p><p>所以，再将此关系代入幅值关系中，有，</p><p>$$<br>g_mR_D=2<br>$$</p><p>换句话说，每一级的共源放大器必须保证有2倍的放大倍数从而保证振荡的发生。我们再来仔细分析一下这个电路，由于每一级在DC处就有180度的相位移动，再加上在$\omega_0$处的相位移动了60度，每一级的$\omega_0$处的总相位移动为240度；另一方面，我们这边考虑寄生$C_L$是否包含了所有的电阻，答案是肯定的。这边$C_L=C_{GS}+C_{DB}+C_{GD}(miller)$。</p><h4 id="当级联的共源放大器的级数-N-gt-3-的情形"><a href="#当级联的共源放大器的级数-N-gt-3-的情形" class="headerlink" title="当级联的共源放大器的级数$N>3$的情形"></a>当级联的共源放大器的级数$N&gt;3$的情形</h4><p>首先我们要保证DC处的反馈为负反馈，以防止发生锁存现象，这就要确保级联的共源放大器的级数为奇数。在这个条件下，每一级的相位移动为$\pi/N$，以保证最终的相位移动为$2\pi$。根据先前的三级级联共源放大器组成的环路振荡器来说，有下面的相角关系，</p><p>$$<br>arctan(\omega_0R_LC_L)=\pi/N<br>$$</p><p>再根据幅度关系给出下面的关系，</p><p>$$<br>g_mR_D=\sqrt{tan^2\frac{\pi}{N}+1}<br>$$</p><p>上面的这个增益随着N的增大逐渐减小，最终趋近于1.</p><h4 id="振荡的幅度"><a href="#振荡的幅度" class="headerlink" title="振荡的幅度"></a>振荡的幅度</h4><p>之前说过，如果环路增益为1，那么仅仅会在$\omega_0$处产生一个很小的震荡幅度。实际上，我们现在分析的这种三级环形振荡器需要产生一个几乎由VDD到VSS的摆幅，因此需要小信号低频增益比2大，2仅仅是一个最小值。我们认为非线性导致电路的环路增益下降，致使最终的平均环路增益下降到1。</p><p>根据上面的结论，这种环形振荡器的幅度取决于电路的非线性，因此，如果要确切地计算出振荡器的振荡幅度是很困难的。</p><h4 id="基于反相器的环形振荡器"><a href="#基于反相器的环形振荡器" class="headerlink" title="基于反相器的环形振荡器"></a>基于反相器的环形振荡器</h4><p>如下图是一个典型的基于反相器的环形振荡器，</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/726461e7bb39c6533418c7eb9411075bea86a9b6a7a6f2583dd55f675808adf8.png" class="" title="picture 16">  <p>假设电路从状态：$V_X=V_Y=V_Z$开始工作，其每一级的增益均为$-(g_{mN}+g_{mP})(r_{oN}||r_{oP})$，这个值通常来说远远大于2。电路中的噪声会导致这三个电压发生再生，直到振荡器的这三个电压分别到达了电源电压和地电压；并且保证DC处的反馈为负反馈，防止电路变成一个锁存器。根据这种电路的工作原理，我们可以马上给出电路工作的周期，假设一个反相器的延迟是$T_D$，那么这种三个反相器级联的电路产生的振荡器的周期为$6T_D$。一般来说，反相器级数越多，其振荡周期越长，其波形也越趋近于方波，反相器级数越少，由于留给管子充电的时间很短，所以会趋近于锯齿波，如下所示，</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/e141f8c338b83a28f2a28d2e4183da0ea93c4aedb314582693ebc7b5e525e45f.png" class="" title="picture 17">  <p>几个数字层面的设计原理揭示了环形振荡器的一些性质，当电源电压增大时，反相器的延时会减小，对应的振荡频率会随着电源电压的增大而增大，因此，其振荡频率对供电电压V非常敏感；每一次反相器反转消耗的能量为$C_LV_{DD}^2$，其在一秒内要翻转$f_0$次，因此每秒消耗的能量（功率）为$f_0C_LV_{DD}^2$，如果存在$n$个反相器，那么总功率为$nf_0C_LV_{DD}^2$。</p><h3 id="基本LC振荡器"><a href="#基本LC振荡器" class="headerlink" title="基本LC振荡器"></a>基本LC振荡器</h3><p>LC振荡器相对于环形振荡器有一些优点：</p><ul><li>更低的相位噪声</li><li>可以工作在更加高的频率上</li></ul><p>基于上述原因，在很多应用中都采用LC振荡器。对于LC振荡器的分析主要依赖于LCtank的模型和性质，因此，我们需要先学习一些简单的LC电路知识。</p><h4 id="LC电路的概念"><a href="#LC电路的概念" class="headerlink" title="LC电路的概念"></a>LC电路的概念</h4><p>从最基本的电路理论中我们可以知道电容的I-V特性为导数特性，时域数学表达如下所示，</p><p>$$<br>I=C\frac{dV}{dt}<br>$$</p><p>频域的数学表达如下所示，</p><p>$$<br>Z(s)=\frac{V(s)}{I(s)}=\frac{1}{sC}<br>$$</p><p>类似的，电感的I-V特性为积分特性，时域数学表达式如下所示，</p><p>$$<br>V=L\frac{dI}{dt}<br>$$</p><p>其频域表达式如下所示，</p><p>$$<br>Z(s)=\frac{V(s)}{I(s)}=sL<br>$$</p><p>这两种器件的并联展现出奇特的性质，如下图所示，</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/38c63c3d33cb38ceaef114eb4de71b4944d1568a3201899f590b5f8d428a7c2d.png" class="" title="picture 18">  <p>LC并联组成的电路称为LC Tanks，其低频的阻抗主要取决于电感L，其高频的阻抗主要取决于电容C，主要原因是因为并联这种解法阻抗大小主要取决于阻抗小的原件，在低频处，电感短路，电容开路，因此，电感的阻抗小，这时，LC tank的阻抗主要取决于电感；反之，在高频处，电容的阻抗小，阻抗主要取决于电容。对于阻抗的幅度和相角来说，都是低频取决于电感，高频取决于电容的，从上面的幅频-相频响应的两张图中可以很容易地看出这个特点。</p><p>在谐振频率$\omega_0$上，我们可以看出，两个阻抗互相抵消，在分母上形成趋近于零的量，整个阻抗趋于无穷大，因此，这个LC tank就是一个典型的谐振器。</p><p>电感由绕线组成的，绕线本身存在一定的电阻，考虑到电感本身的串联电阻，我们将理想的LC tank模型改造成如下的实际模型，引入串联电阻$R_S$以及等效并联电阻$R_P$</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/96ce9c60327e8f718a22b3bac73512305f1bccf076318e133d74be2a85af761c.png" class="" title="picture 19">  <p>在许多场合里，使用等效并联电阻计算会更加方便。需要注意的是，上述的电路并不是在所有频率上都是等效的，仅仅是在一个频段内可以互相等效。在推导并联器件与串联器件之间的关系的时候，我们采用下面的数学关系进行计算，</p><p>$$<br>L_1s+R_s=L_ps||R_p<br>$$</p><p>将其全部展开后有下面的表达式，</p><p>$$<br>j\omega (L_pR_s+L_1R_p-L_pR_p)-\omega^2L_1L_p+R_sR_p=0<br>$$</p><p>利用虚部和实部分别为零的条件消去变量$R_p$，有下面的关系，</p><p>$$<br>L_p=\frac{R_s^2}{\omega^2L_1}+L_1<br>$$</p><p>可以观察一下这个数量级，Rs一般在10这个量级，但是一般频率至少是在$GHz$这个级别，这就保证了第一项$\frac{R_s^2}{\omega^2L_1}$基本可以忽略不计，可以得到下面的关系，</p><p>$$<br>L_p\approx L_1<br>$$</p><p>最后可以得到下面的关系，</p><p>$$<br>R_p\approx \frac{L_1^2\omega^2}{R_s}<br>$$</p><p>根据上面的表达式，可以发现串联电阻越小、并联电阻越大，这个RC tank越理想。需要注意的是，如果我们的频率非常低，导致$L_p\approx L_1$的关系不再成立，上面的表达式就不一定成立了，但对于我们大多数的应用来说，这种情形都不会出现。</p><p>另一个需要注意的是，上面的$R_p$表达式仅仅是一个帮助简化我们分析的表达式，实际上这个量与我们的频率是相关的；另一方面，由于趋肤效应的存在，串联电阻本身也是与频率相关的。</p><h4 id="案例一-1"><a href="#案例一-1" class="headerlink" title="案例一"></a>案例一</h4><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/271017ae896e2d8a62aa6475a2b2d96a400a267877be8ffa141cd439d02a422f.png" class="" title="picture 20">  <p>如上图所示的一个并联RC tank，工作在$5GHz$的谐振频率上，其采用了$5nH$、串联电阻为$20\Omega$的电感，求在$5GHz$频率下的等效并联电阻以及其频率变化到$5.5GHz$时，引入的误差。</p><p>$$<br>R_p=\frac{\omega^2L_1^2}{R_s}\approx 1.23k\Omega<br>$$</p><p>当频率变为$5.5GHz$时，重新计算$R_p$得到下面的结果，</p><p>$$<br>R_p=\frac{\omega^2L_1^2}{R_s}\approx 1.49k\Omega<br>$$</p><p>下面给出阻抗的幅频-相频图，</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/8e03872aa438fa7764a348d2113c8ec106ce9949a82f27be190851e6b4e133d2.png" class="" title="picture 21">  <p>可以看出，当并联电阻存在时，其阻抗在谐振频率不会上升至无穷大，而是上升到$R_p$；另一方面，当RC tank的损耗变小，也就是$R_p$变得更大时，其幅频-相频曲线会变得更加的陡峭，变化率会更大。</p><h4 id="品质因数-Q"><a href="#品质因数-Q" class="headerlink" title="品质因数$Q$"></a>品质因数$Q$</h4><p>为了比较电感的好坏，定义品质因数来衡量这一特质，其符号为$Q$。对于这一指标，其数值越高意味着电感越理想，其数值越低意味着损耗越大。对于一个有串联电阻$R_s$的电感$L_1$来说，定义$Q$为如下表达式，</p><p>$$<br>Q=\frac{L_1\omega}{R_s}<br>$$</p><p>上面表达式的实际意义在于比较电感的阻抗和串联电阻的大小，并给出它们之间的比例；其分子表示了想要的阻抗，而分母上则是我们不需要的阻抗，代表了损耗。假设$R_s$不跟随频率发生变化，那么$Q$就与频率成正比，频率越大，$Q$越大。如果我们把$Q$的表达式代入到之前计算等效并联电阻的表达式中，可以得到下面的关系，</p><p>$$<br>R_p=Q\omega L<br>$$</p><p>这个表达式告诉我们Q越大，$R_p$越大，这个RC tank越理想；另一方面，Q越大，阻抗的相角曲线在谐振频率处的变化斜率越大。</p><h4 id="调谐放大"><a href="#调谐放大" class="headerlink" title="调谐放大"></a>调谐放大</h4><p>并联的RLC tank是一个很好的调谐负载的例子，这种负载在特定频率达到最大值，将它和电流源和电阻放在一起，调谐电路可以作为放大器的负载，这种结构可以提供窄带放大的功能，如下图所示，</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/4b3c52379802dfce4eac3e307e35c1f5385aaff1078d44db085b52fe0fba02c5.png" class="" title="picture 22">  <p>这个电路从输入到输出的传输函数如下所示，</p><p>$$<br>\frac{V_{out}}{V_{in}}(s)=-g_m[(L_1s||R_p||\frac{1}{sC_1})]<br>$$</p><p>上面的表达式表明，在谐振频率处，电感和电容互相抵消，形成了上图中（b）对应的电路，产生了$-g_mR_p$的增益，带来了$\pi$的相移，其传输函数的幅频-相频曲线如下所示，</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/c780a88cde0e793ba874d9caff3bbe98c755ae25db737ae3f8b11583c04d66bd.png" class="" title="picture 23">  <p>从上图中我们可以看出这是一个典型的带通滤波器。</p><h4 id="LC振荡器组成反馈系统"><a href="#LC振荡器组成反馈系统" class="headerlink" title="LC振荡器组成反馈系统"></a>LC振荡器组成反馈系统</h4><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/7841db689e465c734ec03a6d6ba0e41763cccfccec2e108b9865c5abc099cd15.png" class="" title="picture 24">  <p>如上图所示，两个共源放大器构成了两级放大器，并且形成了反馈结构，该放大器的负载由$RLC$并联放大器组成，在频率为$\omega_0=1/\sqrt{L_1C_1}$处，电路的放大倍数为$(g_mR_p)^2$，并且相移为$-2\pi$，下面的图给出了一个更为常见的LC振荡器的画法。</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/0dbed8a5248392cb837bd8ad0f129d3e46d8ee7faa75097223e744751a7f27fe.png" class="" title="picture 25">  <p>下面给出了该振荡器的输出波形，可以看到输出的共模水平在$V_{DD}$处，并且如果你观察下面的</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/624f6da980bbd642c779cb958e95f593879efd127dc7681d05ad23f302fd9867.png" class="" title="picture 26">  <p>从电流角度进行观察，读者可以发现MOS管的电流是在0和最大值之间往复的，如上图所示，是一个方波的波形，但是电压却是正弦波。<strong>这是由于电流的方波的高次分量$2\omega$、$3\omega$等等被上方的LC滤波器结构滤除了。</strong>这个结论很有意思，本人从来没有这么考虑过电路，又从另一个角度说明了从电流的角度考虑问题是多么重要。上述电路还有超压的问题，因为电路的Bias Point是在VDD的，所以，其最大Vp叠加VDD会导致管子的$V_{ds}$超过电路可以承受的范围。</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/34e01f02da471a1227458a655ff4aa4105531fa063c6e220e55d18a59d134f6e.png" class="" title="picture 27">  <p>如图所示的电路的偏置电流没有办法很好得定义，当栅上的电压超过$V_{DD}+V_p$时，漏电流完全取决于管子的特性，并且与$V_{DD}$是直接相关的。为了解决上述的问题，我们给出了如下的电路以改善这一现象。</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/3c48cf467508d44adf76243c684bb47e803f43ec64f566a541ab683b023b81dc.png" class="" title="picture 28">  <h4 id="差分反馈振荡器"><a href="#差分反馈振荡器" class="headerlink" title="差分反馈振荡器"></a>差分反馈振荡器</h4><p>先前都是考虑单端的RC振荡器，现在我们来观察以下差分的RC振荡器，如上图所示，在NMOS输入对的下方加入一个尾电流源，就可以构造一个差分的RC振荡器。我们先如下图所示，考虑输入为大信号正弦波时的电路特性，</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/ae33ef359a3a166b91ef468a9645867b5cf723c330e156301f42fb0e8ef1f4ab.png" class="" title="picture 29">  <p>当输入信号的摆幅足够大时，两个输入对管就会经历一个完整的开关过程，经过两个管子的电流将会在最大值$I_D$与$0$之间变化。这里因为预先假设了信号的摆幅足够大，所以漏电流可以认为是一个方波，因为信号摆幅足够大时，管子在开与关之间切换的速度就很快，不会存在什么中间状态。因为负载的频率响应如下图所示，</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/f58269cd69a2ad146a2270c62732708caf35340dbc5a3a07c8bf6026c3137bee.png" class="" title="picture 30">  <p>所以基波看到的阻抗是最大的，方波的更加高次的量看到的阻抗显著减小，所以输出点的电压是一个正弦波。接下去我们可以计算以下输出的正弦波的摆幅，由于下图所示的对方波进行傅里叶变换后的基波的摆幅为$4/\pi\approx1.27$倍（<strong>建议读者把这个数值记下来，非常有用的，记住方波的基波比方波自身的摆幅要大</strong>）。假设尾电流源的电流大小为$I_{SS}$，那么，其电流方波的最大值为$I_{SS}$，其摆幅为$I_{SS}/2$，其中的正弦波分量的摆幅为$(4/\pi)I_{SS}/2$。该频率为中心频率，其对应的负载阻抗为$R_p$，因此，输出的电压的摆幅为，</p><p>$$<br>V_p=\frac{2}{\pi}I_{SS}R_p<br>$$</p><p>我们马上可以给出$V_{pp,diff}$的值的大小，如下所示，需要注意的是，在计算的过程中，不要把这些倍数搞错了，要仔细计算和分析。</p><p>$$<br>V_{pp,diff}=4V_p=\frac{8}{\pi}I_{SS}R_p<br>$$</p><p>接下去我们来考察电路的反馈问题，如下图所示，有两种接法，其中左图的接法是没办法震荡的，因为是负反馈，这个读者一看就能明白。</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/f365f0509d10aab26287fcbb677a1b968e9821d56f2c825b05cdfbdecfc17221.png" class="" title="picture 31">  <p>右图的接法可以保证正反馈的极性。根据我们推导的$V_{pp,diff}$的表达式，我们可以知道，电路的峰峰摆幅为$(8/\pi)I_{SS}R_p$，这个电路是使用最为广泛的，电路非常稳健，并且起振条件也比较合理，$g_mR_p=1$。</p><h3 id="将LC振荡器作为单端口器件进行分析"><a href="#将LC振荡器作为单端口器件进行分析" class="headerlink" title="将LC振荡器作为单端口器件进行分析"></a>将LC振荡器作为单端口器件进行分析</h3><p>这种分析方法可以给我们带来一些不一样的视角，得到一些有用的结论。在本章的一开始，我们说过，一个理想的钟摆的摆动将会一直持续下去；对于一个不理想的钟摆来说，在其每次摆动的过程中，轻轻推它以下，也可以让它一直摆动下去。我们电路里面也是类似的原理，下图中的电路对应了那个理想的钟摆。</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/3af2281cc74a4d0bc538b43341f19a8a8cf811f07880809c3164218e982eafe4.png" class="" title="picture 32">  <p>假设我们有一个初始条件：C1上存在固定电压$V_0$，接下去释放这个电路，电容开始通过电感L1进行放电，也就是说，在电容上存储的电能$(1/2)C_1V^2$开始逐渐转换为磁能$(1/2L_1I^2)$。</p><p>$$<br>t=t1\rightarrow V_{out}=0<br>$$</p><p>上面这个时刻，所有的能量全部转换为电感中的磁能，这一点对应了钟摆将重力势能全部转换为动能的时刻，根据能量守恒原理，我们可以直接写出电感中电流的表达式，</p><p>$$<br>I(t_1)=\sqrt{\frac{C}{L}}V_0<br>$$</p><p>在$t_1$这个时刻之后，电感中的电流继续流过电容，将其向相反的方向进行充电，并且迫使$V_1$变成负值。在$t_2$时刻，有下面的表达式，</p><p>$$<br>t=t2\rightarrow V_{out}=-V_0<br>$$</p><p>我们可以继续扩展上述结论到一个有损的LC tank中，如下图所示，</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/adfa17d7952e2e6e0349a16e0a79a7d1717c36901a525fc12aee8785e2dbda5c.png" class="" title="picture 33">  <p>只要$V_{out}\neq 0$，就会存在一个电流流过$R_p$，从而LC tank中存储的能量通过$R_p$转换为热能。因此，随着时间的变化，电感中的电流（代表了磁能的大小），电容中的电压（代表了电能的大小），会随着时间的增长而逐渐减小。</p><p>如果在电路中增加了一个负阻$-R_p$，如下图所示，</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/abc8a1b75a954be7f6b42ae170c7989bb057d45da6a7f50eb02fcefa1e963a97.png" class="" title="picture 34">  <p>那么并联的等效阻抗将会趋于无穷大，也就表示了没有能量会在震荡的过程中发生损耗。注意到，当负阻越大，在这个结构里面表示负阻起到的作用越差，因为负阻和正阻是并联的关系。如果我们想要整个震荡更强，那么需要减小负阻的阻值，以增大负阻的作用。随着震荡逐渐增强，负阻的阻值一般会饱和，逐渐下降，最终阻值和正阻相等，其二者达到一种平衡。</p><h4 id="负阻电路"><a href="#负阻电路" class="headerlink" title="负阻电路"></a>负阻电路</h4><p>接下去实现我们的负阻，需要注意到的是，负阻并不违背基本物理学，负阻的基本意思就是随着施加电压的增大，小信号电流会发生减小的器件。交叉耦合对就是这样一个简单的例子。</p><p>下面给出另一个可以产生负阻的结构，如下图所示，</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/0b7e96233408fd3f44bda3e8228d579a5c342e7f66c950cca5a3cbc0f8aaf056.png" class="" title="picture 36">  <p>这个结构非常重要，三点式振荡器、Signal Buffer都是这种结构的衍生，注意到，在这个结构里面，MOS管的源并不一定非要接地。</p><p>我们先测量在图中电流源看到的阻抗大小，假设有电流$i_t$流入节点Y，这时，由于栅上没有电压，所以MOS管开路，电流流过C2电容，产生一个电压$i_t\frac{1}{sC_2}$，这时，电流继续流过C1，形成了电压降$i_t\frac{1}{sC_1}$，由于MOS管的栅源之间产生了对应的电压，M1管子形成了向上的电流$g_mi_t\frac{1}{sC_1}$，这个向上的电流在M1和C2组成的环路中形成了环流，对应C2上产生的电压为$(i_t+i_t\frac{g_m}{sC_1})\frac{1}{sC_2}$，那么，$v_t$电压自然可以直接写出来，就是C1上电压和C2上电压之和，也就是下面的表达式：</p><p>$$<br>v_t=i_t\frac{1}{sC_1}+i_t\frac{1}{sC_2}+i_t\frac{g_m}{s^2C_1C_2}<br>$$</p><p>面对这个表达式，我有以下的思考，一般电路中，我们不会遇到电容的阻抗相乘的情形，这是因为如下的分析：假设我们有一个电流流过一个电容，那么，电容上的压降为电流乘以电容的阻抗，这时，$s$在分母上，无论电容如何进行排布，电路不会出现电压表达式分母出现$s^2$项的情形，其本质是因为MOS管将电压项$f(\frac{1}{s})$直接乘上了$g_m$转换为了电流，这样，电流再流过电容转为了函数$f(\frac{1}{s^2})=f(\frac{1}{s})\frac{1}{s}$。正是因为$g_m$的存在，才会出现这种现象。根据上述表述，这一项的作用与$g_m$成正比，$g_m$越大，意味着我的函数$f(\frac{1}{s^2})$作用越强。</p><p>拆分一下上面的表达式，可以画出如下的等效电路图：</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/292870f8b0ffe2d93a597b027c41c518c79bc8292c6a5311603e7063f9ec4509.png" class="" title="picture 37">  <p>可以看到，两个电容阻抗之和等效于两个电容串联，再串联上一个负阻，如果将电流源变为一个电感，那么，整个电路的谐振频率为，</p><p>$$<br>f_{osc}=\frac{1}{\sqrt{LC}}=\frac{1}{\sqrt{L\frac{C_1C_2}{C_1+C_2}}}<br>$$</p><p>这里需要用到一个串联电阻和并联电阻之间的转换关系，如下所示，</p><p>$$<br>R_p//sL=R_s+sL<br>$$</p><p>可以得到下面的关系，</p><p>$$<br>\frac{R_psL}{R_p+sL}=R_s+sL<br>$$</p><p>求解$R_s$我们可以得到下面的关系，</p><p>$$<br>R_s=\frac{R_psL-R_psL-(sL)^2}{R_p+sL}<br>$$</p><p>通常来说，$R_p&gt;&gt;sL$，所以可以得到下面的关系，</p><p>$$<br>R_s\approx\frac{\omega^2L^2}{R_p}<br>$$</p><p>将上述串联电阻关系带入关系$R_s=\frac{g_m}{C_1C_2\omega_0^2}$可以得到如下的关系</p><p>$$<br>g_mR_p=L_1^2\omega_0^4C_1C_2=\frac{(C_1+C_2)^2}{C_1C_2}<br>$$</p><p>如果我们假设$C_1$和$C_2$的电容值是一样的，那么，晶体管就需要提供4倍以上的增益。根据AC接地位置的不同，我们可以给出以下的三种不同的结构，</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/a96f50af8894605e2aafae5e886a3c140932f822f7cb2d839a6407d37111ed1f.png" class="" title="picture 39">  <h3 id="压控振荡器"><a href="#压控振荡器" class="headerlink" title="压控振荡器"></a>压控振荡器</h3><p>实际应用中，由于振荡器的振荡频率是PVT的函数；又或者说需要不同的频率，因此需要将振荡器设计成可以调节频率的器件，设计出一个可以通过电压调节频率的器件，称为VCO。</p><p>下面的图给出了VCO的特性曲线，其输入为电压，输出为频率，中间用斜率$K_{VCO}$联系起来，由下面的公式表达，</p><p>$$<br>\omega_{out}=K_{VCO}V_{cont}+\omega_0<br>$$</p><p>下面给出了VCO输出电压的数学表达式，</p><p>$$<br>V_{out}=V_0cos[\omega_0t+\int K_{VCO}V_{cont}(t)dt]<br>$$</p><p>将上述表达式中的相位信息部分称为excess phase，$\phi_{ex}$，如下所示，</p><p>$$<br>\phi_{ex}=K_{VCO}\int V_{cont}(t)dt<br>$$</p><p>将上述表达式写为传输函数，如下所示，</p><p>$$<br>\phi_ex/V_{cont}(s)=\frac{K_{VCO}}{s}<br>$$</p><p>这个性质表明VCO有积分器的性质，意味着其目前的相位信息取决于过去时间的控制电压的大小，系统具有记忆的性质；另一方面，由于相位是时间的积分，所以，相位本身并不可以发生突变，但是频率是可以的，这一点也很容易理解。</p><h3 id="Nyquist围线"><a href="#Nyquist围线" class="headerlink" title="Nyquist围线"></a>Nyquist围线</h3><p>Nyquist围线本质上是一个复平面上的函数，这个函数的表达式是$H(s)$，其中$H(s)$是系统的开环传输函数，考察该函数在复平面上的图像：Nyquist围线，下图是一个典型的Nyquist围线，</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/40f1ce1db0ca27a5b8a8c32ca709d176066880f3b19918ce17f1490613a58a4d.png" class="" title="picture 40">  <p>从Bode Plot中读者可以很容易得出系统不稳定的结论，但是从Nyquist围线角度来看，围线围绕$(-1,0)$点顺时针旋转了两圈，意味着$1+H(s)$系统里面存在两个右半平面的零点，如果表示为闭环函数，该表达式的右半平面零点会变为闭环函数的右半平面极点，很明显系统是不稳定的。在这一案例中，Nyquist围线和Bode Plot得到了一样的结论。我们继续看下面的这个例子，</p><img src="/2023/09/15/razavi-cmos-suo-xiang-huan-she-ji-di-yi-zhang/7ae3a9d3f72873befd07064842a24e5147705eafd1ea5f2eb5253b780f573d20.png" class="" title="picture 43">  <p>从这个案例中，我们可以发现，电路的Bode Plot给出了系统是不稳定的这一结论，但是Nyquist围线围绕$(-1,0)$顺时针选中了一次，又逆时针旋转了一次，这个告诉我们系统不存在右半平面的零点，表示整个系统是一个稳定的系统。当然，Nyquist围线的结论是正确的。</p><p>下面我们总结如何根据Nyquist围线判断系统的稳定性的方法：</p><ul><li>如果围线在$|H(j\omega)|&gt;1$的条件下，穿过实轴负半轴<strong>奇数次</strong>，那么电路是不稳定的；</li><li>相反，如果穿过<strong>偶数次</strong>，那么系统就是稳定的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Razavi </tag>
            
            <tag> 锁相环设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PaulGray经典著作读书笔记第一章</title>
      <link href="/2023/08/25/paulgray-jing-dian-zhu-zuo-du-shu-bi-ji-di-yi-zhang/"/>
      <url>/2023/08/25/paulgray-jing-dian-zhu-zuo-du-shu-bi-ji-di-yi-zhang/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近感觉对一些电路的理解还不够深入，比如说Bandgap的噪声和PSRR计算，Bandgap的失调计算，这些内容我都没有思考过，每次想起都让我觉得心里不适。因此，我下定决定，再度回到本源，从基础开始，再学习一遍模拟IC设计，学习得到的经验都记录在我的博客里，形成一套阅读笔记，以供之后查看。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>作者主要想要表达的意思是，模拟IC设计涉及到很多模型的应用，如果要用好这些模型，设计者需要对模型的来源和近似程度有个比较透彻的了解才行，因此，估计本章都在进行模型的推导和解释工作。作者说，本章的重点主要放在半导体器件行为模型上的一些基本概念，以及如何通过等效电路来建模这些行为。</p><h2 id="PN结的耗尽区"><a href="#PN结的耗尽区" class="headerlink" title="PN结的耗尽区"></a>PN结的耗尽区</h2><p>反偏PN结广泛存在于IC设计中，并且产生了许多寄生电容，这些寄生电容大小与反偏电压的大小相关，除了产生寄生电容，PN结还对有源器件的其他特性产生影响，例如，</p><ul><li>击穿电压</li><li>输出电阻</li><li>jfet的工作特性</li></ul><p>总之，这个非常重要，所以在这里重点讨论了这个概念。</p><img src="/2023/08/25/paulgray-jing-dian-zhu-zuo-du-shu-bi-ji-di-yi-zhang/4292e58aa0eb933a043e85d857d1a0e7b43f7a272110ff3b36e67abc2753bf92.png" class="" title="picture 0"><h3 id="扩散运动产生真空电荷区"><a href="#扩散运动产生真空电荷区" class="headerlink" title="扩散运动产生真空电荷区"></a>扩散运动产生真空电荷区</h3><p>考虑上图$(a)$中的一个PN结，这个结的P区掺杂浓度定义为$N_A$ $atoms/cm^3$，N区掺杂浓度定义为$N_D$ $atoms/cm^3$。因为P区和N区的载流子浓度不一样，所以会产生扩散效应，P区的空穴扩散到N区，N区的电子扩散到P区，造成P区聚集了带负电的离子，N区形成了带正电的离子。由于可以移动的电子和空穴都因为扩散运动而消失了，只留下了不可移动的离子，并且P区的离子带负电，N区的离子带正电，造成在结附近的区域产生了大量的空间电荷并且导致了很强的电场。这个区域称耗尽区（Depletion Region，因为可以自由移动的电荷被耗尽了），或者被称为空间电荷区（Space-Charge Region）。值得注意的是，作者假设了耗尽区的边界和上图$(b)$中的边界一样，会有浓度的突变，边界非常陡峭，作者说这在大多数情形下都是一个非常好的近似。</p><h3 id="内建电势（电压）"><a href="#内建电势（电压）" class="headerlink" title="内建电势（电压）"></a>内建电势（电压）</h3><p>想象一个问题，将可乐和水倒在一起，可乐会扩散到水中，水会扩散到可乐中，最终的结果是液体中的可乐浓度处处一致。那么，PN结中的扩散也会导致最终PN半导体变得处处一致吗？</p><p>这两种情况产生不一样的结果的原因在于，可乐中的分子扩散到水中，并不会产生后果，而N型半导体中的电子扩散到P型半导体中，会导致P型半导体不再是电中性，在电荷层面不再平衡，虽然在浓度层面PN结有走向平衡的趋势，但是代价却是电荷层面的不平衡，这种不平衡会产生一个内建的电场，从而产生电势差。最终，浓度的不平衡和电荷的不平衡互相对抗，达到一种新的平衡。</p><p>如果PN结两侧外加电势差为0电荷的不平衡由下面的电势差表达式表达，</p><p>$$<br>\psi_0=V_Tln\frac{N_AN_D}{n_i^2}<br>$$</p><p>其中，热电压$V_T=26mV@300K$，$n_i$是本征半导体的载流子浓度，表示了在一个纯净的半导体中，例如，Si晶体中，电子和空穴的浓度，$n_i\approx1.5\times 10^{10}cm^{-3}$。</p><h3 id="计算N型与P型半导体耗尽层的宽度"><a href="#计算N型与P型半导体耗尽层的宽度" class="headerlink" title="计算N型与P型半导体耗尽层的宽度"></a>计算N型与P型半导体耗尽层的宽度</h3><h4 id="电荷守恒"><a href="#电荷守恒" class="headerlink" title="电荷守恒"></a>电荷守恒</h4><p>由于电荷守恒，两个结的横截面积是一样的，如果耗尽层在浓度为$N_A$ $cm^{-3}$的P型半导体中的宽度为$W_1$，耗尽层在浓度为$N_D$ $cm^{-3}$的N型半导体中的宽度为$W_2$，所以可以推导出如下的表达式，</p><p>$$<br>W_1N_A=W_2N_D<br>$$</p><p>简单来说，浓度小的宽度大，浓度大的宽度小，这样两侧的空间电荷区的电荷总量才能保持数量一致符号相反，保持整体呈现电中性。</p><h4 id="Poisson-Equation"><a href="#Poisson-Equation" class="headerlink" title="Poisson Equation"></a>Poisson Equation</h4><p>接下来要给出一维层面的Poisson公式，先给出通常的Poisson公式，</p><p>$$<br>\nabla^2\psi=f<br>$$</p><p>其中，需要解释的是拉普拉斯算子$\nabla^2$，根据定义来说，该算子施加于Scalar Field（标量）后，可以给出Scalar Field在某点处的曲率。简单来说，该算子就是一个峰（局部最大值）和谷（局部最小值）的检测器。根据上述描述，Poisson公式想要说的是，某标量场出现峰和谷的条件是，有一个外界的影响元$f$，换句话说，如果没有影响元$f$的存在，那么，该标量场就不会存在峰或谷值，体现为一个斜坡或者平台。</p><p>在静电学中，Poisson公式表示为如下，</p><p>$$<br>\nabla^2\psi=-\frac{\rho}{\varepsilon_0}<br>$$</p><p>其中，影响元$f$为电子，但是，由于电子可能处在不同的介质中，不同介质中，电子产生电场的能力是不一样的，这里使用Permittivity（介电常数）来衡量这一特性，介电常数越大，电子产生电场的能力越弱，介电常数越小，电子产生电场的能力越弱，下面给出一些常见的介质的介电常数。</p><table><thead><tr><th>Material</th><th>Relative Permittivity ($\varepsilon_r$)</th></tr></thead><tbody><tr><td>Vacuum</td><td>1 (by definition)</td></tr><tr><td>Air</td><td>1.0006</td></tr><tr><td>Distilled Water</td><td>~80 (at 20°C)</td></tr><tr><td>Quartz</td><td>~3.8</td></tr><tr><td>Common Window Glass</td><td>~4 - 7</td></tr><tr><td>Pyrex</td><td>~4.5</td></tr><tr><td>Teflon (PTFE)</td><td>~2.1</td></tr><tr><td>Rubber</td><td>~2 - 7 (depending on type)</td></tr><tr><td>Mica</td><td>~5 - 8</td></tr><tr><td>Polyethylene</td><td>~2.3</td></tr><tr><td>Barium Titanate</td><td>~1200 - 5000 (variable)</td></tr><tr><td>Crystalline Silicon</td><td>~11.7</td></tr><tr><td>Silicon Dioxide (SiO2)</td><td>~3.9</td></tr></tbody></table><p>真空中的介电常数为$8.86fF/mm$，这个参数比较好记，大概量级就是”一毫米十飞法”。</p><p>将Poisson公式写成一维的形式，如下所示，</p><p>$$<br>\frac{d^2V}{dx^2}=-\frac{\rho}{\varepsilon}=\frac{qN_A}{\varepsilon}<br>$$</p><p>这里由于在描述P型半导体（Acceptor）的电荷密度，在P型中的真空电荷区的电荷带负电，因此，抵消了原先的负号。</p><h4 id="导出电场"><a href="#导出电场" class="headerlink" title="导出电场"></a>导出电场</h4><p>对上式积分有，如下表达式，</p><p>$$<br>\frac{dV}{dx}=\frac{qN_A}{\varepsilon}x+C_1<br>$$</p><p>由于电势差增长方向（导数为正方向）与电流方向（正电荷受力移动方向）相反，因此，电场表达如下，</p><p>$$<br>E=-\frac{dV}{dx}=-(\frac{qN_A}{\varepsilon}x+C_1)<br>$$</p><p>使用边界条件$E=0$ @ $x=-W_1$，得到下面的表达式，</p><p>$$<br>E=-\frac{dV}{dx}=-(\frac{qN_A}{\varepsilon}x+\frac{qN_A}{\varepsilon}W_1)<br>$$</p><h4 id="导出电势"><a href="#导出电势" class="headerlink" title="导出电势"></a>导出电势</h4><p>对上式继续做积分，由下面的表达式，</p><p>$$<br>V=\frac{qN_A}{2\varepsilon}x^2+\frac{qN_A}{\varepsilon}W_1x+C_2<br>$$</p><p>假设$V=0$ @ $x=-W_1$的边界条件，那么可以给出下面的表达式，</p><p>$$<br>V=\frac{qN_A}{2\varepsilon}x^2+\frac{qN_A}{\varepsilon}W_1x+\frac{qN_A}{2\varepsilon}W_1^2<br>$$</p><h4 id="计算结的电势差-psi-0-V-R"><a href="#计算结的电势差-psi-0-V-R" class="headerlink" title="计算结的电势差$\psi_0+V_R$"></a>计算结的电势差$\psi_0+V_R$</h4><p>先计算从结的中间$x=0$到P型半导体空间电荷区的边界$x=-W_1$的电势差$V_1$，如下所示，</p><p>$$<br>V(0)-V(-W_1)=V(0)=\frac{qN_A}{2\varepsilon}W_1^2<br>$$</p><p>根据对偶性，我们可以马上写出从N区空间电荷区$x=W_2$到结的中间$x=0$的电势差$V_2$</p><p>$$<br>V_2=\frac{qN_D}{2\varepsilon}W_2^2<br>$$</p><p>马上我们可以写出总的结电压差（内建+外加）的表达式，</p><p>$$<br>\psi_0+V_R=\frac{q}{2\epsilon}(N_AW_1^2+N_DW_2^2)<br>$$</p><p>接下去根据关系：$W_1N_A=W_2N_D$，马上就可以分别给出$W_1$和$W_2$的表达式，如下所示，</p><p>$$<br>W_1=[\frac{2\varepsilon(\psi_0+V_R)}{qN_A(1+\frac{N_A}{N_D})}]^{1/2}<br>$$</p><p>$$<br>W_2=[\frac{2\varepsilon(\psi_0+V_R)}{qN_D(1+\frac{N_D}{N_A})}]^{1/2}<br>$$</p><p>上面两个表达式中，我们可以发现耗尽区宽度与杂质浓度成反比，并且与内建和外加反向电压之和成正比，耗尽区总是在轻掺杂的一侧更宽。</p><h3 id="耗尽区电容"><a href="#耗尽区电容" class="headerlink" title="耗尽区电容"></a>耗尽区电容</h3><p>我们先给出结电容的微分表达式，如下所示，</p><p>$$<br>C_j=\frac{dQ}{dV_R}=\frac{dQ}{dW_1}\frac{dW_1}{dV_R}<br>$$</p><p>空间电荷区的电荷大小与宽度的关系如下所示，</p><p>$$<br>dQ=qN_AAdW_1<br>$$</p><p>其中，$A$代表了横截面积，$AdW_1$直接代表了体积微元。进一步计算得到，结电容的表达式如下所示，</p><p>$$<br>C_j=\frac{C_{j0}}{\sqrt{1-\frac{V_D}{\psi_0}}}<br>$$</p><p>其中，$C_{j0}$表示了当$V_D=0$时的结电容，该曲线对应了下图中的1.21，但是实际上，该表达式在推导时，假设了P和N半导体都是均匀掺杂的，但实际上，掺杂浓度是有一个梯度的，因此，经过计算后，原先分母的平方根(1/2次方)应变为立方根(1/3次方)。并且，这里也假设了当V_D趋近于$\psi_0$时，电容会趋近于无穷大，这也是不合理的，实际的曲线应该为下方的虚线所示。</p><img src="/2023/08/25/paulgray-jing-dian-zhu-zuo-du-shu-bi-ji-di-yi-zhang/662ee5895e6f3ff7b04f72adaedbc0d03ef2b0e0b9064b32e6f5b2a2fc92d573.png" class="" title="picture 1">   <h3 id="结的击穿"><a href="#结的击穿" class="headerlink" title="结的击穿"></a>结的击穿</h3><p>这部分内容感觉用不太到，等用到了之后再读。</p><h2 id="双极性晶体管的大信号行为"><a href="#双极性晶体管的大信号行为" class="headerlink" title="双极性晶体管的大信号行为"></a>双极性晶体管的大信号行为</h2><p>大信号行为包括：</p><ul><li>总电压、总电流大小；</li><li>击穿电压上限；</li><li>二阶效应（电流增益随着集电极电流 &amp; Early电压变化）</li></ul><h3 id="Large-Signal-Models-in-Forward-Active-Region"><a href="#Large-Signal-Models-in-Forward-Active-Region" class="headerlink" title="Large Signal Models in Forward Active Region"></a>Large Signal Models in Forward Active Region</h3><p>典型的三极管的结构如下所示，</p><img src="/2023/08/25/paulgray-jing-dian-zhu-zuo-du-shu-bi-ji-di-yi-zhang/ab14460213dcb72225dc66d53f5403c484608bfcdf43538f3b5c2e4e97b011ed.png" class="" title="picture 3">  <p>要注意到，这种结构的三极管的掺杂浓度往往不是一个常量，而是一个有梯度的量，我们先从均匀掺杂浓度的管子开始分析，而后这里得到的结论有一些也可以在非均匀的管子里面应用。下面的图片就表示了一个均匀掺杂的三极管的示意图。</p><img src="/2023/08/25/paulgray-jing-dian-zhu-zuo-du-shu-bi-ji-di-yi-zhang/c2482f20c48ba9210190b663b18fd8384cbd76842c0f648caec88116360e0265.png" class="" title="picture 4">  <h4 id="基区中的载流子浓度计算"><a href="#基区中的载流子浓度计算" class="headerlink" title="基区中的载流子浓度计算"></a>基区中的载流子浓度计算</h4><p>如上图所示，在AA’的横截面上取出一个掺杂浓度的样本，可以得到如下所示的载流子浓度示意图。</p><img src="/2023/08/25/paulgray-jing-dian-zhu-zuo-du-shu-bi-ji-di-yi-zhang/14971d53a1fc8968338a4d4fcfdbbc7a4055a8ebae22aad540e882bda4aeb488.png" class="" title="picture 5">  <p>空穴浓度用p表示，电子浓度用n表示，其中，下标的n和p表示所处的半导体的类型；E和C的下标分别代表发射极和集电极。上图中表示的载流子浓度是在管子偏置在Forward Active Region中的载流子浓度分布，在这种情况下，Base和Emitter的PN结正向导通，而Base和Collector的PN结是反向偏置的。</p><p>我们先给出由Fermi-Dirac分布函数通过Boltzmann Approximation得到的下面的关于电子浓度分布在$x=0$和$x=W_B$处的表达式，</p><p>$$<br>n_p(0)=n_{po}exp(\frac{V_{BE}}{V_T})<br>$$</p><p>$$<br>n_p(W_B)=n_{po}exp(\frac{V_{BC}}{V_T})\approx0<br>$$</p><p>其中，$n_{po}$表示了在P型半导体中，在无任何电压激励状态下，电子的浓度。可以看到，如果在PN结的P一端施加更高的电压，也就是$V_{BE}$更大，在P型半导体一端的耗尽层边缘的电子浓度会急剧上升，Fermi能级会大大上升，因为Fermi能级指的是电子的50%出现概率的能级点。随着电压上升，电子留在P中的概率大大上升，自然Fermi能级就会上升。</p><p>这里讨论几个我产生的疑问：</p><ol><li><p>为什么这个表达式中会产生指数？</p><p>   因为这里是在说P型半导体中的电子，属于少子浓度，少子浓度一般都是在Fermi-Dirac分布的尾端，而Fermi-Dirac分布的尾端近似指数分布，因此，指数分布就是这么来的。</p></li><li><p>为什么这个表达式中是$V_{BE}/V_T$?</p><p>   首先，我们要弄清楚，上面这个指数表达式是Fermi-Dirac分布的一种近似，其原先的含义是，给出某个粒子的能量，马上可以通过Fermi-Dirac分布给出该能量下，该粒子出现的概率。简单来说，能量越低，找到该粒子的概率越大；能量越高，找到该粒子的概率就越小。这时，怎么判断能量的高低呢？物理学家使用$kT$这一量来衡量能量的大小，这个量的含义是，粒子的热能的数学期望，是一个统计学的量。如果，能量差超过均值很多，那么，找到这个粒子的概率就大大降低；反之，如果能量差小于均值很多，找到这个粒子的概率就大大升高。这个概念直观上来说，可以用一群孩子在书架上拿书的情形来解释，假设这些孩子都是一样高的，但是孩子跳得不一样高，但孩子跳的高度均值为$kT$，那么，书架上的书如果超过$kT$很多，自然被孩子拿去的概率就大大降低，如果小于$kT$很多，被孩子拿去的概率就很大了。这里之所以是$V_{BE}/V_T$而不是$V_{EB}/V_T$的原因在于，衡量的量是P型半导体基极的电子的概率，如果B上施加正向的电压，会使得基区的费米能级上升，自然，n区少数载流子（自由电子）的浓度就上升了。</p></li></ol><p>在上图中，还有一个值得观察的点是，在BE的耗尽区界面和BC的耗尽区界面之间，是线性链接的，这是因为什么呢？这里，作者直接给出了文字的解释：如果在基区的电子和空穴的重新结合的量很小，那么中间的分布就可以看作是线性变化的。这里可以直观地用水来理解，想象一个水渠，有AB两端，水从A端被放入，从B端被放出，水面的高度被认为是载流子的浓度，这里，我们认为是少子电子的浓度，$n_p(x,t)$。如果，输入恒定，且输出恒定，最终水渠内的水的高度会达到稳定，不再跟随时间发生变化，即，</p><p>$$<br>\frac{\partial n_p(x,t)}{\partial t}<br>$$</p><p>少子与多子的重新结合（Recombination），可以被认为是水渠的中间挖了一些小洞，如果小洞流出的水相对于水流量来说很少，那么，可以认为小洞不存在，由于输出端流出水流，所以输出端的水面位置自然会低一些，输入端的睡眠位置自然会高一些，之间自然是线性变化的，也就是下面的表达式，</p><p>$$<br>\frac{\partial^2 n_p(x,t)}{\partial x^2}=0<br>$$</p><p>对于基区来说，耗尽区外的部分仍然为电中性，所以，需要保证多出来的一份自由电子必须要有一份多出来的空穴，本身的自由空穴与一开始的掺杂浓度是一样的，所以要有下面的式子成立，</p><p>$$<br>N_A+n_p(x)=p_p(x)<br>$$</p><p>由于之前假设了基区掺杂浓度处处相等，所以，这边也可以认为基区的空穴浓度$p_p(x)$也是一个在x（位置）上线性的量。</p><h4 id="集电极电流"><a href="#集电极电流" class="headerlink" title="集电极电流"></a>集电极电流</h4><p>接下去来探讨通过扩散作用的电子到了BC的界面上该如何运动的问题，想象下面的一个直观的粒子，在夏日的海滩上，海里有很多人，沙滩的一边代表基极，人源源不断地从沙滩进入到大海，代表着基极的扩散运动，这时，大海里的人少，沙滩上的人多，形成了一个梯度，这时，大海里突然产生了离岸流，将在海里的人拉到了深海里，这就像是基极和集电极之间的电场作用，将人（电子）拉到海洋里（集电极），形成了电流。作者使用了扫进集电极的术语，说明了人（电子）在对抗离岸流（电场）时，力量很小，只要被卷入了海洋（集电极），就很难再回来了。</p><p>同样地，在晶体管里面，也是一样的概念，电子由于基极的浓度差，形成了一个梯度，导致电子往低浓度的方向扩散，当电子移动到BC的界面的时候，电场非常强，一下子把扩散到这个地方的电子吸入了集电极，产生了很强的电流。</p><p>我们接下去用数学的方式来描述一下这个过程，如下所示，</p><p>$$<br>J_n=qD_n\frac{dn_p(x)}{dx}<br>$$</p><p>上式描述了扩散电流密度，其中，$D_n$表示了电子的扩散常数，由于电子的浓度在距离上的斜率固定，所以可以用下式表达，</p><p>$$<br>J_n=qD_n\frac{n_p(0)-n_p(W_B)}{0-W_B}=-qD_n\frac{n_p(0)}{W_B}<br>$$</p><p>上式乘以面积就是集电极电流了，如下所示，</p><p>$$<br>I_C=qAD_n\frac{n_p(0)}{W_B}<br>$$</p><p>将BE界面的少子浓度$n_p(0)$代入到上面的表达式后，得到如下的表达式，</p><p>$$<br>I_C=\frac{qAD_nn_{po}}{W_B}exp\frac{V_{BE}}{V_T}=I_Sexp\frac{V_{BE}}{V_T}<br>$$</p><p>其中，$I_S=\frac{qAD_nn_{po}}{W_B}$，一般这个数值的量级为$10^{-14}$ ~ $10^{-16}A$之间，属于$fA$量级，相当小。</p><h4 id="基极电流"><a href="#基极电流" class="headerlink" title="基极电流"></a>基极电流</h4><p>基极电流也是一个非常重要的量，作者给出了基极电流的两个分量，一个是空穴和电子的重新结合（Recombination），和我们前文说的水渠的案例可以结合起来看，这个水渠中的流水代表了电子的流动，水渠中间挖去一些洞，水流会流走一些，就代表了空穴和电子的重新结合（Recombination），可以由此来直观地理解这个机制。</p><p>下面使用数学来描述这个过程，定义$I_{B1}$为重新结合的电子和空穴形成的电流，该电流与基区的少子电子$Q_e$成正比，该量表示如下，</p><p>$$<br>Q_e=q\int_{0}^{W_B}n_p(x)Adx=\frac{1}{2}qAW_Bn_p(0)<br>$$</p><p>定义$\tau_b$为基区少子的平均生存时间，那么，该时间内，基区所有少子都会被重新结合，所以，该电流表示如下，</p><p>$$<br>I_{B1}=\frac{Q_e}{\tau_b}=\frac{1}{2}\frac{qAW_Bn_p(0)}{\tau_b}<br>$$</p><p>另一个主要部分的电流主要来自于空穴的扩散，造成了空穴从基极注入到了发射极，如下所示，注意，这一部分电流主导了基区电流，后面的集电极-基极电流的一章说了，这一部分电流占据了90%，而前面一部分由于基极电子与空穴的重结合造成的电流只占据了10%。</p><p>$$<br>I_{B2}=\frac{qAD_p}{L_p}p_{nE}(0)<br>$$</p><p>注意，该扩散运动的电子运动速率与单位长度上的浓度差$p_{nE}(0)/L_p$成正比。一般管子不希望有这一部分电流，因为这一部分电流过大会影响管子的性能和效率，管子一般不希望基极电流过大，这样，其电流放大倍数可以很大；另一方面，由于发射极重掺杂，所以，发射极一般是一个好的电子的发射端，而不是空穴的接收端。因此，从两个层面讲，该电流都不会太大。</p><h4 id="beta-的定义"><a href="#beta-的定义" class="headerlink" title="$\beta$的定义"></a>$\beta$的定义</h4><p>将上面表达的两个电流组合起来，得到了总的晶体管的电流如下所示，</p><p>$$<br>I_B=(\frac{1}{2}\frac{qAW_Bn_{po}}{\tau_b}+\frac{qAD_pp_{nEo}}{L_p})exp\frac{V_{BE}}{V_T}<br>$$</p><p>上述表达式对于不均匀基区掺杂的器件仍然适用，但基区电流存在二阶项，这对于低电流应用来说非常重要，将会在之后进行考虑。</p><p>利用集电极电流和基极电流的比例我们就可以得到电流系数$\beta$了，如下所示，</p><p>$$<br>\frac{I_C}{I_B}=\beta<br>$$</p><p>$\beta$被称作Forward Current Gain，前向电流增益，一般这个值在集成电路中NPN管大概在50-500之间，而PNP管略低，大概在10-100之间。</p><h4 id="发射极电流-amp-alpha-的定义"><a href="#发射极电流-amp-alpha-的定义" class="headerlink" title="发射极电流 &amp; $\alpha$的定义"></a>发射极电流 &amp; $\alpha$的定义</h4><p>由于基极电流和集电极电流都是流向基极的，所以，发射极电流为基极电流和集电极电流之和，如下所示，</p><p>$$<br>I_E=I_C+I_B=\frac{I_C}{\alpha}<br>$$</p><p>其中，</p><p>$$<br>\alpha=\frac{\beta}{1+\beta}<br>$$</p><p>$\alpha$的表达式也可以用下面的式子进行表达，</p><p>$$<br>\alpha=\alpha_T\gamma<br>$$</p><p>$$<br>\alpha_T=\frac{1}{1+\frac{W_B^2}{2\tau_bD_n}}<br>$$</p><p>$$<br>\gamma=\frac{1}{1+\frac{D_p}{D_n}\frac{W_B}{L_p}\frac{N_A}{N_D}}<br>$$</p><p>其中，$\gamma$称为发射极注入效率，该量为由发射极注入基极的电子电流与穿过BE界面的电子电流和空穴电流的总和，理想状况下，$\gamma=1$，通过使得发射极的掺杂浓度（$N_D$）远远大于基极的掺杂浓度（$N_A$），并且基极的宽度（$W_B$）非常小，在这样两个条件下，电流几乎都是正向从发射极注入到基极的电子电流，而反向的空穴电流非常小。</p><p>还有一个参数$\alpha_T$称为基极传输因数，主要描述的是基极到集电极载流子到达的比例，也就是衡量了有多少载流子从基极被注入到集电极。如果把$W_B$设计得足够小，那么我们就可以获得一个接近1的$\alpha_T$。</p><p>很显然，如果将基极做得足够薄，也就是说$W_B$足够小，再将发射极掺杂浓度做得足够高，以至于发射极和基极得掺杂比例足够大，那么，我们就可以设计出一个$\beta$很大的管子。以前初次上模电课时，老师曾经说过，基极非常薄，发射极重掺杂，这些概念当时也只是听听就过了，现在，终于明白这些改进是为了提高$\beta$的大小。</p><p>下面给出了NPN三极管的大信号模型</p><img src="/2023/08/25/paulgray-jing-dian-zhu-zuo-du-shu-bi-ji-di-yi-zhang/deae1ad0bc31a22d5ff8061fbba07d00ef919dd83c4741cfa4abae5dd36062b0.png" class="" title="picture 6"> <p>注意到左图中的电路很好解释，但是右图中，产生了一个新的变量$V_{BEon}$，这个变量的大小常在0.6-0.7V之间，这和我们的三极管的指数特性是对应上的，即电压的微小变化就会造成巨大的电流变化，所以这里电压基本不怎么变化。值得注意的是，这个量是一个与温度有关的量，与温度成反比，大概的变化为$-2mV/K$。</p><h4 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h4><p>我认为Forward Active Region下的大信号行为可以用海滩上的人来进行直观地说明。海滩上的人相当于基区中的少数载流子，在海岸上的人永远是最多的，这对应了BE界面上的少数载流子浓度是最大的，在BC界面上，由于集电极和基极电压反偏，造成了浓度为零。这两个界面之间的浓度分布是关于位置线性变小的，由于扩散运动，少子在高浓度区域BE界面上，要往低浓度区域BC界面扩散，如果这个过程中的电子空穴结合可以忽略，那么，电流就仅仅会因为扩散运动而产生，这个电流的大小取决于BE界面到BC界面的浓度变化速率，也就是单位长度上的浓度差值，由于BC界面上的浓度值近似为零，所以仅仅由BE界面上的浓度决定，这个浓度与VBE正偏电压成指数关系，这也就是指数关系的由来。到了BC界面上的少子在强电场的作用下（用人被离岸流卷走来理解），穿过BC界面到达了集电极，形成了集电极电流。沙滩上的人肯定都是从沙滩外的马路来的，如果沙滩外马路上的人足够多（发射极重掺杂），那么进入沙滩的人的数量也会足够多，从沙滩返回公路的人就会非常少。如果沙滩的宽度足够窄（基区宽度小，薄基区），那么由于沙滩上容纳的人数有限（没有空穴与电子的结合），在浓度差的作用下，全部都更快地进入了大海（更大的电流），被离岸流吸走，最终进入海洋。</p><p>因此，可以看到，指数特性的来源在于BE界面上的正偏电压造成了少数载流子的数量上升剧烈，从而通过扩散运动形成与浓度相关的电流。读大学第一次学模拟课程是在大二，到现在研三了，才弄懂三极管指数特性的来源，真是惭愧。</p><h3 id="集电极电压对Forward-Active-Region中的大信号模型产生的影响"><a href="#集电极电压对Forward-Active-Region中的大信号模型产生的影响" class="headerlink" title="集电极电压对Forward Active Region中的大信号模型产生的影响"></a>集电极电压对Forward Active Region中的大信号模型产生的影响</h3><p>我们一只认为集电极电压并不会对集电极电流大小，因为根据我们之前推导的过程，集电极电流相当于在海里被离岸流带走的人，其量只取决于从沙滩到海的人的梯度，即从BE界面到BC界面的少数载流子的浓度变化率，即单位长度上的浓度差，因此，基区做得越薄，其产生的集电极电流就越大。下面来讨论集电极电压对集电极电流产生影响的一些情形。</p><p>除了Forward Active Region之外，还有Saturation Region（$V_{CE}$接近0）和Breakdown Region（$V_{CE}$很大）这两个区域，如果三极管工作在这两个区域，那么，集电极电压对集电极电流有非常大的影响；如果在这两个区域中间，集电极电流会随着$V_{CE}$的上升而缓慢上升。</p><p>看一下下面的图马上读者就可以定性地直观地理解了，$V_{CE}$变大，那么，$V_{BC}$反偏电压就会反偏得更多，BC界面上的耗尽区就会因为反偏电压增大而增大，挤压了基区的空间，造成了基区宽度较小，根据我们先前的分析，基区宽度变小，直接导致基区的浓度场的梯度变大，直接导致集电极电流增大。</p><img src="/2023/08/25/paulgray-jing-dian-zhu-zuo-du-shu-bi-ji-di-yi-zhang/e6f819c37a75435fa68742190d6e16c20be88496b703c4b1e6e530f3aa9b8a51.png" class="" title="picture 9">  <p>接下来需要定量分析一下，根据先前的集电极电流表达式，如下，</p><p>$$<br>I_C=\frac{qAD_nn_{po}}{W_B}exp\frac{V_{BE}}{V_T}<br>$$</p><p>对宽度$W_B$求导有如下表达式，</p><p>$$<br>\frac{\partial I_C}{\partial V_{CE}}=-\frac{qAD_nn_{po}}{W_B^2}exp\frac{V_{BE}}{V_T}\frac{\partial W_B}{\partial V_{CE}}=-\frac{I_C}{W_B}\frac{\partial W_B}{\partial V_{CE}}<br>$$</p><p>因为基区宽度随着$V_{CE}$的增大而减小，所以，上式的偏导为正，即，集电极电压增大，集电极电流也增大，与我们定性的分析一样。通过先前的耗尽区宽度与反偏电压关系的一节中的式子，可以进一步计算其斜率，其斜率是$V_{CE}$的函数，意味着他们之间存在一定的非线性，但这种非线性很弱，一般视作是一个恒定斜率的线性关系。</p><p>再来看上面表达式中的系数项，这一系数表明，$I_C$越大，$I_C$关于$V_{CE}$曲线的斜率越大，同时，由于IC中，基区的宽度都很薄，所以造成了$I_C$的作用被放大了。因此，可以得到如下的$V_{CE}-I_C$特性曲线，可以看到，相同$V_{CE}$的条件下，$I_C$越大，曲线的斜率越大。</p><img src="/2023/08/25/paulgray-jing-dian-zhu-zuo-du-shu-bi-ji-di-yi-zhang/8e1120adf836d04343cfb65b42e892436cf4c2e25475cad4c64f8271a6262742.png" class="" title="picture 10">  <p>注意到，将曲线反向延长到横轴，会产生一个交点$V_A$，$V_A$的大小根据截距的定义，由下式表达，</p><p>$$<br>V_A=\frac{Y}{k}=\frac{I_C}{\frac{\partial I_C}{\partial V_{CE}}}=-W_B\frac{dV_{CE}}{dW_B}<br>$$</p><p>上述集电极电流跟随集电极电压发生变化的现象叫做Early Effect，$V_A$的典型值在15-100V之间。</p><p>在计算的时候，手算DC工作点的时候，一般不考虑Early效应，但是在小信号模型中，一般是考虑的。</p><h3 id="Saturation-and-Inverse-Active-Regions"><a href="#Saturation-and-Inverse-Active-Regions" class="headerlink" title="Saturation and Inverse-Active Regions"></a>Saturation and Inverse-Active Regions</h3><p>通常在模拟电路中，器件一般不希望工作在Saturation Region，因为在这个区域里，管子的增益非常差，一般只会在数字中使用。</p><p>在Saturation的状态下，BE和BC的结都是正向导通的，在这种情形下，$V_{CE}$大概在0.05-0.3V之间，在$W_B$位置上的少子浓度如下所示，</p><p>$$<br>n_p(W_B)=n_{po}exp\frac{V_{BC}}{V_T}<br>$$</p><p>由于$V_{BC}$的值远大于零，这时，$n_p(W_B)$的值（$W_B$处的少子浓度）就不可以被忽略了。根据先前的分析，集电极电流与基极的少子浓度斜率有关，自然与$[n_p(0)-n_p(W_B)]$成正比，换句话说，$n_p(W_B)$这一量直接影响到了集电极电流的大小，由于$V_C$电压直接影响到了$n_p(W_B)$的大小，因此，集电极节点呈现为一个低阻抗节点，即，微小的电压变化会产生巨大的电流变化。假设$V_{BE}$恒定不变，随着$V_{CE}$的减小，BC结界面上的结越来越正偏，$W_B$处的少子浓度越来越高，于是，产生了如下的器件特性，</p><img src="/2023/08/25/paulgray-jing-dian-zhu-zuo-du-shu-bi-ji-di-yi-zhang/bb60fc027282e56c01c27a231345291eaf2245337cca4648f4a6093b13e32d1b.png" class="" title="picture 11"><p>这时的电阻主要取决于集电极上的寄生电阻，通常在$20-500\Omega$之间。这时，处于饱和区三极管的器件模型由下面的模型描述，</p><img src="/2023/08/25/paulgray-jing-dian-zhu-zuo-du-shu-bi-ji-di-yi-zhang/4fe1932d3d8986c2c809374546b9b80c6cf3a903f15d02f61a7676581e9bfe55.png" class="" title="picture 14">  <p>当双极型晶体管处于饱和区的时候，基区的电荷浓度显著高于Forward-Active Region，这时，由于电子空穴重新结合而产生的基极电流$I_B$会更大；另一方面，基极产生了新的电流分量，因为BC结的正向导通，$I_B$产生了BC结正向导通的电流的分量。这两个因素导致了双极型晶体管在同一集电极电流$I_C$的条件下，在Saturation Region状态下的基极电流会显著大于在Forward-Active Region状态下的基极电流。根据定义，对应的电流系数$\beta$也会显著低于处于Forward-Active Region状态下的晶体管。</p><img src="/2023/08/25/paulgray-jing-dian-zhu-zuo-du-shu-bi-ji-di-yi-zhang/de23fba6c250aa9b0d8d26fa8a486c48229b4f3d6f0b623285a1d4c30b52d307.png" class="" title="picture 15">  <p>如上图所示，少子浓度可以看作是两条虚线浓度的叠加产生的，这样看待这个问题的条件是，基区电子和空穴的重结合（Recombination）非常小，这个条件前文我们说过如何直观地看待它。那么，由于$n_{p1}(x)$导致的发射极电流由下式表达，</p><p>$$<br>I_{EF}=-I_{ES}(exp(\frac{V_{BE}}{V_T})-1)<br>$$</p><p>$n_{p2}(x)$导致的集电极电流使用如下表达式进行表达，</p><p>$$<br>I_{CR}=-I_{CS}(exp\frac{V_{BC}}{V_T}-1)<br>$$</p><p>注意，根据之前的分析，只有一部分的发射极电流最终到达了集电极，比例为$\alpha_F$。因此，集电极电流由下面的式子表达，</p><p>$$<br>I_C=\alpha_FI_{EF}+I_{CR}<br>$$</p><p>通常来说，$\alpha_F$非常趋近于1，发射极电流由下式表达，</p><p>$$<br>I_E=-I_{EF}-\alpha_RI_{CR}<br>$$</p><p>通常来说，$\alpha_R$的值的大致范围为$[0.5, 0.8]$，这个值为管子反过来接时工作的发射极到集电极电流比例。我们可以写出这个时候的电流放大倍数$\beta_R$，如下所示，</p><p>$$<br>\beta_R=\frac{\alpha_R}{1-\alpha_R}<br>$$</p><p>这个值通常在1-5之间，可以看到相比之前的100的电流放大系数，把管子反过用，即原先的E当作C，原先的C当作E，会造成双极型晶体管的电流增益大大降低，其原因在于，双极型晶体管在设计的时候，EC就是不对称的，其目的是为了增大电流放大系数$\beta_F$。把管子反过来接，这个状态被称为Inverse Active Region。</p><p>这两个表达式被称为Ebers-Moll等式，之前我就在论文上看到过这个表达式，当时，对这个表达式完全不懂，现在终于明白了其中的来龙去脉。这个表达式可以描述在三个区域中的双极型晶体管的工作情况：</p><ul><li>Saturation Region</li><li>Forward-Active Region</li><li>Inverse-Active Region</li></ul><p>$$<br>I_C=\alpha_FI_{EF}+I_{CR}<br>$$</p><p>$$<br>I_E=-I_{EF}-\alpha_RI_{CR}<br>$$</p><p>使用下面的表达式，</p><p>$$<br>\alpha_FI_{ES}=\alpha_RI_{CS}=I_S<br>$$</p><p>可以得到一个Ebers-Moll等式的通式，如下所示，</p><p>$$<br>I_C=I_S(exp\frac{V_{BE}}{V_T}-1)-\frac{I_S}{\alpha_R}(exp\frac{V_{BC}}{V_T}-1)<br>$$</p><p>$$<br>I_E=-\frac{I_S}{\alpha_F}(exp\frac{V_{BE}}{V_T}-1)-I_S(exp\frac{V_{BC}}{V_T}-1)<br>$$</p><p>上面这个表达式通常用于计算机计算管子的大信号行为中。</p><h4 id="I-CO-集电极-基极漏电流"><a href="#I-CO-集电极-基极漏电流" class="headerlink" title="$I_{CO}$集电极-基极漏电流"></a>$I_{CO}$集电极-基极漏电流</h4><p>集电极基极漏电流由下式表达，</p><p>$$<br>I_{CO}=I_{CS}(1-\alpha_R\alpha_F)<br>$$</p><p>其定义为，当发射极开路时，从集电极漏到基极的电流，通常来说，当BC结处于反偏状态时，这个漏电流的典型值为，25C下，$1pA-100pA$，这个漏电流的大小会随着温度上升而增大，趋势大约为每上升8C，电流增大一倍。所以，这个电流在高温情况下，可能会相当大，大到不可以被忽视的程度。</p><p>基极电流表示成集电极电流和集电极漏电流的形式的表达式如下所示，</p><p>$$<br>I_B=\frac{I_C}{\beta_F}-\frac{I_{CO}}{\alpha_F}<br>$$</p><p>注意到两者是反号的，所以温度上升，集电极漏电流增大，会直接导致基极电流变小。</p><h3 id="晶体管击穿电压"><a href="#晶体管击穿电压" class="headerlink" title="晶体管击穿电压"></a>晶体管击穿电压</h3><p>这部分内容目前应该没有需求，以后再看。</p><h3 id="晶体管电流增益-beta-F-随工作区域的变化情况"><a href="#晶体管电流增益-beta-F-随工作区域的变化情况" class="headerlink" title="晶体管电流增益$\beta_F$随工作区域的变化情况"></a>晶体管电流增益$\beta_F$随工作区域的变化情况</h3><p>大多数一阶分析都做了$\beta_F$是一个常量的假设，但实际上，$\beta_F$是温度和工作区域的函数，如下给出了$\beta_F$的曲线。</p><img src="/2023/08/25/paulgray-jing-dian-zhu-zuo-du-shu-bi-ji-di-yi-zhang/0f9d80f99d7be456893760514f774be08c75095da5e54d5564649663101f649e.png" class="" title="picture 16">  <p>很显然，随着温度的上升，电流增益$\beta_F$逐渐增大，典型的$\beta_F$的温度系数为7000ppm/C。基本原理是，随着温度上升，相同掺杂浓度的射极的电子和空穴发生重新结合的概率更低，增强了发射极电子到达基极的概率，即，提高了发射极注入效率$\gamma$，更多的电流从发射极到达了基极，最终提升了$\beta_F$。</p><p>上图还给出了$\beta_F$与集电极电流$I_C$之间的关系，在I区域中，电流很小，$\beta_F$与电流成正比；在II区域中，电流中等，在这个区域中，$\beta$基本保持恒定；在III区域中，电流很大，在这个区域中，电流增大，电流增益$\beta_F$降低。</p><p>接下去是一个很有意思的图标，作者通过电流的对数图，说明了$\beta_F$与集电极电流的关系的原因，如下图所示，因为我们感兴趣的量是两个变量的比值，所以通过对数图，可以直接在图上看到比值的变化情况，就是两个曲线之间的距离，这是今后在分析电路图表的时候可以使用的一个方法。</p><img src="/2023/08/25/paulgray-jing-dian-zhu-zuo-du-shu-bi-ji-di-yi-zhang/012b2839272dcefe554a69411cc6cbd8895e2865d5743b455dfaa2b9d8eaf67a.png" class="" title="picture 17">  <p>对于基极电流来说，有两个部分，一个是由于BE结上的浓度差导致的空穴移动造成的电流，还有一部分是由于基极在向集电极运输载流子的过程中，空穴和电子发生重新结合造成的电流分量。第一部分的电流由下式表达，</p><p>$$<br>I_B=\frac{I_S}{\beta_{FM}}exp\frac{V_{BE}}{V_T}<br>$$</p><p>第二部分的电流由下面的式子表达，</p><p>$$<br>I_{BX}=I_{SX}exp\frac{V_{BE}}{2V_T}<br>$$</p><p>当集电极电流比较低时，基极电流主要由第二部分主导；当集电极电流比较高时，基极电流主要由第一部分主导。</p><p>另一方面，当电流比较大的时候，集电极电流在集电极产生拥塞现象，由于high-level injection以及kirk effect造成集电极电流下降的现象。</p><h4 id="总结一下-1"><a href="#总结一下-1" class="headerlink" title="总结一下"></a>总结一下</h4><ul><li>晶体管的电流放大倍数$\beta_F$在管子Forward Active状态下是最大的，在管子Inverse Active状态下会大幅下降</li><li>晶体管的电流放大倍数$\beta_F$与温度成正比，温度系数大约为7000ppm/C</li><li>晶体管的电流放大倍数$\beta_F$在中等电流时最大，当电流很小或者是电流很大时，都会下降，因此，要控制好三极管的电流大小，保证足够的电流放大倍数。</li></ul><h2 id="双极型晶体管的小信号模型"><a href="#双极型晶体管的小信号模型" class="headerlink" title="双极型晶体管的小信号模型"></a>双极型晶体管的小信号模型</h2><p>模拟电路设计中，信号的量通常与偏置相比非常小，比如反馈电路，在这种电路中，可以采用小信号模型来更加方便地对电路进行手算，当然有更加复杂的模型可以用于计算电路，但是作为模拟设计来说，一个重要的技能就是知道在特定的电路中，模型当中的哪些东西可以在手算过程中予以忽略。</p><p>考虑下图中的电路，</p><img src="/2023/08/25/paulgray-jing-dian-zhu-zuo-du-shu-bi-ji-di-yi-zhang/030224d3e17e8fa72ebad40677e494be7c90a1496d0d8b71eed9da880853512d.png" class="" title="picture 18">  <p>图中，管子处于Forward Active Region，并且将输入施加在基极上，产生了对应的基极电流$I_b=I_B+i_b$，以及对应的集电极电流$I_c=I_C+i_c$，其对应的载流子浓度分布如下图所示，</p><img src="/2023/08/25/paulgray-jing-dian-zhu-zuo-du-shu-bi-ji-di-yi-zhang/e2a74615c41cb1f53b2fd647c113b26598110f92640399468c7eede7a8e688b3.png" class="" title="picture 19">  <p>当只有偏置DC电压的时候，载流子浓度的分布如图中实线所示，当基极电压发生小信号波动时，其BE界面上的少子浓度发生变化，导致集电极电流发生变化，接下去推导小信号模型中的参数。</p><h3 id="跨导"><a href="#跨导" class="headerlink" title="跨导"></a>跨导</h3><p>跨导可以由下面的表达式进行推导，</p><p>$$<br>g_m=\frac{d}{dV_{BE}}I_Sexp\frac{V_{BE}}{V_T}=\frac{I_S}{V_T}exp\frac{V_{BE}}{V_T}=\frac{I_C}{V_T}<br>$$</p><p>可以看到，跨导只与偏置集电极电流有关，并且在25C下，$1mA$的集电极电流条件下，为$38mS$，对应的阻抗为$26\Omega$。有意思的是，这个值对于任意管子，不论是NPN管还是PNP管，不论是什么尺寸，还是什么材料的管子（Si, Ge, GaAs），其跨导都为$38mS/1mA@25C$。</p><h4 id="小信号模型的局限性"><a href="#小信号模型的局限性" class="headerlink" title="小信号模型的局限性"></a>小信号模型的局限性</h4><p>将大信号模型的表达式如下所示，</p><p>$$<br>I_c=I_Cexp\frac{v_i}{V_T}<br>$$</p><p>进行泰勒展开后有，</p><p>$$<br>I_c=I_C[1+\frac{v_i}{V_T}+\frac{1}{2}(\frac{v_i}{V_T})^2+\frac{1}{6}(\frac{v_i}{V_T})^3+\cdots]<br>$$</p><p>如果输入信号远小于阈值电压，即，$v_i&lt;&lt;V_T$，那么，小信号模型就可以直接使用。总结一下就是，当$v_i=\Delta V_{BE}&lt;&lt;26mV@25C$时，小信号就可以用了。从数量上来看，如果$v_i&lt;10mV$，那么对应的小信号分析的误差就可以控制在10%以内，这是一个比较直观的认知。</p><h3 id="基区充电电容"><a href="#基区充电电容" class="headerlink" title="基区充电电容"></a>基区充电电容</h3><p>之前的$V_{BE}$变化的MOS管的少子浓度分布图表明，输入信号，也就是$V_{BE}$的变化会导致基区的少子电荷量的变化，$\Delta Q=q_e$。根据电荷守恒原理，基区的多子的数量也会同样增加或减少这么多$\Delta Q_h=q_h$。又因为多子是由基区的信号源提供的，施加$v_i$的信号在基区上就需要提供对应的$q_h$的电荷，这属于电容的特性，因此，基区呈现出如下的电容，</p><p>$$<br>C_b=\frac{q_h}{v_i}<br>$$</p><p>经过一系列推导之后（这一部分推导感觉没有太多学习的意义，因此，不在这里说了），得到了如下的电容值，</p><p>$$<br>C_b=\tau_F\frac{qI_C}{kT}<br>$$</p><p>这里可以得到结论，小信号电容与双极型晶体管的DC集电极电流$I_C$成正比。式子中的$\tau_F$的意义是载流子穿过基极的平均时间，在集成电路中通常是$10ps-500ps$。如果你把管子反过来用，也就是把原先的发射极当作集电极，那么，对应的$\tau_R$会显著变大，对应的基极电容也就变大了，管子就变慢了，这是由于管子两侧掺杂是不对称导致的。处于饱和区的管子的基极电容可以通过$Ebers-Moll$模型来预测，即，将Forward-Active和Inverse-Active的情形做叠加。所以在$SPICE$之类的软件中，常常会有$\tau_R$的参数出现。</p><h3 id="输入电阻"><a href="#输入电阻" class="headerlink" title="输入电阻"></a>输入电阻</h3><p>双极型晶体管的输入在基极上时，由于基极会有电流流入，所以，会存在一个小信号电阻$r_\pi$，其值由下式给定，</p><p>$$<br>r_\pi=\frac{v_i}{i_b}<br>$$</p><p>又因为$i_c=\beta i_b$，所以得到下面的表达式，</p><p>$$<br>r_\pi=\frac{v_i}{i_c}\beta<br>$$</p><p>接着，又因为$v_ig_m=i_c$，所以有下面的式子成立，</p><p>$$<br>r_\pi=\frac{\beta}{g_m}<br>$$</p><p>这里给出结论，双极型晶体管的小信号输入Shunt Resistance的大小与电流增益成正比，与集电极电流成反比。这里之所以说是Shunt，是因为Shunt在英文中代表了一种低阻支路的含义，这里的双极型晶体管的输入电阻给信号另一条低阻支路，使得管子被Bypass了。</p><h3 id="输出电阻"><a href="#输出电阻" class="headerlink" title="输出电阻"></a>输出电阻</h3><p>在先前的内容中，描述了在大信号中，$V_{CE}$的变化是如何影响双极型晶体管的大信号特性的，之前说过，当$V_{CE}$产生变化时，会对管子的集电极电流产生影响，由下式表达，</p><p>$$<br>\Delta I_C=\frac{\partial I_C}{\partial V_{CE}}\Delta V_{CE}<br>$$</p><p>根据之前的Early电压的内容，可以知道下面的表达式，</p><p>$$<br>\frac{\Delta V_{CE}}{\Delta I_C}=\frac{V_A}{I_C}=r_o<br>$$</p><p>在这个式子中，$V_A$是Early电压，通常来说这个值在$50V-100V$之间，假设管子的集电极电流为$1mA$，那么对应的输出电阻就在$50k\Omega-100k\Omega$之间。注意到管子的小信号输出阻抗是和集电极电流成反比的，$g_m$是和集电极电流成正比的，因此，$r_o$和$g_m$之间可以互相转换，存在一定的关系，这个关系读者稍微推导一下就可以得到，如下，</p><p>$$<br>r_o=\frac{1}{\eta g_m}<br>$$</p><p>其中，$\eta$的值如下，</p><p>$$<br>\eta=\frac{V_T}{V_A}<br>$$</p><p>如果我们的$V_A=100V$，那么对应的$\eta=2.6\times 10^{-4}$，其实$1/\eta$就是我们的双极型晶体管的本征增益，大概对应了70dB左右，这里可以看到这个增益只与$V_A$有关，因为$V_T$提供了大约$30dB$的增益，这一部分是固定的，剩下的$40dB$全部由$V_A$提供。</p><h3 id="集电极-基极电阻"><a href="#集电极-基极电阻" class="headerlink" title="集电极-基极电阻"></a>集电极-基极电阻</h3><p>考虑到之前描述的集电极电压调制基区宽度的情形，当集电极电压上升时，BC结的耗尽区宽度变大，造成基区宽度被压缩，如下图所示。</p><p>这时，由于基区电子与空穴重结合效应而产生的基极电流$I_{B1}$由于基区宽度变小而变小，作者说这一部分由于$\Delta V_{CE}$变化造成的$I_B$电流变化的效应，由集电极到基极的电阻来进行建模。这里的合理性我还不是特别清楚。下面给出具体的数学表达，</p><p>$$<br>r_\mu =\frac{\Delta V_{CE}}{\Delta I_{B1}}=\frac{\Delta V_{CE}}{\Delta I_C}\frac{\Delta I_C}{\Delta I_{B1}}=r_o\beta_0<br>$$</p><p>作者这里给出了由于重结合造成的基极电流和因为多子扩散到发射极形成的基极电流的比例，后者占据了主导，前者在总基极电流中的比例小于10%。因此，$\beta_0$的典型值约为$\beta/10$。对于平面型的管子来说，其基区的重结合效应更加显著，这里其本质上就是平面型管子的基区宽度更宽，造成了重结合效应更显著了，更多从基极输入管子的基区多子与从发射极发射入基区的基区少子发生了结合，造成了基区电流的上升与到达集电极的基区少子载流子的降低，降低了管子的电流放大倍数。这里作者给出了具体的倍数关系，在平面结构中，由于基区宽度变宽造成的基区电流的增大，从而导致由于重结合效应产生的基区电流上升而造成的此部分电流占比上升，其倍数大约为$\beta_0=<br>\beta/5-\beta/2$。</p><h3 id="小信号模型中的寄生"><a href="#小信号模型中的寄生" class="headerlink" title="小信号模型中的寄生"></a>小信号模型中的寄生</h3><p>目前仅仅是考虑到了一些直接可以看出来的管子的寄生，但是对于集成晶体管来说，还有很多寄生需要考虑，需要根据下面的集成晶体管剖面图来进行分析。</p><img src="/2023/08/25/paulgray-jing-dian-zhu-zuo-du-shu-bi-ji-di-yi-zhang/c23047cd033097a3c5813604411a3943e3f1cd1605082c7dae1eb856c2f538a1.png" class="" title="picture 20">  <h4 id="容性寄生"><a href="#容性寄生" class="headerlink" title="容性寄生"></a>容性寄生</h4><p>在前面的章节里说过，在晶体管的所有PN结的界面上都存在一个与电压相关的电容，这个电容的成因是耗尽区的存在。在上图中，三个电容是耗尽层电容，分别是：</p><ul><li>BE界面上的耗尽层电容$C_{je}$；</li><li>BC界面上的耗尽层电容$C_\mu$；</li><li>集电极与衬底的耗尽层电容$C_{cs}$</li></ul><p>BE界面上的耗尽层电容由于发射极的重掺杂，BE结是一个突变结(abrupt junction)，其电容可以由下面的表达式很好地进行数学上地表达，</p><p>$C_{\mu}=\frac{C_{j0}}{\sqrt{1-\frac{V_D}{\psi_0}}}$</p><p>其中，$C_{j0}$是在结的偏置电压$V_D=0$时的结电容大小，$\psi_0$为内建电势，大约为$0.7mV$左右。</p><p>BC界面上的耗尽层电容由于掺杂浓度不高，所以是个缓变结（graded junction），当偏置电压很小时，耗尽层的边缘在结面的附近，在这个区域内，掺杂浓度是耗尽层位置的函数，其结特性显示为一个缓变结，因此，其电容跟随位置的变化</p><p>$C_{\mu}=\frac{C_{j0}}{^3\sqrt{1-\frac{V_D}{\psi_0}}}$</p><p>当偏置电压很大时，集电极的耗尽区一路延伸到集电极的内部，其掺杂浓度是均匀的，这时，分母的根号为平方根。实际应用中，这个电容的根号取值为平方根到5次方根之间，如下所示，</p><p>$$<br>C_\mu=\frac{C_{\mu 0}}{(1-\frac{V}{\psi_0})^n},n\in[0.2,0.5]<br>$$</p><p>第三个寄生电容是集电极到衬底的结电容，这个等到以后需要的时候再重新阅读考虑。</p><p>这里作者给出了这三个电容的典型值，$C_{je0}\approx10fF$，$C_{\mu 0}\approx10fF$，$C_{cs0}\approx20fF$，从中可以看出，集电极到衬底的电容要显著得更大。</p><h4 id="阻性寄生"><a href="#阻性寄生" class="headerlink" title="阻性寄生"></a>阻性寄生</h4><p>这一部分里面最重要的就是基区电阻$r_b$，当集电极电流显著增大时，这个电阻会显著降低，恶化管子的性能。这个现象作者给出了解释，但是我没有看懂，等到以后有机会了再进行深入研究。</p><h4 id="完整的双极型晶体管的小信号模型"><a href="#完整的双极型晶体管的小信号模型" class="headerlink" title="完整的双极型晶体管的小信号模型"></a>完整的双极型晶体管的小信号模型</h4><p>有了上面的分析，我们可以给出如下的完整的双极型晶体管的小信号模型，</p><img src="/2023/08/25/paulgray-jing-dian-zhu-zuo-du-shu-bi-ji-di-yi-zhang/f2a2b5b95ba1db40e35ebc510f9834c5733b53da926b7cdd4bb5879d74e1b2c1.png" class="" title="picture 21">  <p>图中的$C_\pi=C_b+C_{je}$，由基区充电电容（基区少子的存在对应存储的多子空穴）以及耗尽层结电容组成。</p><h3 id="晶体管频率响应的一些指标"><a href="#晶体管频率响应的一些指标" class="headerlink" title="晶体管频率响应的一些指标"></a>晶体管频率响应的一些指标</h3><p>双极型晶体管的高频增益受到小信号模型中的容性器件的大小控制；双极型晶体管的频率能力主要靠衡量管子的短路集电极电流增益掉到1的频率。这个频率称为截止频率（Transition Frequency），这个频率的本质是管子可以被用作放大器的最大的频率。</p><p>这个频率可以通过手算来进行分析，使用如下的电路模型，</p><img src="/2023/08/25/paulgray-jing-dian-zhu-zuo-du-shu-bi-ji-di-yi-zhang/0359f521758ab19a05592cc5fdb2000f202d7d1ff3eaf00f2f46eac55c4c3a88.png" class="" title="picture 22">  <p>在基极施加一个AC电流，将管子的CE短路起来，测量流入C的电流。如下是该电路的小信号模型，</p><img src="/2023/08/25/paulgray-jing-dian-zhu-zuo-du-shu-bi-ji-di-yi-zhang/9aab08be117b3474cec5d756c3735fb10f5f61f904a0846dc883abbcf130b43c.png" class="" title="picture 23">  <p>这里为了计算简单，假设$r_c\rarr0$，那么右边的$r_o$和$C_{cs}$就可以认为是被短路了，对电路的传输函数不起到影响，这时，$C_\mu$的右侧为地，$v_1$的电位为$i_1$流过两个电容和一个电阻的并联，如下所示，</p><p>$$<br>v_1=\frac{1}{s(C_\pi+C_\mu)}||r_\pi i_i=\frac{r_\pi}{s(C_\pi+C_\mu)r_\pi+1}i_i<br>$$</p><p>如果通过$C_\mu$的前馈电流可以忽略不计，那么，可以直接写出集电极短路电流$i_o$，如下所示</p><p>$$<br>i_o=\frac{g_mr_\pi}{s(C_\pi+C_\mu)r_\pi+1}i_i<br>$$</p><p>当频率非常大时，上式中的分母中的1可以忽略不计，这时，当电流增益为1时对应的截至角频率$\omega_T$值也可以直接写出，</p><p>$$<br>\omega_T=\frac{g_m}{C_\pi+C_\mu}<br>$$</p><p>转换成频率为，</p><p>$$<br>f_T=\frac{\omega_T}{2\pi}=\frac{g_m}{2\pi(C_\pi+C_\mu)}<br>$$</p><p>双极型晶体管的幅频响应可以由下面的图进行表达，</p><img src="/2023/08/25/paulgray-jing-dian-zhu-zuo-du-shu-bi-ji-di-yi-zhang/eca6b81a35045a3b763588af4a896fe3bbadbadb03a37992a91a86bcaefaaaab.png" class="" title="picture 24">  <p>图中的$3dB$折点的频率如下所示，</p><p>$$<br>\omega_\beta=\frac{g_m}{(C_\pi+C\mu)g_mr_\pi}=\frac{1}{r_\pi(C_\pi+C_\mu)}<br>$$</p><p>再来分析一下截止频率的时间常数，如下，</p><p>$$<br>\tau_T=\frac{C_\pi}{g_m}+\frac{C_\mu}{g_m}=\frac{C_b}{g_m}+\frac{C_{je}}{g_m}+\frac{C_\mu}{g_m}=\tau_F+\frac{C_{je}}{g_m}+\frac{C_\mu}{g_m}<br>$$</p><p>因为$g_m=I_C/V_T$，所以，这个时间常数是和集电极电流直接相关的，如果集电极电流很大，那么$\tau_T\rarr\tau_F$。对于低电流的情形来说，$\tau_T\rarr\frac{C_{je}}{g_m}+\frac{C_\mu}{g_m}$，并且会导致截止频率的时间常数上升，也就是说会导致截止频率降低，如下图所示，</p><img src="/2023/08/25/paulgray-jing-dian-zhu-zuo-du-shu-bi-ji-di-yi-zhang/01dbb51cd3329b5e3cc097270613423c89238758dc09797f082c350500c7355c.png" class="" title="picture 25">  <p>在大电流的情形下，随着电流增大，截止频率也在降低，这一部分无法用我们的简单模型来进行解释。其实，当电流增大时，$\tau_T\rarr\tau_F$，但是当集电极电流进一步增大，$\tau_F$自身会因为之前说到过的高水平注入（High-level injection）和Kirk效应（Kirk Effect）而显著上升，进一步导致截止频率下降；这两个效应之前说过，也会导致电流放大倍数$\beta$显著下降。</p><h2 id="MOSFET的大信号模型"><a href="#MOSFET的大信号模型" class="headerlink" title="MOSFET的大信号模型"></a>MOSFET的大信号模型</h2><p>MOSFET电路相对于Bipolar电路来说成本更低，与数字电路兼容性更好，于是，在此考虑MOSFET的各种模型。</p><h3 id="MOS器件的传输特性"><a href="#MOS器件的传输特性" class="headerlink" title="MOS器件的传输特性"></a>MOS器件的传输特性</h3><p>下面是一个典型的增强型N沟道MOS管的剖面图，</p><img src="/2023/08/25/paulgray-jing-dian-zhu-zuo-du-shu-bi-ji-di-yi-zhang/59fd95fbe664225a68adbd75f91e02c5127317698424b8ebe7eb15fed1778307.png" class="" title="picture 27">  <p>可以看到源和漏是重掺杂的N型半导体，并且在衬底上有一层薄的氧化层，这个氧化层的结构可能是金属或者是多晶硅。</p><p>这里我产生了为什么需要使用多晶硅的原因，有几个具体的原因需要考虑：</p><ul><li><p>首先是在设计MOS管的时候，$C_{gd}$电容一直是一个问题，因为在制造过程中，$C_{gd}$或多或少会发生重叠，这时候引入了一个全新的技术，叫做自对齐栅技术（Self Aligned Gate），这种技术先生产栅氧化层，再通过离子注入的技术进行源和漏的掺杂操作，这个过程中，栅氧化层充当了一个隔离膜，防止栅下方的区域被掺杂，从而减小GD之间的交叠。但是这个过程中，需要进行退火（Annealing）操作，这个操作的目的是让晶体重新形成，从而得到想要性质的结构，在掺杂之后，由于加入了一些其他的物质，半导体的电气特性可能被改变，这是加温让其中的粒子重新排布，自己形成对应的晶体结构，提高了结构的性能以及可靠性。由于这个过程中需要高温，大概1000摄氏度左右，这时，如果采用金属例如铝，在660摄氏度左右，这时金属就会融化，从而损坏结构。因此，采用多晶硅可以防止栅的接触发生融化的现象。</p></li><li><p>另一方面，据网上的说法，采用多晶硅作为接触可以更好地控制MOSfet的阈值电压。</p></li></ul><p>在MOS管的操作过程中，随着栅源电压$V_{gs}$的不断变化，栅下方区域的电导也会发生变化，从而使得可以通过栅电压来控制源漏之间的电流大小。</p><p>上图所示的MOS管是增强型NMOS管，增强型说的是在$V_{gs}=0$的情形下，是不存在沟道的，沟道需要被增强从而才能导通，上述的MOS管是由P型半导体作为衬底，形成N型沟道（电子）的增强型NMOS管；我们也可以使用N型半导体作为衬底，形成P型沟道组成增强型PMOS管。当栅源电压为零时，源和漏之间实际上是一组背对背的二极管（Back-to-Back），这种结构造成源漏之间的电阻非常巨大，大概为$10^{12}$的量级。</p><img src="/2023/08/25/paulgray-jing-dian-zhu-zuo-du-shu-bi-ji-di-yi-zhang/8da5dc9b28be0c2708df8d4bd7fc66e167d9b35cc7a7352a1c0df15f293140aa.png" class="" title="picture 28">  <p>我们考虑如上图所示的情形，这时候，D、S、B全部接地，G接一个正电位栅和衬底之间就形成了由MOS管的氧化层为电解质的一个电容。正电荷存储在栅上，负电荷存储在衬底里（感应出的N型沟道）。</p><p>我们使用公式1.10（1.2节中的内容），可以得到耗尽层宽度$X$可以表示为如下的公式，</p><p>$$<br>X=(\frac{2\epsilon\phi}{qN_A})^{1/2}<br>$$</p><p>其中，$\phi$表示了耗尽层中靠近氧化硅界面的电位，$N_A$是P衬底的掺杂浓度，当$G$的电位上升时，对应的掺杂的原子中的空穴被电子填满，造成了空穴被耗尽的情形，这也是耗尽区的本质，基于这一原理，我们可以直接写出耗尽区对应的电荷大小，</p><p>$$<br>Q=qN_AX=\sqrt{2qN_A\epsilon\phi}<br>$$</p><p>当表面电势达到了两倍的费米能级$\phi_f$，反型就发生了，也就是在原本应该是空穴主导的P型半导体的区域出现了电子主导的情形。费米能级由下面的表达式表达，</p><p>$$<br>\phi_f=\frac{kT}{q}ln[\frac{N_A}{n_i}]<br>$$</p><p>上面的表达式可以根据我们之前说的一个班的孩子在一个书架面前比赛谁能够到最高的书的案例进行记忆，其中$kT/q$表示了在某一特定温度下，粒子具有的平均能量，随着掺杂浓度越高，要将一半的粒子加能到导带的能量就越大，这个关系随着掺杂浓度提高会发生对数增长。费米能级电势通常为0.3V，随着在硅中的电势达到0.6V，进一步提升栅中的电压就不会造成耗尽层的宽度发生变化，而会在耗尽层中感应出一层薄薄的电子，这层电子紧贴着氧化层。反型层在源和漏之间形成了一个连续的N型区域，这个区域形成了导电的沟道。这个通道的导电能力会被栅源电压之间的变化所调制。</p><p>MOS管的阈值电压由下面的表达式进行表达，</p><p>$$<br>V_t=V_{t0}+\gamma(\sqrt{2\phi_f+V_{SB}}-\sqrt{2\phi_f})<br>$$</p><p>其中，$V_{t0}$为体电压接地时的阈值电压，即没有考虑体效应时的阈值电压，$\gamma$的典型值为$0.5[V^{1/2}]$，从上面的表达式中可以看出，体效应一定程度上会对管子的沟道起到调制作用，但是是根号规律的调制，相比于栅的线性调制来说，要更加弱一些。$V_{t0}$的值实际上是通过在沟道区域中进行掺杂来实现调整的，在沟道中调整P掺杂的浓度可以将管子的$V_{t0}$在0.3V和1.5V之间调整；在沟道中加入N型的掺杂，可以让沟道在$V_{GS}=0$的条件下就处于导通状态。</p><p>接下来计算n沟道MOSFET的大信号特性，在接下去的分析中，假设S接地，其余端子D、G、B均有对应电位，如下图所示，</p><img src="/2023/08/25/paulgray-jing-dian-zhu-zuo-du-shu-bi-ji-di-yi-zhang/29405aa974765f69300480170137fdc80ff397f11acfd66e8a0279d091eaadf6.png" class="" title="picture 29">  ]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Paul Gray </tag>
            
            <tag> 模拟IC设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二阶系统的各项指标总结</title>
      <link href="/2023/08/22/er-jie-xi-tong-de-ge-xiang-zhi-biao-zong-jie/"/>
      <url>/2023/08/22/er-jie-xi-tong-de-ge-xiang-zhi-biao-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>二阶系统一般有两个极点组成，这两个极点的距离的关系决定了二阶系统的稳定性，本质上这种分析方法是在求解偏微分方程的解。注意，这里所说的二阶系统的方程都是说的是闭环系统。</p><h2 id="二阶系统的基本概念"><a href="#二阶系统的基本概念" class="headerlink" title="二阶系统的基本概念"></a>二阶系统的基本概念</h2><p>先给出一个二阶系统的拉普拉斯方程。</p><p>$$<br>Sys(s)=\frac{1}{s^2+2\zeta \omega_ns+\omega_n^2}<br>$$</p><p>其中的$\zeta$是阻尼系数，$\omega_n$是自然频率。</p><p>接下去我们给出由阻尼系数和自然频率给出的极点位置的表达式。</p><p>$$<br>P = -\zeta \omega_n\pm j\omega_n\sqrt{1-\zeta^2}<br>$$</p><p>我们可以看出极点的辐角，由下面的表达式表达，</p><p>$$<br>\theta=\pm arctan\frac{\sqrt{1-\zeta^2}}{\zeta}<br>$$</p><h3 id="求解相位裕度"><a href="#求解相位裕度" class="headerlink" title="求解相位裕度"></a>求解相位裕度</h3><p>这里读者需要注意，直接从我们之前的闭环传输函数推导出相位裕度是不可行的，因为相位裕度本身就是在开环传输函数上求解的，因此，我们需要知道开环传输函数与我们的闭环传输函数之间的关系。</p><p>假设下面的开环传输函数，</p><p>$$<br>A_{OL}=\frac{A_o}{(1+s/s_1)(1+s/s_2)}=\frac{A_o}{1+(1/s_1+1/s_2)s+s^2/(s_1s_2)}<br>$$</p><p>通常来说，我们的闭环传输函数的反馈系数$\beta = 1$，因此，求得下面的闭环传输函数。</p><p>$$<br>A_{CL}=\frac{A_{OL}}{1+A_{OL}\beta}=\frac{A_o}{1+(1/s_1+1/s_2)s+s^2/(s_1s_2)+A_o}<br>$$</p><p>将上式化简之后我们可以获得如下的表达式，</p><p>$$<br>A_{CL}=\frac{1}{1+\frac{s}{s_1A_o}+\frac{s^2}{s_1A_os_2}}<br>$$</p><p>可以看到，这里做了一些化简，并且注意到，假设$s_1$是主极点，有，$s_1A_o=GBW$，再重新写一下上式，我们可以获得如下的信息，</p><p>$$<br>A_{CL}=\frac{1}{1+\frac{s}{GBW}+\frac{s^2}{GBWs_2}}<br>$$</p><p>再根据我们先前推导的二阶系统的表达式，我们可以知道如下信息，</p><p>$$<br>PM=\frac{\pi}{2}-arctan\frac{GBW}{s_2}<br>$$</p><p>$$<br>\omega_n=\sqrt{GBWs_2}<br>$$</p><p>$$<br>2\zeta \omega_n=s_2<br>$$</p><p>$$<br>\zeta=\frac{1}{2}\sqrt{\frac{s_2}{GBW}}<br>$$</p><p>由上面的式子我们可以直接由系统的参数写出系统的阻尼系数、振荡频率等参数。简单来说，阻尼系数由非主极点和GBW的比例决定，比例越大，非主极点离GBW距离越远，阻尼系数越大。一般情况下，阻尼系数设置为$\frac{1}{\sqrt{2}}$合适，这时候，非主极点为GBW的两倍，相位裕度为63°左右。</p><h3 id="品质因素-Q-的定义"><a href="#品质因素-Q-的定义" class="headerlink" title="品质因素$Q$的定义"></a>品质因素$Q$的定义</h3><p>我们再研究一下Q的定义，在滤波器中Q的定义为幅度最大的频率$\omega_o$与滤波器的3dB带宽的频率$\Delta\omega$的比值，由下面的式子表达。</p><p>$$<br>Q’=\frac{\omega_o}{\Delta\omega}=\frac{\omega_n}{\zeta\omega_n}=\frac{1}{\zeta}<br>$$</p><p>实际的Q需要在此值上除以一个2，这里还没有一个很好的解释，如下面的式子所示，</p><p>$$<br>Q=\frac{1}{2\zeta}<br>$$</p><p>如果阻尼系数$0&lt;\zeta&lt;1$，这也是通常我们研究的情形，在这种情形下，振荡频率会从原先的0阻尼振荡频率$\omega_r=\omega_n$，修正为$\omega_r=\omega_n\sqrt{1-\zeta^2}$。这里需要特别说明一下表达式$\sqrt{1-\zeta^2}$本身也是有一定物理意义的。</p><h3 id="sqrt-1-zeta-2-的物理意义"><a href="#sqrt-1-zeta-2-的物理意义" class="headerlink" title="$\sqrt{1-\zeta^2}$的物理意义"></a>$\sqrt{1-\zeta^2}$的物理意义</h3><p>该量在二阶系统的很多数学特征中有所体现，体现为一个修正量，这个修正量与阻尼系数成反比，阻尼系数越大，该修正量越小，修正得越多，阻尼系数越小，该修正量越接近于1，越趋近于不修正；并且，该修正量在阻尼系数大得时候，变化得更显著。因此，总结一下就是，修正量主要对阻尼系数大的情形进行修正，会将原先的量修正小。</p><h3 id="频率响应的最大值"><a href="#频率响应的最大值" class="headerlink" title="频率响应的最大值"></a>频率响应的最大值</h3><p>如果阻尼系数$0&lt;\zeta&lt;1$，那么，频率响应在谐振频率$\omega_r=\omega_n\sqrt{1-\zeta^2}$处取得最大值，将，上述表达式代入二阶系统的频率响应中，得到最大的幅频响应值，这个值也是peaking的大小，表达式如下所示，</p><p>$$<br>P_r=\frac{1}{2\zeta\sqrt{1-\zeta^2}}=\frac{Q}{\sqrt{1-\zeta^2}}<br>$$</p><p>可以看到，Q一定程度上代表了Peaking的高度，只不过被修正了，阻尼系数越大，修正得越多，阻尼系数越小，修正得越少。所以在一些小阻尼系数得系统里面，可以直接使用Q估计Peaking的高度。</p><h3 id="二阶系统的瞬态响应时域表达式"><a href="#二阶系统的瞬态响应时域表达式" class="headerlink" title="二阶系统的瞬态响应时域表达式"></a>二阶系统的瞬态响应时域表达式</h3><p>先给出二阶系统的瞬态响应时域表达式：</p><p>$$<br>y(t)=1-e^{-\zeta\omega_n t}(cos(\omega_r t)+\frac{\zeta}{\sqrt{1-\zeta^2}}sin(\omega_r t))<br>$$</p><p>其中，$\omega_r$指的是阻尼系数修正后的振荡频率，如下所示，</p><p>$$<br>\omega_r=\omega_n\sqrt{1-\zeta^2}<br>$$</p><p>其瞬态响应的最大值出现在$\frac{\pi}{\omega_r}$处，把这个值代入到时域的瞬态表达式中，我们可以得到如下的瞬态响应最大值，</p><p>$$<br>M_p=1+e^{\frac{-\pi\zeta}{\sqrt{1-\zeta^2}}}<br>$$</p><p>将上述表达式绘制成图像，可以得到如下结果，</p><img src="/2023/08/22/er-jie-xi-tong-de-ge-xiang-zhi-biao-zong-jie/f3e1e5eaa19d0d1fce61ea5765e7c87fd4268976b28c820533b732a32c70c5b5.png" class="" title="picture 0">  <p>观察图片可以发现，当阻尼系数为零时，过冲最大，当阻尼系数为1时，没有过冲。</p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>分析一个闭环放大器，该放大器的开环响应存在主极点@10kHz，非主极点@2MHz，该放大器的开环增益为40dB，反馈系数为1，分析该二阶系统的各项参数。</p><p>先给出该放大器的s域开环系统传递函数：</p><p>$$<br>A_{OL}=\frac{100}{(s/1e4+1)(s/2e6+1)}=\frac{100}{s^2/2e10+s/1e4+1}<br>$$</p><p>再计算闭环系统的传递函数：</p><p>$$<br>A_{CL}=\frac{100}{s^2/2e10+s/1e4+100}=\frac{2e12}{s^2+2e6s+2e12}<br>$$</p><p>接下去可以求解出该表达式的自然频率$\omega_n$，如下所示，</p><p>$$<br>\omega_n=\sqrt{2e12}\approx1.414MHz<br>$$</p><p>接下去求解系统的阻尼系数$\zeta$，如下所示，</p><p>$$<br>2\zeta\omega_n=2e6<br>$$</p><p>$$<br>\zeta=\frac{2e6}{2\omega_n}=\frac{1}{\sqrt{2}}<br>$$</p><p>这里还需要说明，当阻尼系数为0.707时，该传输函数称为一种特殊的滤波器：Butterworth Filter。这里简单介绍一下Butterworth滤波器，这种滤波器在带内完全平坦，这里需要说明的是，这里说的平坦是指滤波器频率响应，而不是瞬态响应，要记住，Butterworth滤波器的瞬态响应根据先前的计算，是存在一定的过冲的。Butterworth滤波器的频率响应具有一下的特点：</p><ul><li>在通带内的幅度响应的平坦的；</li><li>频率响应从通带到禁带的变化是单调的，即不存在任何的上下波动；</li><li>禁带内的滚降是平滑的，并且随着滤波器阶数的上升而上升。</li></ul><p>值得注意的是，Butterworth由于其通带内平坦的特性而被广泛应用，但是其从通带到禁带的过渡部分不像切比雪夫滤波器和椭圆滤波器那样迅速滚降，即滚降速率比较慢。</p><p>计算品质因素Q的值，根据之前的表达式$Q=\frac{1}{2\zeta}$，Q的表达式由下式表达，</p><p>$$<br>Q=\frac{1}{2\zeta}=\frac{1}{\sqrt{2}}=0.707<br>$$</p><p>有了Q之后，我们就可以计算修正后的Q，这个值代表了幅频响应中的Peaking高度$P_r$</p><p>$P_r=\frac{Q}{\sqrt{1-\zeta^2}}=\frac{1/\sqrt{2}}{1/\sqrt{2}}=1$</p><p>这也论证了我们之前说这是一个Butterworth滤波器的结论。接下去再计算时域中的过冲$M_p$，由下式表达</p><p>$$<br>M_p=e^{\frac{-\pi\zeta}{\sqrt{1-\zeta^2}}}=e^{-\pi}\approx0.04<br>$$</p><p>可以看到瞬态响应中是由一定的过冲的，过冲的比例$%OS$为$4%$基本可以忽略不计。</p>]]></content>
      
      
      <categories>
          
          <category> 控制理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟IC设计 </tag>
            
            <tag> 放大器设计 </tag>
            
            <tag> 控制理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADC SAR Logics Timing Analysis</title>
      <link href="/2023/07/22/adcsarlogicstiminganalysis/"/>
      <url>/2023/07/22/adcsarlogicstiminganalysis/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近在做SAR逻辑的版图优化工作，遇到了一些奇怪的问题，在总结错误之后，将SAR逻辑的工作原理以及时序分析记录在这里，以供之后进行查阅。</p><h2 id="SAR逻辑做Retiming的动机以及时序"><a href="#SAR逻辑做Retiming的动机以及时序" class="headerlink" title="SAR逻辑做Retiming的动机以及时序"></a>SAR逻辑做Retiming的动机以及时序</h2><p>在SAR ADC中，对比较器输出结果做Retiming之后，再输出给寄存器进行寄存，这样保证了寄存器输出拨动CDAC的时刻不存在先后，避免了有的比较器输出结果比较缓慢，在判断过程中，迅速判断出结果的比较器波动CDAC从而影响有的比较器的结果。</p><p>其时序如下所示，</p><img src="/2023/07/22/adcsarlogicstiminganalysis/2e8a2478645bf0a33481f345e271ade92444ed52e32bb32da4f0a9726b8c3c5e.svg" class="" title="picture 0">  <p>采样跟随时钟拉低代表ADC正在进行Tracking，其拉高后表示Tracking阶段结束，进入到转换阶段，该时钟拉高后，比较器的Self Clock被拉高，这时，比较器结束默认的复位状态，准备接受来自CDAC输出的需要进行比较的数据，这时CDAC被拨动，进入到Reset Phase。</p><p>经过30ps~60ps左右的时间，三个比较器根据其输入大小异步地产生三个输出，当三个输出都准备好后，SAR逻辑判断并驱动寄存器和比较器的自时钟进行翻转，寄存器的Self Clock先进行翻转，通知输出到寄存器的数据可以被释放到寄存器的输入，这时，三组数据同时进入到寄存器中，寄存器复位状态在跟随相的时候就已经被解除了，所以，寄存器一检测到输入，便立即开始进行锁存操作，寄存根据输入判断得到得三组结果。</p><p>在寄存器得到输入后$10$~$20ps$左右的时间，比较器开始进行复位操作，经过大概$30ps$左右，SAR逻辑检测到比较器复位完成后，便驱动Self Clock进行翻转，先翻转寄存器，再翻转比较器。寄存器翻转之后，触发本级的寄存器的读入时间窗口关闭，并驱动下一级的读入窗口开启，由于此时比较器已经完成了复位，所以下一级寄存器打开也不会导致同一Cycle的数据被读入两级的寄存器中。</p><p>比较器翻转后，从复位状态进入了比较状态，开始了下一个周期的比较。</p><p>上述内容不断重复，直到最后的数据被读入到寄存器中，触发ED信号，使自时钟关闭，便结束了一个样本的转换操作。</p><p>现在来分析一下时间是如何分配在ADC的转换时序中的，假设采样跟随时钟拉低的时刻为零，经过大概$250ps$左右的时间后，采样跟随过程完成，时钟被拉高，驱动比较器Self Clock进行翻转，进入到比较状态，经过至少30ps左右的时间，三个比较器逐步产生结果，再经过$30ps$左右的时间，三个比较器的结果经过Retiming的逻辑被释放到寄存器的输入，同时，三个比较器，开始进行复位操作，经过$40ps$左右的时间，被释放到寄存器的输入寄存后输出至CDAC进行拨动CDAC的操作，一个SAR Cycle大概$130ps$左右的时间仅剩下$30ps$左右的时间剩下给CDAC进行建立了。</p><p>分析一下上述过程，其中由CDAC输出到比较器产生输出的时间我们没法进行控制，但是我们可以取消Retiming来获取$30ps$的时间。</p><h2 id="SAR逻辑不做Retiming的动机以及时序"><a href="#SAR逻辑不做Retiming的动机以及时序" class="headerlink" title="SAR逻辑不做Retiming的动机以及时序"></a>SAR逻辑不做Retiming的动机以及时序</h2><p>在绘制版图后，由于REF建立时间变慢，导致最终的输出还没建立好就进行了比较，一方面是由于REF的建立时间变慢，另一方面还因为CDAC拨动的时刻太慢了，理应在比较器出结果之后就立刻进行拨动，但是经过Retiming以及逻辑后，延迟了$30ps+40ps=70ps$的时间，总共SAR逻辑的时间只有$170ps$左右，CDAC建立的时间仅仅留了一半不到，如果在极限情况下，SAR逻辑的时间只有$130ps$，那么留给CDAC建立的时间仅仅只有30ps了，对于CDAC来说，建立将变得十分困难，因为REF是按照170ps左右的时间进行设计的，因此，这大大超出了REF BUF的能力。</p><p>下面给出不做Retiming的时序图，</p><img src="/2023/07/22/adcsarlogicstiminganalysis/66ed2cba7e97007a9f19d47febb6494196e76feb4cba9ccfa0ec1f816108489a.svg" class="" title="picture 1">  <p>这幅图中消去了比较器输出到寄存器的Delay，这个Delay主要由Retiming引起的，长度大约为$30ps$，消去了这个时间之后，CDAC拨动的时间就会提前$30ps$，但比较器进行比较的时间保持不变，因为比较器开始比较的时间不取决于寄存器的输出，而是取决于比较器的输出。这样，CDAC的建立就多出来了$30ps$的时间。</p><p>但是这个方案有一定的问题，因为寄存器Self Clock在比较器输出结果的时候仍然是低，这时候，一旦寄存器输出结果了，就会马上触发Q信号，告诉下一级寄存器要开始寄存结果了，这就会导致不仅仅本级的寄存器寄存了结果，下一级的寄存器也寄存了相同的结果，导致时序出错。</p><p>这时我们仅仅需要改变寄存器的时钟，使其检测到输入的时候，寄存器的Self Clock拉高状态即可，很显然，我们可以直接让比较器Self Clock和寄存器的Self Clock为同一个时钟，即可满足这一需求，如下的时序图所示，</p><img src="/2023/07/22/adcsarlogicstiminganalysis/7cb3e0f284376fc6cba9b0bb6b68642df51952b63e5b9ca2e1f0ed475aa43b97.svg" class="" title="picture 2">  <p>当然这样的时序图仍然存在潜在问题，那就是寄存器还没有关闭之前，比较器就进行了复位，输出到寄存器的数据就发生了变化，会影响寄存器寄存的结果，但是就仿真而言，这样的情况并不会发生。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>到这里，关于SAR逻辑的时序分析就结束了，这里探讨了使用Retiming的好坏，以及对应的时序应该做如何的调整。到这里我才深刻理解了为什么SAR逻辑有两个环路，其实，这两个环路有所交叠，由比较器产生结果的时刻开始，两个Self Clock就开始驱动两个部件完成不同的任务，比较器需要完成复位，寄存器需要对比较器的输出结果进行寄存，这就要求比较器需要在寄存器寄存结果后才进行复位操作，防止出现数据还没有被寄存就被复位的情况，同时寄存器的输出去拨动CDAC，产生对应的输出，等待比较器复位完成后，驱动两个Self Clock进行翻转，一方面驱动寄存器关闭，另一方面驱动比较器进行下一次比较。</p><p>至此，我理解了整个SAR逻辑的工作过程，感觉调电路更有方向了！</p>]]></content>
      
      
      <categories>
          
          <category> ADC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADC </tag>
            
            <tag> SAR逻辑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>传输线理论</title>
      <link href="/2023/07/12/chuan-shu-xian-li-lun/"/>
      <url>/2023/07/12/chuan-shu-xian-li-lun/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近在做项目时，遇到了需要使用传输线理论进行解释的电路，于是最近对传输线理论有了一个新的认识，并且，理论与实践相结合得到了一个比较容易理解的认识。</p><h2 id="传输线理论"><a href="#传输线理论" class="headerlink" title="传输线理论"></a>传输线理论</h2><p>当传输线的长度和波长差不多时，直观上读者就可以想象，在传输线上各点的相位肯定不一样，这时就会导致传输线上各点的电压不同，这就是传输线效应。一般来讲，当传输线的长度大于波长的$1/10$时，就需要考虑这种效应了。</p><h3 id="传输线方程"><a href="#传输线方程" class="headerlink" title="传输线方程"></a>传输线方程</h3><p>基本的传输线模型如下图所示，</p><img src="/2023/07/12/chuan-shu-xian-li-lun/4b46f2298ffea3c89bc1339fb5289d45b74627c92fa6ef2ef83f33ca860a7cb9.png" class="" title="picture 1">  <p>传输线本质上是一个拥有返回路径的长度为$z$导线，然后为了方便分析，将传输线分割成长度为$\Delta z$的导线，定义电阻、电感、电导、电容的单位长度密度为如下，</p><p>$R’=\rho/A[\Omega/m]$：单位长度下的电阻大小；</p><p>$L’=\mu[H/m]$：单位长度上的电感大小；</p><p>$G’=1/R’[S/m]$：单位长度上的导纳大小；</p><p>$C’=\epsilon A/d[F/m]$：单位长度上的电容大小；</p><p>一般来说，在集成电路里面，电感的大小为$1nH/mm$，电容的大小为$1fF/\mu m$。需要注意的是，电感的长度密度大小是与真空磁导率$\mu_0=4\pi\times10^{-7}\approx1.25e-6$直接相关的，大概是$1.25nH/mm$，这个值与我们之前给的经验值基本一致，这里需要解释一下为什么使用真空磁导率计算的电感密度结果就与经验值差不多，这是因为铝和铜这两种导线材质的相对磁导率基本接近1，所以不需要对磁导率进行调整。</p><p>将传输线进行微分后，得到如下的微元，</p><img src="/2023/07/12/chuan-shu-xian-li-lun/b9aaf00627977074d9a1ecaf4d9a5cbbb9313b66827627fea8d7e5cb75f48ee7.png" class="" title="picture 2">  <p>写出上图中的KVL方程：</p><p>$$<br>v(z,t)=R\Delta zi(z,t)+L\Delta z\frac{di(z,t)}{dt}+v(z+\Delta z,t)<br>$$</p><p>写出上图中的KCL方程：</p><p>$$<br>i(z,t)=G\Delta zv(z+\Delta z,t)+C\Delta z\frac{dv(z+\Delta z,t)}{dt}+i(z+\Delta z,t)<br>$$</p><p>如果$\Delta z\rightarrow0$，那么上述的两个表达式可以化为如下的互耦表达式，</p><p>$$<br>-\frac{\partial v(z,t)}{\partial z}=R(i,t)+L\frac{\partial i(z,t)}{\partial t}<br>$$</p><p>$$<br>-\frac{\partial i(z,t)}{\partial z}=Gv(z,t)+C\frac{\partial v(z,t)}{\partial t}<br>$$</p><p>对于正弦波输入的电压和电流而言，可以使用如下的Phasor（相量）形式，</p><p>$$<br>v(z,t)=Re{V(z)e^{j\omega t}}<br>$$</p><p>$$<br>i(z,t)=Re{I(z)e^{j\omega t}}<br>$$</p><p>上述两个方程和的解如下，</p><p>$$<br>V(z)=V^+(z)+V^-(z)=V_0^+e^{-\gamma z}+V_0^-e^{\gamma z}<br>$$</p><p>$$<br>I(z)=I^+(z)+I^-(z)=I_0^+e^{-\gamma z}+I_0^-e^{\gamma z}<br>$$</p><p>上述方程将波分为了两个方向传播的过程，一个是正向的传播，还有一个是负向的传播，该方程描述了电压在传输线上的分布，其中$\gamma$是一个无量纲的数值，称为传输常数（Transmission Constant），主要描述了电压在传输线上的分布特征。读者可以想象，$\gamma$是一个类似于$e^{\omega t}$中的$\omega$，这个值主要描述了电压的相位在时间轴上的变化速度，$\omega$越大，在时间轴上，电压相位变化速度越快；同样的，在距离x轴上，$\gamma$越大，电压相位在相同距离上变化得越多。</p><p>传输常数$\gamma$的表达式如下所示，</p><p>$$<br>\gamma=\alpha+j\beta=\sqrt{(R+j\omega L)(G+j\omega C)}<br>$$</p><p>如果这里的衰减系数为0，那么$\gamma=j\beta$，该传输函数的量纲为$[rad/m]$。</p><p>这里还给出了特征阻抗的定义，</p><p>$$<br>Z_0=\frac{V_0^+}{I_0^+}=-\frac{V_0^-}{I_0^-}=\frac{R+j\omega L}{\gamma}=\sqrt{\frac{R+j\omega L}{G+j\omega C}}<br>$$</p><p>注意到这里的量纲为$[\Omega/m]$。</p><p>特征阻抗$Z_0$和传输函数$\gamma$是传输线两个最重要的参数，值得注意的是，这两个参数与传输线的长度无关，只与传输线上的（$RLGC$）有关。</p><h3 id="无损传输线案例分析"><a href="#无损传输线案例分析" class="headerlink" title="无损传输线案例分析"></a>无损传输线案例分析</h3><p>对于无损传输线来说，电阻$R$以及电导$G$的贡献均为零，因此，对于传输常数来说，只会在长度上产生相位的变化，并不会产生衰减。在这一层面上，传输函数的意义非常明确，传输函数代表了一定长度上，电压相位的变化，因此，如果要知道信号在传输线中的波长，只需要知道相位变化$2\pi$时，走了多少长度即可，因此波长由下式表达，</p><p>$$<br>\lambda=\frac{2\pi}{\gamma}=\frac{2\pi}{\beta}=\frac{1}{f\sqrt{LC}}<br>$$</p><p>对于一个10GHz的信号来说，根据先前我们给定的如下经验参数，</p><p>$$<br>L=1nH/mm<br>$$</p><p>$$<br>C=1fF/\mu m<br>$$</p><p>可以计算得到10GHz的信号在芯片传输线中的波长为如下，</p><p>$$<br>\lambda=\frac{1}{f\sqrt{LC}}=\frac{1\mu m}{10G\sqrt{1pH\times 1fF}}=3.16mm<br>$$</p><p>因此，对于10GHz左右的信号来说，300um以上的线就必须要考虑传输线效应了。</p><p>在考虑特征阻抗，如果传输线时无耗传输线，那么，特征阻抗的表达式如下所示，</p><p>$$<br>Z_0=\sqrt{\frac{R+j\omega L}{G+j\omega C}}=\sqrt{\frac{L}{C}}<br>$$</p><p>如果使用我们的经验参数计算特征阻抗，得到下面的数值，</p><p>$$<br>Z_0=\sqrt{\frac{L}{C}}=\sqrt{\frac{1pH/\mu m}{1fF/\mu m}}=32\Omega<br>$$</p><h3 id="Terminated的传输线的反射"><a href="#Terminated的传输线的反射" class="headerlink" title="Terminated的传输线的反射"></a>Terminated的传输线的反射</h3><p>反射系数$\Gamma$描述了反射波与入射波的比例，反射系数$/Gamma$的表达式如下，</p><p>$$<br>\Gamma=\frac{V_0^-}{V_0^+}=\frac{Z_L-Z_0}{Z_L+Z_0}<br>$$</p><p>上述表达式很容易记忆，$Z_0$表示传输线的特征阻抗，$Z_L$表示传输线驱动的负载。当传输线驱动的负载为开路，也就是无穷大时，传输线应该将所有信号全部反射回去，也就是反射系数为1，这样就把表达式分子上的符号记住了。</p><p>接下去给出传输线反射相关的内容的一个计算实例，假设一个800um的传输线，16GHzCMOS时钟，驱动一个负载为$200fF$的电容，计算其在输入位置是否会因为反射而产生过压现象？</p><p>首先根据先前的经验公式，得到传输线的特征阻抗为，</p><p>$$<br>Z_0=\sqrt{\frac{L}{C}}=\sqrt{\frac{1pH/\mu m}{1fF/\mu m}}=32\Omega<br>$$</p><p>接下去计算反射系数$\Gamma$，</p><p>$$<br>\Gamma=\frac{\frac{1}{j\omega C}-32}{\frac{1}{j\omega C}+32}=\frac{1-32j\omega C}{1+32j\omega C}=\frac{1-0.1024j}{1+0.1024j}\approx1\angle-11.69\degree<br>$$</p><p>可以发现，该反射波在原先输入波的基础上，滞后了$11.69\degree$，幅度基本不变，如果反射波和入射波进行叠加之后，产生的新的波形的幅度可以看到是变为原先正常波形的接近两倍。</p>]]></content>
      
      
      <categories>
          
          <category> 模拟IC设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟IC设计 </tag>
            
            <tag> 传输线理论 </tag>
            
            <tag> 微波工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leeson-Cutler Phase Noise Model里森相噪模型</title>
      <link href="/2023/06/14/leeson-cutlerphasenoisemodel-li-sen-xiang-zao-mo-xing/"/>
      <url>/2023/06/14/leeson-cutlerphasenoisemodel-li-sen-xiang-zao-mo-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>先直接给出Leeson-Cutler相位噪声模型的表达式，如下所示，</p><p>$$<br>L(\Delta \omega)=10\cdot log{\frac{2FkT}{P_s}\cdot[1+(\frac{\omega_0}{2Q_L\Delta\omega})^2]\cdot(1+\frac{\Delta\omega_{1/f^3}}{|\Delta\omega|})}<br>$$</p><p>其中</p><ul><li>$F$是一个经验参数（device excess noise number），AI给出的这个参数的大致范围是0.5~2.0；</li><li>$k$是玻尔兹曼常数（1.38e-23）；</li><li>$T$是绝对温度；</li><li>$P_s$是在tank里的电阻部分消耗的平均功率；</li><li>$\omega_0$是震荡频率；</li><li>$Q_L$是tank的有效品质因数，之所以称之为有效因为这时所有的负载全部加在这个上面，AI告诉我这个值大概是10~100；</li><li>$\Delta\omega$代表了频率偏移主频的值；</li><li>$\Delta\omega^3_{1/f}$代表了$1/f^3$区域与$1/f^2$区域的交界区域，如下图所示；</li></ul><img src="/2023/06/14/leeson-cutlerphasenoisemodel-li-sen-xiang-zao-mo-xing/6f6f84cd03c727a60437e5a44c57e16f304bfe1adb8bc8433fea4f2a53e1f4a1.png" class="" title="picture 1">  <h4 id="1-x2F-f-2-区域的噪声"><a href="#1-x2F-f-2-区域的噪声" class="headerlink" title="$1/f^2$区域的噪声"></a>$1/f^2$区域的噪声</h4><p>该区域的噪声可以通过下面的模型进行建模，先考虑一个RLC并联电路的输入阻抗，</p><img src="/2023/06/14/leeson-cutlerphasenoisemodel-li-sen-xiang-zao-mo-xing/0eab80f179513f55a2d002fe0307474c19eb56b734b862bc273947bd3cc1df9b.png" class="" title="picture 1">  <p>上述电路的阻抗$Z(s)$由下面的表达式表达，</p><p>$$<br>Z(s)=\frac{1}{1/R+1/sL+sC}<br>$$</p><p>通分化简后得到下面的表达式，</p><p>$$<br>Z(s)=\frac{sLR}{sL+R+s^2LCR}<br>$$</p><p>因为我们考虑的频率是$s=j(\omega_0+\Delta \omega)$，并且中心频率为$\omega_0=1/\sqrt{LC}$，将上述两个关系代入到我们的阻抗表达式中进行化简，</p><p>$$<br>Z(s=\omega_0+\Delta\omega)=\frac{j(\omega_0+\Delta \omega)LR}{j(\omega_0+\Delta\omega)L+R-\omega_0^2LCR-2\omega_0\Delta\omega LCR-\Delta\omega^2LCR}<br>$$</p><p>考虑到$\Delta\omega&lt;&lt;\omega_0$，所以，$\Delta\omega^2LCR$的一项可以被忽略；另一方面，由于$\omega_0^2=1/LC$，所以$-\omega_0^2LCR=-R$与前面的一项$R$抵消；并且，$-2\omega_0\Delta\omega LCR=2\Delta\omega R/\omega_0$。经过上述三步的化简，得到下面的表达式，</p><p>$$<br>Z(\omega_0+\Delta\omega)\approx\frac{j(\omega_0+\Delta \omega)LR}{j(\omega_0+\Delta \omega)L-2\Delta\omega R/\omega_0}<br>$$</p><p>将上述分式上下同时乘以$-j$，并且同时除以$(\omega_0+\Delta\omega)L$之后，得到下面的表达式，</p><p>$$<br>Z(\omega_0+\Delta\omega)\approx\frac{R}{1+j\frac{2\Delta\omega R/\omega_0}{(\omega_0+\Delta\omega)L}}<br>$$</p><p>其中我们定义$Q=\frac{R}{\omega L}$为品质因数，在我们的这个问题中，品质因数定义为$Q_L=\frac{R}{(\omega_0+\Delta\omega)L}$，因此，根据这一个等式，上面的阻抗表达式可以进一步表示为，</p><p>$$<br>Z(\omega_0+\Delta\omega)\approx\frac{R}{1+j2Q_L\Delta\omega/\omega_0}<br>$$</p><p>需要注意的是，上述表达式仅仅在$\omega_0$振荡频率附近（$\Delta\omega&lt;&lt;\omega_0$）才成立。</p><p>一般是计算等效输入噪声，噪声源作用在整个电路的输入上，振荡电路一般是一个正反馈环路，也就是如下图所示的电路框图结构，</p><img src="/2023/06/14/leeson-cutlerphasenoisemodel-li-sen-xiang-zao-mo-xing/4acb4a74227d76008a15eb9418fe87477f7ee163f4381af9adebd66f730afa4e.png" class="" title="picture 2">  <p>上面的噪声电流源相当于作用在这个正反馈环路上，因此传输函数可以用下面的表达式进行表达，</p><p>$$<br>H(\Delta\omega)=\frac{v_{out}}{i_{in}}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 相位噪声 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 相位噪声 </tag>
            
            <tag> VCO </tag>
            
            <tag> 物理数学模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI小助手合集</title>
      <link href="/2023/06/14/ai-xiao-zhu-shou-he-ji/"/>
      <url>/2023/06/14/ai-xiao-zhu-shou-he-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>最近在B站和Youtube上看到了许多与AI有关的内容，自从OPENAI的ChatGPT模型问世之后，各种AI的应用层出不穷，最常用的就是使用ChatGPT进行对话，这个应用让我感到十分震惊。当然你可能需要使用AI进行一系列的应用，例如自动制作视频，自动分析视频内容，自动分析文档内容等等。我本人现在还处在学生阶段，因此，对于我来说最有帮助的应该是科研相关的AI应用技术，这里，将这些应用程序或者网站收集起来，并存储在这个网页中，供以后参考。</p><h3 id="应用程序列表（Paper相关）"><a href="#应用程序列表（Paper相关）" class="headerlink" title="应用程序列表（Paper相关）"></a>应用程序列表（Paper相关）</h3><ul><li><a href="https://researchrabbitapp.com/home" target="_blank" rel="noopener">Research Rabbit</a> 这个网站主要是帮助读者从一篇文章中找寻到其他相关的文章，帮助读者发现与当前文章相关的文章，并且根据文章内容和索引给出相关的文章。</li><li><a href="https://www.chatpdf.com/" target="_blank" rel="noopener">chatPDF</a> 这个网站主要是帮助读者进行阅读PDF的，因为有些Paper的内容可能比较复杂难懂，这里就可以以对话的形式进行Paper内容的分析，非常有帮助。</li><li><a href="https://typeset.io/" target="_blank" rel="noopener">SCISPACE</a> 这个网站主要是帮助读者从PDF中获取有效信息，可能和chatPDF类似，也是帮助你来阅读Paper的，非常有效。</li></ul>]]></content>
      
      
      <categories>
          
          <category> AI工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI工具 </tag>
            
            <tag> 奇技淫巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>低压带隙基准</title>
      <link href="/2023/05/26/di-ya-dai-xi-ji-zhun/"/>
      <url>/2023/05/26/di-ya-dai-xi-ji-zhun/</url>
      
        <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>最近有一个需求需要做一个低压带隙基准，本人之前制作的带隙基准都是高压带隙基准，输出的电压都是1.25V的带隙电压，这次突然要做一个低压带隙基准，对本人也是一种考验。于是，我调研了低压带隙基准，根据如下论文进行了设计工作，参考文献如下，</p><p>B. Razavi, “The Design of a Low-Voltage Bandgap Reference [The Analog Mind],” in IEEE Solid-State Circuits Magazine, vol. 13, no. 3, pp. 6-16, Summer 2021, doi: 10.1109/MSSC.2021.3088963.</p><h3 id="普通带隙基准是如何工作的？"><a href="#普通带隙基准是如何工作的？" class="headerlink" title="普通带隙基准是如何工作的？"></a>普通带隙基准是如何工作的？</h3><p>带隙基准的目的就是获得一个与温度无关的电压，我们利用一个与温度成反比的NTAT电压，加上一个与温度成正比的PTAT电压，就可以获得一个与温度无关的CTAT电压。这里简单说明正温度系数电压和负温度系数电压都是怎么获得的。</p><h4 id="负温度系数电压"><a href="#负温度系数电压" class="headerlink" title="负温度系数电压"></a>负温度系数电压</h4><p>负温度系数电压利用的三极管的VBE电压，如下图所示，</p><img src="/2023/05/26/di-ya-dai-xi-ji-zhun/f1bc059b9f4e889314bbe080bd71b9b97d7ba6521517878f03f8f7d0021d8c7e.png" class="" title="picture 1">  <p>这个电压也就是二极管的正向电压，具有负温度系数。下面，具体说明这个电压是如何与温度负相关的。对于一个三极管器件，我们熟悉其特性曲线的表达式，如下所示，</p><p>$$<br>I_C=I_Se^{\frac{V_{BE}}{V_T}}<br>$$</p><p>其中的$V_T=kT/q$为热电压，这时我们可能会说，诶，这个为了保持一定的电流，那么$V_{BE}$应该和温度成正比呀？我第一次看到这个表达式的时候，也会有这样的疑问，但是实际上，我们忽略了$I_S$饱和电流的这一参数的影响，该参数与$\mu kTn_i^2$成正比。这些参数对于读者来说都是魔法参数，需要与我们所关注的温度相挂钩，这里给出这些参数与温度的关系。首先是我们的$\mu$，也就是少数载流子迁移率，与温度的关系如下所示，</p><p>$$<br>\mu\propto\mu_0T^m,m\approx-3/2<br>$$</p><p>接下去是$n_i^2$，$n_i$是硅的本征载流子浓度，这个参数与温度的关系如下所示，</p><p>$$<br>n_i^2\approx T^3e^{-\frac{E_g}{kT}}<br>$$</p><p>其中，$E_g\approx 1.12eV$，为硅的带隙能量。把上述关系写入我们的三极管特征方程中，有如下关系，</p><p>$$<br>I_S=bT^{2.5}e^{-\frac{Eg}{kT}}<br>$$</p><p>由于我们刚才给出的是这些参数与温度的关系，因此，b是一个不包含温度的比例系数。我们需要计算$V_{BE}$与温度的关系，从数学角度来说，也就是希望计算$\frac{\partial V_{BE}}{\partial T}$，所以我们给出$V_{BE}$的表达式，如下所示，</p><p>$$<br>V_{BE}=V_Tln\frac{I_C}{I_S}<br>$$</p><p>接下去我们就是要将上面的表达式的$V_{BE}$对温度$T$求导，利用乘法求导法则，如下所示，</p><p>$$<br>\frac{\partial V_{BE}}{T}=\frac{\partial V_T}{\partial T}ln\frac{I_C}{I_S}+V_T\frac{I_S}{I_C}\cdot(-\frac{I_C}{I_S^2})\frac{\partial I_S}{\partial T}=\frac{\partial V_T}{\partial T}ln\frac{I_C}{I_S}-\frac{V_T}{I_S}\frac{\partial I_S}{\partial T}<br>$$</p><p>上面的式子归根到底需要求两个导数，一个是$\frac{\partial V_T}{\partial T}$，还有一个是$\frac{\partial I_S}{\partial T}$，根据我们前面的分析，$\frac{\partial V_T}{\partial T}$的表达式如下所示，</p><p>$$<br>\frac{\partial V_T}{\partial T}=\frac{k}{q}<br>$$</p><p>$\frac{\partial I_S}{\partial T}$的表达式略微复杂，如下所示，</p><p>$$<br>\frac{\partial I_S}{\partial T}=2.5bT^{1.5}e^{\frac{-E_g}{kT}}-bT^{2.5}\frac{E_g}{kT}e^{\frac{-E_g}{kT}}<br>$$</p><p>整理上面的式子，我们可以得到最终的表达式，如下所示，</p><p>$$<br>\frac{\partial V_{BE}}{\partial T}=\frac{V_{BE}-2.5V_T-Eg/q}{T}<br>$$</p><p>这个值本质上与$V_{BE}$的大小有关，当$V_{BE}\approx800mV$，在室温下，$V_T=\frac{kT}{q}=\frac{1.380649e-23\times 300}{1.602e-19}\approx25.84mV$，$E_g=1.12eV$，将上述表达式的值带到上述等式中，可以得到$V_{BE}$关于温度的一阶导数为，$\frac{\partial V_{BE}}{\partial T}=-1.282mV/K$。</p><p>值得注意的是，上述三项中，中间一项$-2.5V_T/T$是可以忽略的一项，$V_{BE}/T$贡献$2.5mV/K$的正向变化，$-E_g/q/T=-1.12V/300K\approx-4mV/K$贡献了$-4mV/K$的负向变化。所以，如果忽略中间项的话，那么总的导数为$-1.5mV/K$。</p><h4 id="正温度系数电压"><a href="#正温度系数电压" class="headerlink" title="正温度系数电压"></a>正温度系数电压</h4><p>正温度系数由两个$V_{BE}$的差值得到，如果两个晶体管的电流密度不同，那么，他们$V_{BE}$的差值就与绝对温度成正比，如下所示，</p><p>$$<br>\Delta V_{BE}=V_{BE1}-V_{BE2}=V_Tln\frac{nI_0}{I_{S1}}-V_Tln\frac{I_0}{I_{S2}}=V_Tlnn<br>$$</p><p>接下去，为了获得$\Delta V_{BE}$与温度的关联，将$\Delta V_{BE}$对$T$求导，如下所示，</p><p>$$<br>\frac{\partial \Delta V_{BE}}{\partial T}=\frac{k}{q}lnn<br>$$</p><p>先估算一下$\frac{k}{q}$的大小，如下所示，</p><p>$$<br>\frac{k}{q}=87uV/K<br>$$</p><h4 id="获得恒定温度系数的电压和"><a href="#获得恒定温度系数的电压和" class="headerlink" title="获得恒定温度系数的电压和"></a>获得恒定温度系数的电压和</h4><p>通过上面的$V_{BE}$和$\Delta V_{BE}$的结合，适当放大$\Delta V_{BE}$，就可以得到恒定温度系数的量，如下所示，</p><p>$$<br>V_{out}=V_{BE}+\Delta V_{BE}\cdot N<br>$$</p><p>将上述式子对温度求导，如下所示，</p><p>$$<br>\frac{\partial V_{out}}{\partial T}=-1.5mV/K+N\cdot 87uV/K=0<br>$$</p><p>计算得到$N=17.24$</p><h3 id="普通带隙基准电路"><a href="#普通带隙基准电路" class="headerlink" title="普通带隙基准电路"></a>普通带隙基准电路</h3><p>普通的带隙基准电路如下图所示，电路通过运算放大器和顶部的电流镜，强制左右两路的电流完全相同，并且强制X、Y两点的电压一致。</p><img src="/2023/05/26/di-ya-dai-xi-ji-zhun/48450502b8d5aaf06b4ca1ae950ec9230f4d9d0486ef0db406542262ee2d8926.png" class="" title="picture 2">  <p>那么落在电阻$R_1$上的电压就是两个$V_{BE}$的差值，这样Y点的电压就是$\Delta V_{BE}+V_{BE2}$，通常为了保证$V_Y$电压对温度的导数为零，需要将$\Delta V_{BE}$乘以一个倍数$N$，假设这里的晶体管的电流密度的比例为$n=ln15\approx2.7$，为了保证恒定的输出电压系数，我们需要$N=\frac{17.24}{2.7}\approx6.37$，因此，通常的做法是在运放正负输入和电流镜之间，放置一个电阻，通过电阻的方式实现这个倍数。这个输出电压的大小如下所示，</p><p>$$<br>V_{out}=V_{BE}+17V_T\approx1.2<br>$$</p><p>上面的值差不多就是硅的带隙电压，因此，该基准称为带隙基准也正是基于这个原因。但是读者可以发现，该电压是一个比较高的电压，在低于1.2V供电的电路中无法进行实现，因此需要一个低压电路以实现这个电压。</p><h3 id="低压带隙基准"><a href="#低压带隙基准" class="headerlink" title="低压带隙基准"></a>低压带隙基准</h3><p>下面的电路通过产生一个恒定的电流来产生一个恒定的电压，避免了直接产生恒定电压，从而规避了需要高供电电压的问题。</p><img src="/2023/05/26/di-ya-dai-xi-ji-zhun/03cad77b4806eb46044abcc7d17c4d0d5df5a66c1d4d49c00fd7e23d3cc425ad.png" class="" title="picture 3">  <p>上述电路的工作原理是，通过运算放大器保证$V_X=V_Y$，因此，$I_{D2}=\frac{\Delta V_{BE}}{R1}+\frac{V_{BE}}{R_3}$，通过电流镜镜像到$M3$上，从而产生对应的电压$V_{out}$，如下所示，</p><p>$$<br>V_{out}=(\frac{\Delta V_{BE}}{R1}+\frac{V_{BE}}{R_3})R_L<br>$$</p><p>从上述表达式中可以看出，$\Delta V_{BE}$与$V_{BE}$之间的比例通过$R_1$和$R_3$两个电阻进行控制。因此，如果要获得恒定的输出电压，需要下面的式子成立，</p><p>$$<br>\frac{R_3}{R_1}lnn=17.24<br>$$</p><p>上述电路和分析可以使得读者自行制作一个低电压的Bandgap。</p>]]></content>
      
      
      <categories>
          
          <category> cat_1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tag_1 </tag>
            
            <tag> tag_2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TTC方法总结</title>
      <link href="/2023/03/10/ttc-fang-fa-zong-jie/"/>
      <url>/2023/03/10/ttc-fang-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>TTC（Time Transfer Constant）这个方法本人经过验证之后发现，非常有用，受益颇丰。本人先前分析类似电路时，总是遇到无从下手的情形，使用这个方法之后，分析电路非常迅速，可以迅速找到Dominant Pole、以及Zero的位置。并且其中的方法在许多论文中都有应用，在此罗列一下，以便之后参考。</p><p>本文的内容来源：Ali Hajimiri的视频课程：New Analog IC Design.</p><p>链接：<a href="https://www.youtube.com/watch?v=403CnTftB4M&amp;list=PLc7Gz02Znph-c2-ssFpRrzYwbzplXfXUT" target="_blank" rel="noopener">https://www.youtube.com/watch?v=403CnTftB4M&amp;list=PLc7Gz02Znph-c2-ssFpRrzYwbzplXfXUT</a></p><p>或者可以参考Ali Hajimiri的论文：</p><p>A. Hajimiri, “Generalized Time- and Transfer-Constant Circuit Analysis,” in IEEE Transactions on Circuits and Systems I: Regular Papers, vol. 57, no. 6, pp. 1105-1121, June 2010, doi: 10.1109/TCSI.2009.2030092.</p><h2 id="从传输函数到零点极点分析"><a href="#从传输函数到零点极点分析" class="headerlink" title="从传输函数到零点极点分析"></a>从传输函数到零点极点分析</h2><p>一般电路的传输函数如下所示，</p><p>$$<br>H(s)=\frac{a_0+a_1s+a_2s^2+···+a_ms^m}{1+b_1s+b_2s^2+···+b_ns^n}<br>$$</p><p>为了直观看到零点与极点，典型的电路的传输函数也可以写成下面的形式，将零点与极点写在分母上的好处是，$a_0$可以直接是DC增益。</p><p>$$<br>H(s)=a_0\frac{(1-\frac{s}{z_1})(1-\frac{s}{z_2})···(1-\frac{s}{z_m})}{(1-\frac{s}{p_1})(1-\frac{s}{p_2})···(1-\frac{s}{p_n})}<br>$$</p><p>如果极点满足以下条件，那么称$p_1$为Dominant Pole（主极点）。</p><p>$$<br>|p1|&lt;&lt;|p2|&lt;&lt;|p3|&lt;&lt;···<br>$$</p><p>观察第一个传输函数可知，$b_1$满足下面的关系，</p><p>$$<br>b1=-\Sigma_i\frac{1}{p_i}<br>$$</p><p>如果存在条件，$|p1|&lt;&lt;|p2|$，那么可以有下面的结论，</p><p>$$<br>b1\approx-\frac{1}{p_1}<br>$$</p><p>如果还存在条件，$|p2|&lt;&lt;|p3|$，那么可以有下面的结论，</p><p>$$<br>b2\approx\frac{1}{p_1p_2}<br>$$</p><p>总结一下就是，如果传输函数存在一个主极点（通常来说，设计好的电路都是这样的），那么我们的分母一次项的系数就是我们的主极点的倒数，同理，第二个主极点的位置就是主极点和非主极点的乘积的倒数。</p><h3 id="ZVT，Zero-Value-Time-Constant方法"><a href="#ZVT，Zero-Value-Time-Constant方法" class="headerlink" title="ZVT，Zero Value Time Constant方法"></a>ZVT，Zero Value Time Constant方法</h3><p>这个方法在Paul Gray的书中有做介绍，但是书中的内容总是不够直观，看起来也比较枯燥。本文接下去的内容对这个方法进行了详细的描述。</p><p>我们先考虑只有一个Reactive Element的情况，也就是下面的两种情形，左图表示了只有电容的情形，右图表示了只有电感的情形。其中的大圈表示”No Dynamics”的电路部分，也就是说，其中没有电感和电容的部分。</p><img src="/2023/03/10/ttc-fang-fa-zong-jie/bd5c9cbc5c782145da26e7110093d225a2433131c8bcb95703dc6679ce5fd670.png" class="" title="picture 1"><p>上面的电路只有一个Reactive Element，所以一定可以用下面的表达式进行表达，</p><p>$$<br>H(s)=\frac{a_0+a_1s}{1+b_1s}<br>$$</p><p>这里要介绍一个有限零点(Finite Zero)和无限零点(Infinite Zero)的概念，有限零点表示零点是一个有限的实频率，而无限零点表示零点为无穷大频率。直观来说，有限零点对应的情况为：$a_0\neq0$，$a_1\neq0$；而无限零点对应的情况是：$a_1=0$。这种无限零点的说法，在Ahuja的文章：</p><p>B. K. Ahuja, “An improved frequency compensation technique for CMOS operational amplifiers,” in IEEE Journal of Solid-State Circuits, vol. 18, no. 6, pp. 629-633, Dec. 1983, doi: 10.1109/JSSC.1983.1052012.</p><p>一文中，有无限零点、有限零点的这种说法存在，我怀疑Ahuja也是使用了这种方法进行电路零点极点分析的。</p><p>上面的表达式可以进一步写成如下的表达式，可以写成下面表达式的原因是因为我们的$s$永远是和$C_1$一起出现的，所以我们可以把包含$s$的项提出一个$C_1$出来。</p><p>$$<br>H(s)=\frac{a_0+\alpha_1^1C_1s}{1+\beta_1^1C_1s}<br>$$</p><p>$b_1$是我们的时间常数，$\tau=C_1R_1^0$。这里要说明一下我们的命名方式，这里除了下标，还会有上标，上标表示值为无穷的器件，也就是频率为无穷大时，器件的阻抗，这时，电容为短路，电感为开路，另外，如果上标为零，那么表示所有器件均为零值，也就是频率为零，DC时的情况，这时，电容为开路，电感为短路。根据这个描述，我\们可以把上面的表达式写成如下形式，</p><p>$$<br>H(s)=\frac{H^0+H^1R_1^0C_1s}{1+R_1^0C_1s}=\frac{H^0+H^1\tau s}{1+\tau s}<br>$$</p><h3 id="几个例子"><a href="#几个例子" class="headerlink" title="几个例子"></a>几个例子</h3><h4 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h4><img src="/2023/03/10/ttc-fang-fa-zong-jie/314dd384f61fd6f5909f97e76ca130299a910ccdaf277735ea0450b2f6a2746f.png" class="" title="picture 2">  <p>先计算$H^0$，也就是所有Reactive Elements的值为零的传输函数，换句话说，也就是所有电容开路，所有电感短路时的电路的传输函数。这时，输入直接传递到输出，没有衰减和增益，所以，</p><p>$$<br>H^0=1<br>$$</p><p>再计算传输函数$\tau_1^0$，计算这时的传输函数，要将除了$C_1$之外的电容全部开路，将所有独立电压源短路，所有独立电流源开路，求从$C_1$两侧看入的阻抗$R_1^0$的大小。从$C_1$只能看到$R$，所以，</p><p>$$<br>\tau_1^0=R_1^0C_1=RC_1<br>$$</p><p>再计算$H^1$的值，$H^1$是将$C_1$的值为无穷大，其他Reactive Element的值为0时，电路的传输函数，也就是将$C_1$短路时，电路的传输函数，这时，输出被短路，所以有，</p><p>$$<br>H^1=0<br>$$</p><p>综上所述，我们利用一开始的ZVT公式，可以得到如下的电路传输函数，</p><p>$$<br>H(s)=\frac{1}{1+RC_1s}<br>$$</p><p>到这里我们就推导了一阶RC低通滤波器的传输函数。</p><h4 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h4><p>接下去我们看第二个例子</p><img src="/2023/03/10/ttc-fang-fa-zong-jie/f7cbc444b7c9b91fb40fcdd6aeb1297afb07ef6278e8768e2822d5f0d130d3a9.png" class="" title="picture 3">  <p>我们可以先计算一下该电路的DC增益：</p><p>$$<br>H^0=\frac{R_b}{R_a+R_b}<br>$$</p><p>接下去我们去计算我们的时间常数$\tau_1$，计算该时间常数的办法是，</p><ol><li>将所有的源归零；</li><li>将其他的电抗器件的值变为零；</li><li>计算$C_1$两侧看入的电阻$R$，并与$C_1$相乘得到时间常数$RC_1$</li></ol><p>$$<br>\tau_1=(R_a||R_b)C_1<br>$$</p><p>接下去我们计算$H^1$，计算$H^1$的办法就是将$C_1$的值变为无穷大，其他的电抗器件的值变为0，然后测算从输入到输出的增益。</p><p>这里，我们将$C_1$短路，获得的$H_1$如下所示，</p><p>$$<br>H_1=1<br>$$</p><p>所以，根据先前的公式，有，</p><p>$$<br>H_(s)=\frac{H^0+H^1\tau_1s}{1+\tau_1s}=\frac{\frac{R_b}{R_a+R_b}+(R_a||R_b)C_1s}{1+(R_a||R_b)C_1s}<br>$$</p><p>从上述表达式中，我们可以发现增益从低频的$\frac{R_b}{R_a+R_b}$移动到高频的$1$，也就是从$H^0$变为$H^1$。</p><h4 id="例子三"><a href="#例子三" class="headerlink" title="例子三"></a>例子三</h4><img src="/2023/03/10/ttc-fang-fa-zong-jie/219af40a7422879883437e41477e9409923ad86289deb063404dccbd271d55f8.png" class="" title="picture 4">  <p>该例子中出现了电感器件，为了说明电感器件如何应用该理论，这里特别放置了这样的一个例子。首先说明，该电路为一阶RL高通滤波器。</p><p>我们先计算DC增益$H^0$，也就是所有的器件的值全部为零的情形，在该情形下，电感为短路，$sL=s\cdot 0=0$，电容为开路，$\frac{1}{sC}=\frac{1}{s\cdot 0}=\infty$。在这里，电感为短路，所以输出为零，即，$H^0=0$。接下去计算时间常数$\tau_1$，计算电感的时间常数和电容不同，电感的时间常数为$\frac{L}{R}$，所以有，</p><p>$$<br>\tau_1=\frac{L_1}{R}<br>$$</p><p>接下去我们继续计算$H^1$，即$L_1$器件的值为$\infty$时，电路的增益，这时电感为开路，输出增益为1，所以，</p><p>$$<br>H^1=1<br>$$</p><p>将上述表达式代入TTC公式中，可以得到如下的表达式，</p><p>$$<br>H(s)=\frac{\frac{L_1}{R}s}{1+\frac{L_1}{R}s}<br>$$</p><p>可以看到的是，该电路的传输函数是一个高通滤波器。</p><h4 id="例子四"><a href="#例子四" class="headerlink" title="例子四"></a>例子四</h4><p>在案例四中，我们加入了受控源结构，即MOS管，使得问题与实际问题更加贴切，让我们来看看在MOS管中如何利用TTC理论。</p><img src="/2023/03/10/ttc-fang-fa-zong-jie/9cf3803268831d8b1e5c282a8aff513e05191ba8074157b3210aea59a0448f70.png" class="" title="picture 5">  <p>上图中的MOS管电路是一个共源放大器，我们可以先计算一下DC增益$H^0$，该增益由下式描述，</p><p>$$<br>H^0=-g_mR_2<br>$$</p><p>再来计算由$C_\pi$贡献的时间常数$\tau_\pi^0$，</p><p>$$<br>\tau_\pi^0=R_1C_\pi<br>$$</p><p>当我们想要计算$H_\pi$时，会发现当$C_\pi$短路时，该电路的增益为零，因为输入被短接到地了，所以有，</p><p>$$<br>H^\pi=0<br>$$</p><p>综上所述，我们可以得到总体的传输函数表达式，</p><p>$$<br>H(s)=\frac{-g_mR_2}{1+R_1C_\pi s}<br>$$</p><p>从这个例子中我们可以得到结论，如果短路电容或者开路电感，输出有且不为零，那么就存在一个零点；如果前后传输函数的极性被翻转了，那么就存在一个右半平面的零点，反之，如果传输函数的极性没有被翻转，那么就存在一个左半平面的零点。</p><h3 id="一阶TTC在MOS管中的应用"><a href="#一阶TTC在MOS管中的应用" class="headerlink" title="一阶TTC在MOS管中的应用"></a>一阶TTC在MOS管中的应用</h3><img src="/2023/03/10/ttc-fang-fa-zong-jie/defc605b3d12ad27149d7037afa168a69b86904251dabbd96f62bf512808c400.png" class="" title="picture 6">  <p>上述电路结构是一个典型的MOS管的寄生结构，该结构是一个通用的寄生模型，该模型在计算时间常数时，如果采用通常的小信号方法进行硬解，比较复杂麻烦，这里，给出了几个结论，并且给出了这几个结论的推导过程。</p><h4 id="R-mu-的计算方法"><a href="#R-mu-的计算方法" class="headerlink" title="$R\mu$的计算方法"></a>$R\mu$的计算方法</h4><p>先给出结论，</p><p>$$<br>\tau_\mu^0=R_\mu C_\mu=(R_{left}+R_{right}+G_mR_{left}R_{right})C_\mu<br>$$</p><p>这里的$G_m$为等效跨导，该由于MOS管的源通常会接电阻，所以MOS管的跨导会发生退化，也就是源退化电阻导致的MOS管的跨导的减小。</p><p>下面对上面的结论进行推导，我们先给出了如下的电路图，</p><img src="/2023/03/10/ttc-fang-fa-zong-jie/bf95b43810b1fba7ed2ebfe90f0281a3e7285c517d73719690b573776da82647.png" class="" title="picture 7">  <p>我们要测量$C_\mu$两端看去的阻抗，可以将$C_\mu$替换为电流源，电流为$i_x$，如上图所示，这样，这个电流会在栅上产生一个恒定的电压$v_g=i_xR_1$。</p><p>我们令流过管子的电流为$i_d$，这样，源上的电压为$v_s=i_dR_2$，我们接下去可以利用管子的跨导将栅源电压差和漏电流的关系表示出来，如下所示，</p><p>$$<br>(i_xR_1-i_dR_2)g_m=i_d<br>$$</p><p>化简之后，可以获得$i_d$与$i_x$之间的关系，如下所示，</p><p>$$<br>i_d=\frac{i_xg_mR_1}{1+g_mR_2}<br>$$</p><p>我们可以先观察一下上面的表达式，很明显有一个负反馈的意思在其中，这里的环路增益是$g_mR_2$。环路也比较明晰，栅电压升高$v_g$，产生更大的漏电流$v_gg_m$，进一步在源上产生电压$v_gg_mR_2$，通过$v_{gs}$反馈到输入上，具体的反馈图如下图所示，</p><img src="/2023/03/10/ttc-fang-fa-zong-jie/13f414b8a349f1570c867addf80611496aa23fc82f340f21b7d73f2ea65c365d.png" class="" title="picture 8">  <p>我们可以利用这个电流关系进一步计算$v_d$的表达式，如下所示，</p><p>$$<br>v_d=-idR_3-ixR_3=-\frac{i_xg_mR_1R_3}{1+g_mR_2}-ixR_3<br>$$</p><p>进一步我们可以得到最终的$v_x$电压，该电压的大小由下式表达，</p><p>$$<br>v_x=v_g-v_d=i_xR_1+\frac{i_xg_mR_3R_1}{1+g_mR_2}+i_xR_3=i_x(R_1+R_3+G_mR_1R_3)<br>$$</p><p>其中真正的跨导被源退化电阻缩小$g_mR_2$倍，所以为等效跨导。至此我们推导了$R_\mu$的大小。</p><h4 id="R-pi-的计算方法"><a href="#R-pi-的计算方法" class="headerlink" title="$R\pi$的计算方法"></a>$R\pi$的计算方法</h4><p>先给出结论，$R_\pi$的计算方法如下，</p><p>$$<br>R_\pi=\frac{R_1+R_2}{1+g_mR_2}<br>$$</p><p>下面我们对该阻抗的计算方法进行一个推导，本质上就是计算如下图所示的端口看入的阻抗。</p><img src="/2023/03/10/ttc-fang-fa-zong-jie/ab667c29a72f52b8b0158d3e67b93453fdcee55af44e3bba5faf4daa62878176.png" class="" title="picture 9">  <p>我们先解出$i_d$和$i_x$的关系，如下所示，</p><p>$$<br>(i_xR_1-i_dR_2+i_xR_2)g_m=i_d<br>$$</p><p>简单化简一下，我们可以得到下面的关系，</p><p>$$<br>i_d=\frac{g_m(R_1+R_2)}{1+g_mR_2}i_x<br>$$</p><p>接下去我们就可以解出$v_x$的大小，$v_x=v_{gs}$，如下，</p><p>$$<br>v_x=i_x(R_1+R_2)-\frac{g_m(R_1R_2+R_2^2)}{1+g_mR_2}<br>$$</p><p>化简有如下表达式，</p><p>$$<br>v_x=\frac{R_1+R_2}{1+g_mR_2}<br>$$</p><h4 id="R-B-的计算办法"><a href="#R-B-的计算办法" class="headerlink" title="$R_B$的计算办法"></a>$R_B$的计算办法</h4><p>$R_B$的计算方法与结果与$R_\pi$基本一致，表达式如下所示，这里就不做推导了。</p><p>$$<br>R_B=\frac{R_2+R_3}{1+g_mR_2}<br>$$</p><h4 id="MOS管从源看入的阻抗表达式中的零点问题"><a href="#MOS管从源看入的阻抗表达式中的零点问题" class="headerlink" title="MOS管从源看入的阻抗表达式中的零点问题"></a>MOS管从源看入的阻抗表达式中的零点问题</h4><p>如下图所示，我们可以看到一个典型的MOS管配置在源跟随器状态下的电路图，这时，MOS管存在寄生电容$C_\pi$，会产生一个阻抗的零点，下面对这个零点的来源进行一个推导。</p><img src="/2023/03/10/ttc-fang-fa-zong-jie/330baf3e0cfe9b679734b08b8288c444299cef28a948393ba58671c0c5b958ee.png" class="" title="picture 10">  <p>我们要计算输出阻抗，所以激励一定是电流，我们在源上施加一个流入的电流$i_x$。</p><p>我们先计算DC阻抗$Z^0$，这时，所有的电容的值均为零，也就是电容的阻抗为无穷大，即所有电容开路，这时的DC阻抗就是$1/g_m$，即，</p><p>$$<br>Z^0=1/g_m<br>$$</p><p>我们再去计算$Z^\pi$，即当$C_\pi$的值为无穷大时，这时看入的阻抗。这时，由于MOS管的栅和源之间被短路了，所以MOS管的源不能流入和流出电流，电流只可以流向$R_1$，所以，最终看入的阻抗为$R_1$，即，</p><p>$$<br>Z^\pi=R_1<br>$$</p><p>接下去我们需要计算时间常数$\tau_\pi^0$，计算这个时间常数主要是需要计算从$C_\pi$两侧看入的阻抗$R_\pi^0$，该阻抗在$R_1$以及$R_2$均为有限值时，由下式表达，</p><p>$$<br>R_\pi^0=\frac{R_1+R_2}{1+g_mR_2}<br>$$</p><p>但在本电路中，由于MOS管的源是开路的，所以，$R_2\rightarrow\infty$，所以，</p><p>$$<br>R_\pi^0=\frac{1}{g_m}<br>$$</p><p>根据上面的信息，我们已经可以写出s域下的阻抗表达式了，如下所示，</p><p>$$<br>Z(s)=\frac{Z^0+Z^\pi\tau_\pi^0s}{1+\tau_\pi^0s}=\frac{1/g_m+R_1C_\pi1/g_ms}{1+C_\pi1/g_ms}=\frac{1+R_1C_\pi s}{g_m+C_\pi s}<br>$$</p><p>从上面的阻抗表达式中，我们可以发现阻抗在低频的位置处，为$1/g_m$，到了高频处，为$R_1$。在一些对高频输出阻抗敏感的应用中，我们需要对电路的栅电阻尤为注意，要在此处加足够的Decap，否则，将会出现输出阻抗peaking的问题。</p><h4 id="米勒电容问题"><a href="#米勒电容问题" class="headerlink" title="米勒电容问题"></a>米勒电容问题</h4><p>如下图所示，是一个米勒电容的模型，该电容跨接在电容的源和漏之间，形成了一个极点加上一个右半平面的零点。下面利用TTC推导上述结论，并且对零点和极点位置进行定量分析。</p><img src="/2023/03/10/ttc-fang-fa-zong-jie/97862a5c8467ea6548bd65da855aa55244ff23879ae907692c816c274b89b755.png" class="" title="picture 11">  <p>首先，先分析DC增益，DC增益为电容开路时，电路的增益，那么就是一个共源放大器的增益，如下所示，</p><p>$$<br>H^0=-g_mR_2<br>$$</p><p>接下去我们计算$H^\mu$，也就是当$C_\mu$的值为无穷大时，电路的增益，也就是当$C_\mu$短路时，电路的增益。当电容短路时，电路表现为输出经过$R_1$后，再与$R_2||1/g_m$串联分压，因此，增益表现为如下表达式，</p><p>$$<br>H^1=\frac{1/g_m||R_2}{R_1+1/g_m||R_2}=\frac{R_2}{R_1+R_2+g_mR_1R_2}=\frac{R_2}{R_\mu^0}<br>$$</p><p>注意上式中的$R_\mu^0$为$C_\mu$两端看到的阻抗。</p><p>所以电路的传输函数可以表示为如下所示，</p><p>$$<br>H(s)=\frac{H^0+H^1C_\mu R_\mu^0s}{1+C_\mu R_\mu^0s}=\frac{-g_mR_2+R_2C_\mu s}{1+R_\mu C_\mu s}=-g_mR_2\frac{1-C_\mu/g_m s}{1+R_\mu C_\mu s}<br>$$</p><p>从上面的表达式中，可以看到该电路中的极点为$-\frac{1}{R_\mu C_\mu^0}$，电路的零点为$\frac{g_m}{C_\mu}$。值得注意的是，这里的零点为右半平面零点，右半平面一方面会让增益以$+20dB/dec$的速度滚升，另一方面还会将相位降低$90\degree$。直观来说，对相位裕度有十分恶劣的影响，因为我们希望增益在到达$-180\degree$前滚降到0dB。我们来大概估计一下这个零点的位置，假设MOS管本身的寄生为$C_\mu$，那么最终的零点位置其实是比$f_T$要远的，这就意味着，一般情形下，零点位于GBW外。因此，在不额外增加电容的前提下，我们不需要关注这个零点对电路造成的影响。</p><h3 id="零点的位置估计"><a href="#零点的位置估计" class="headerlink" title="零点的位置估计"></a>零点的位置估计</h3><p>从上面的内容中，我们不难发现，零点的计算方法如下，</p><p>$$<br>Z=\frac{H^0}{H^1}P<br>$$</p><p>仔细观察一下上面的式子，读者就会发现，零点实际上是极点位置经过修正后的结果。所以，只要知道修正系数的大小，我们就可以马上推算出零点的位置了。</p><p>下面我们给出一个相关的表格，来分析一下各种情况：</p><table><thead><tr><th>0</th><th>$\frac{H^0}{H^1}&lt;1$</th><th>$\frac{H^0}{H^1}&gt;1$</th></tr></thead><tbody><tr><td>$\frac{H^0}{H^1}&gt;0$</td><td>零点极点位于同一平面<br> $|Z|&lt;|P|$</td><td>零点极点位于同一平面<br> $|Z|&gt;|P|$</td></tr><tr><td>$\frac{H^0}{H^1}&lt;0$</td><td>零点极点位于不同平面<br> $|Z|&lt;|P|$</td><td>零点极点位于不同平面<br> $|Z|&lt;|P|$</td></tr></tbody></table><p> 下图总结了上面不同的零点和极点关系对应的不同的频率响应。</p> <img src="/2023/03/10/ttc-fang-fa-zong-jie/dc9777201460f0a04442fae26933e53205c38387bd0d58c967be2350ca3c41f1.png" class="" title="picture 12">  <p>对于上面的一个极点一个零点的系统，我们可以对其进行分解，得到对应的时域响应表达式，如下所示，</p><p>$$<br>H(s)=\frac{H^0+H^1\tau s}{1+\tau s}=H^0\frac{1}{1+\tau s}+H^1\frac{\tau s}{1+\tau s}<br>$$</p><p>上式对应的时域表达式如下所示，</p><p>$$<br>h(t)=H^0(1-e^{-t/\tau})u(t)+H^1e^{-t/\tau}u(t)<br>$$</p><p>上述表达式的时域波形可以分解为如下图所示的图像，</p><img src="/2023/03/10/ttc-fang-fa-zong-jie/3b9d5df897826574cd0f8756097c7f3b33fdde3bdb404b2eccf85299b9917904.png" class="" title="picture 14">  <p>可以看到的是，左半平面零点对应的时域响应是上述两个相应的和，将这两个响应相加，会发现如果$H^1$比较大，那么相应会有过冲的现象，如下图所示，</p><img src="/2023/03/10/ttc-fang-fa-zong-jie/3cef3ee231f93668778fdfabc71567aeb0ac88a699547f8c2ea6ae7de1da94bd.png" class="" title="picture 15">  <p>因此，需要注意的是，当读者看到阶跃响应出现过冲时，不仅仅会在二阶系统中出现，也有可能在一阶系统中出现。</p><p>另一方面，如果电路中存在右半平面零点，那么该电路会有undershoot现象，如下所示，</p><img src="/2023/03/10/ttc-fang-fa-zong-jie/0bd940d8eb67783409b54cda23ba345c30120fc9b63b08d9217dfaaf5d861182.png" class="" title="picture 16">  ]]></content>
      
      
      <categories>
          
          <category> 模拟IC设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟IC设计 </tag>
            
            <tag> 零点极点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cadence版图小技巧</title>
      <link href="/2023/02/27/cadence-ban-tu-xiao-ji-qiao/"/>
      <url>/2023/02/27/cadence-ban-tu-xiao-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>版图是一个非常吃经验的工作，如果一段时间不画版图，那么这个人的版图能力也会退化，并且由于先前绘制版图时那些不太好的回忆，会导致这个人对版图产生惧怕心理，不敢再涉足版图的工作，这里我就将我的一些经验的东西写在这里，供以后的我参考。</p><h2 id="版图设计的小技巧"><a href="#版图设计的小技巧" class="headerlink" title="版图设计的小技巧"></a>版图设计的小技巧</h2><h3 id="自动去除线头"><a href="#自动去除线头" class="headerlink" title="自动去除线头"></a>自动去除线头</h3><p>这个功能我以前曾经再eetop上看到过，有人用skill脚本实现过，skill脚本通常来说会有一定的bug。但是我最近在画图的过程中，发现不用skill脚本也可以实现这一功能的办法，这里记录下来，以备之后绘制版图的过程中予以参考。</p><p>具体方法：</p><ul><li>先使用<code>s</code>快捷键进入拉伸模式</li><li>再使用<code>鼠标左键</code>进行批量选择</li><li>最后使用<code>鼠标左键</code>进行拉伸即可去除线头。</li></ul><h3 id="仅选中Selectability中生效的层的Via"><a href="#仅选中Selectability中生效的层的Via" class="headerlink" title="仅选中Selectability中生效的层的Via"></a>仅选中Selectability中生效的层的Via</h3><p>这里问题主要存在Cadence中的一个可选项不可视的问题，这个问题我搜索了一下，最后找到了一篇对应的Cadence的帖子，链接如下，</p><p><a href="https://community.cadence.com/cadence_technology_forums/f/custom-ic-design/36593/selection-of-non-visible-object" target="_blank" rel="noopener">https://community.cadence.com/cadence_technology_forums/f/custom-ic-design/36593/selection-of-non-visible-object</a></p><p>其中，作者将问题描述为如下所示，</p><img src="/2023/02/27/cadence-ban-tu-xiao-ji-qiao/ca8d763c051e25a0d5b3daea7856d262f55a13ba8717c11753975d9b4eec1e6a.png" class="" title="Selection of non-visible object">  <p>最终支持人员给出的解决方案如下，</p><img src="/2023/02/27/cadence-ban-tu-xiao-ji-qiao/d4d89a8de96ac916af21aa44f46b2d38043dfb3ea9aff2e0c7805aea49e49a58.png" class="" title="picture 2">  <p>简单来说，如果要实现我们想要的那个不选择看不见或者没选中的器件，需要使用下面的语句，</p><pre><code>envSetVal("layout" "viaSelectionMode" 'cyclic "useCutLayers")</code></pre><p>经过我实验过后，发现是可行的，只不过退出Cadence环境后，都需要重新进行输入操作，这样有些麻烦，应该可以在cadence中进行预先设置。本人修改了位于home下的文件<code>.cdsenv</code>，在其中加入了如下的条目</p><pre><code>layout  viaSelectionMode    cyclic  useCutLayers</code></pre><p>这样一来每次打开virtuoso的时候，就会自动将该环境变量进行赋值，就不需要每次都进行更改了。</p><h3 id="自动添加pin与label"><a href="#自动添加pin与label" class="headerlink" title="自动添加pin与label"></a>自动添加pin与label</h3><p>每次手动添加label与pin非常费力费时，这时可以考虑将这一部分操作进行自动化。</p><p>具体方法：</p><ul><li>点选<code>Create</code>栏目；</li><li>点击<code>Pin</code>；</li><li>选择<code>Auto</code>；</li><li>在<code>Pin Layer/Purpose</code>一栏中，选择<code>Use same layer as shape, select purpose</code>中的复选框，将Purpose设置为<code>pin</code>；</li><li>选择Create Label，将复选框选为<code>auto</code>；</li><li>点选<code>Option</code>进行Label属性的设置；</li><li>设置Height &amp; Font为你想要的大小；</li><li>在<code>Text Options</code>栏目中，选择<code>Create As Label</code>；</li><li>在<code>Layer Name</code>栏目中，选择<code>Same As Pin</code>;</li><li>在<code>Layer Purpose</code>栏目中，选择<code>Same As Pin</code></li></ul><p>设置完以上之后，每次点击<code>Create</code>-&gt;<code>Pin</code>之后，再点击想要设置的线网形状即可，非常方便。</p><h3 id="自动打过孔Via"><a href="#自动打过孔Via" class="headerlink" title="自动打过孔Via"></a>自动打过孔Via</h3><p>这个功能在铺设地网和Power网的时候非常好用，基本上就是直接使用即可，一般来说我们在设计过程中一定会需要打过孔的情况，这时如果采用手动打过孔的方式，那么就会非常复杂和麻烦，这时候可以采用借助工具的方法。在这里不禁感叹一句，”懒惰就是发明工具的第一源动力”。Anyway，我在这里采用<code>o</code>快捷键进行过孔的添加。</p><p>具体方法：</p><ul><li>点击快捷键<code>o</code>后，点击<code>Auto</code>，进入过孔自动编辑页面；</li><li>在<code>Cut Class</code>中，设置你想要的过孔形状，在Options中最好也设置成对应的；</li><li>点选<code>Prevent DRC Violations With Neighbors</code>;</li><li>点选<code>Prevent Via Larger Than Overlap</code>；</li><li>在你确定线网名称后，可以使用<code>Connect Shapes On The Same Net</code>选项，并输入你的网表名称，这样可以只打一种过孔。在铺设地网和Power网的时候非常好用，并且在后期打过孔时也非常好用。</li></ul><p>以上过孔方法可以配合自动去线头的方法一起使用，效果极佳。</p><h3 id="检查Marker报错的原因"><a href="#检查Marker报错的原因" class="headerlink" title="检查Marker报错的原因"></a>检查Marker报错的原因</h3><p>有的时候，Marker会报错，这是由于ADEXL内部自动带的检查规则导致的，这时，你可能不知道怎么去看Marker报错的原因。你可以使用如下方法检查Marker报错的原因。</p><p>具体方法：</p><ul><li><code>Verify</code> -&gt; <code>Marker</code> -&gt; <code>Explain</code></li></ul><p>即可查看Marker报错的原因了，非常简单方便。</p><h3 id="仅仅选择指定类型的对象"><a href="#仅仅选择指定类型的对象" class="headerlink" title="仅仅选择指定类型的对象"></a>仅仅选择指定类型的对象</h3><p>在Cadence中进行选择的时候，我们常常会发现选中的内容中包含了<code>instances</code>，往往这是我们不希望使用的，可以在<code>Pallete</code>中的<code>Objects</code>窗口中选择<code>Objects</code>。其中有不同对象的<code>Visibility</code>以及<code>Selectability</code>，读者可以通过这些设置进行选择对象的Filtering，如下所示</p><img src="/2023/02/27/cadence-ban-tu-xiao-ji-qiao/69d4f2fe62d79c70c7a67970ab70de7b780294b3abbb2ac52d1962e39a92e9f5.jpeg" class="" title="picture 3"><h3 id="绘制地网-amp-Power网"><a href="#绘制地网-amp-Power网" class="headerlink" title="绘制地网&amp;Power网"></a>绘制地网&amp;Power网</h3><p>一块一块绘制的方法肯定是不可行的，非常浪费时间，我们这里采用<code>Create</code> -&gt; <code>Wiring</code> -&gt; <code>Stranded Wire</code>的方法，便可以快速绘图了。</p><img src="/2023/02/27/cadence-ban-tu-xiao-ji-qiao/31d2da4f0e8b61fafcc8752db3eec62c9d50b118b6a21b2a2d79cdcdf51a027a.jpeg" class="" title="Stranded Wire绘制方法"><p>以下表格给出了具体的线宽和线间距设置，按照此规定设置可以保证最终结果满足要求，并且在打过孔的时候不会出现问题。</p><table><thead><tr><th>Layer Name</th><th>线宽</th><th>线间距</th></tr></thead><tbody><tr><td>M9</td><td>0.468</td><td>1.188</td></tr><tr><td>M10</td><td>1.8</td><td>3.6</td></tr></tbody></table><h3 id="拉伸到指定位置"><a href="#拉伸到指定位置" class="headerlink" title="拉伸到指定位置"></a>拉伸到指定位置</h3><p>我们在做拉伸的时候，经常会发现拉伸到指定位置比较困难，因为你要去对准某一个特定的位置，这时候需要放大仔细对准，这是非常不方便的。我们可以使用标尺先测量距离，再进行精确拉伸即可达到目的。</p><p>具体方法：</p><ul><li>使用<code>s</code>进入拉伸操作；</li><li>使用<code>k</code>进行距离测量；</li><li>使用<code>TAB</code>切换到dx或dy输入框；</li><li>输入测量得到的距离，按回车之后即可；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 版图设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版图小技巧 </tag>
            
            <tag> Cadence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LVS错误总结</title>
      <link href="/2023/02/27/lvs-cuo-wu-zong-jie/"/>
      <url>/2023/02/27/lvs-cuo-wu-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>通常来说，Calibre的LVS错误会比较难排查，基本原因是因为Calibre的错误提示做得太差，这里点名批评Siemens公司。一般我们会采用Connectivity以及CAS工具辅助我们排查错误，但是这些工具可能会误报错误或者说检查不出Front End的错误，这是我们需要注意的。综上所述，没有一个很好的工具帮助我们发现错误，所以，我们需要通过大量的时间检查出错误，发现错误，并且总结这些报错的原因。这就是我写这篇博客的意义，帮助我在LVS错误上不要掉进一个坑两次。</p><h2 id="错误总结板块"><a href="#错误总结板块" class="headerlink" title="错误总结板块"></a>错误总结板块</h2><p>在这个版块会罗列出错误的名称和解决方案，方便之后排查。</p><h3 id="Incorrect-Instances"><a href="#Incorrect-Instances" class="headerlink" title="Incorrect Instances"></a>Incorrect Instances</h3><h4 id="Discrepancy"><a href="#Discrepancy" class="headerlink" title="Discrepancy"></a>Discrepancy</h4><h5 id="SOURCE-NAME-missing-instance"><a href="#SOURCE-NAME-missing-instance" class="headerlink" title="SOURCE NAME ** missing instance **"></a>SOURCE NAME ** missing instance **</h5><img src="/2023/02/27/lvs-cuo-wu-zong-jie/fc7a8650beaefe9a0854259bcf066f5db509506b42de05f7f352b89ef1c52397.jpeg" class="" title="picture 1">  <p>出现这个错误一般是版图中有MOS与原理图对应不上，或者是多出了器件，常见于用户自行绘制PO形状之后，LVS将该形状识别成了器件；或者说用户将MOS管的源和漏短路了，（P.S. 这种错误其实可以使用Connectivity工具马上定位出来）。</p><p>需要注意的是，一般LVS可能不会将器件识别准确，所以你点开提示的器件不一定就是你绘制错误的器件，这里的case就是这样，我在其他地方绘制了多余的PO形状之后，Calibre没有识别到我的那个多余的器件，反而找了一个随机的正确的器件。</p><h5 id="LAYOUT-NAME-bad-component-subtype"><a href="#LAYOUT-NAME-bad-component-subtype" class="headerlink" title="LAYOUT NAME bad component subtype"></a>LAYOUT NAME bad component subtype</h5><p>出现这个错误一般是NMOS出现，我还没有看到过PMOS出现过这个错误，一般来说是电路里面缺少<code>LVS Dummy layer</code>导致的，这个层次一般来说是一个绿色虚线的层次，如下所示，</p><img src="/2023/02/27/lvs-cuo-wu-zong-jie/15452d585ac6d945cbe2bb181f5785af535819330d1c062721c61aa82f5aae90.jpeg" class="" title="picture 2">  <p>一般需要将这个层次打开即可。</p>]]></content>
      
      
      <categories>
          
          <category> 版图设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LVS </tag>
            
            <tag> 错误总结分类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>做FFT时的频谱零值插值问题</title>
      <link href="/2023/02/20/zuo-fft-shi-de-pin-pu-ling-zhi-cha-zhi-wen-ti/"/>
      <url>/2023/02/20/zuo-fft-shi-de-pin-pu-ling-zhi-cha-zhi-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这个问题我在2023年初的寒假第一次遇到，这个时候闫老师给出的解释如下图所示，</p><img src="/2023/02/20/zuo-fft-shi-de-pin-pu-ling-zhi-cha-zhi-wen-ti/c51add6478ae12667ba35fd92e313e93789b754d3ff48a7df52250b9427042f9.png" class="" title="picture 1">  <p>这时我勉强明白是怎么回事，但是没有完全搞懂，现在我通过MATLAB建模的方式，彻底搞清楚了这个的原因。做这件事的动机在于一个学妹的MATLAB代码，其中有量化的片段，这个量化的片段执行完成之后，将量化后的数字码进行FFT分析，却在图中获得不到最终的频谱图，这个现象非常诡异，是我从来没有遇到过的。仔细查看其中的结果发现，频谱中的结果如下图所示，出现了zero interlacing的情况。</p><img src="/2023/02/20/zuo-fft-shi-de-pin-pu-ling-zhi-cha-zhi-wen-ti/4376358049cfb57dcfbc7699c77855335f5077e8e58072cd3a1d126566da6d94.png" class="" title="picture 2">  <p>我称这种情况为Spectrum Zero Interpolation。</p><h2 id="Spectrum-Zero-Interpolation会发生什么？"><a href="#Spectrum-Zero-Interpolation会发生什么？" class="headerlink" title="Spectrum Zero Interpolation会发生什么？"></a>Spectrum Zero Interpolation会发生什么？</h2><p>我起初上网搜索的时候，发现大部分的人在频谱中加0的方式都是所谓的zero padding，这种zero padding本质上就是在频谱的最后插零。</p><h3 id="Zero-Padding"><a href="#Zero-Padding" class="headerlink" title="Zero Padding"></a>Zero Padding</h3><p>为了验证频域中进行zero padding对时域信号有什么影响，我们采用下面方法进行验证。第一步先产生如下的时域信号，</p><img src="/2023/02/20/zuo-fft-shi-de-pin-pu-ling-zhi-cha-zhi-wen-ti/8d20b57355ed7b64b7fa65e6bcfc83582e4c8720eac748699a79e5c2f38f3f93.png" class="" title="初始频谱">  <p>这个时域信号产生的代码如下所示，</p><pre class=" language-MATLAB"><code class="language-MATLAB">Signal = cos(2*pi*fin*t);Signal_quantized = floor(Signal.*2^(bit));</code></pre><p>可以看到，这个信号是量化过后的信号。第二步我们将这个信号做fft之后获取到了复数频谱数列，再对该序列的尾部进行zero padding（尾部插零），代码如下所示，</p><pre class=" language-MATLAB"><code class="language-MATLAB">Spectrum = fft(Signal_quantized);Spectrum_interpolated = zeros(1,N*10);for i = 1:N    Spectrum_interpolated(i) = Spectrum(i);end</code></pre><p>最后使用ifft函数对得到的数据进行逆变换，代码如下所示，</p><pre class=" language-MATLAB"><code class="language-MATLAB">Signal_interpolated = ifft(Spectrum_interpolated,'symmetric');</code></pre><p>注意到这里有添加<code>symmetric</code>的选项，这里是保证输出一定为实数信号。最后变换的结果如下所示，</p><img src="/2023/02/20/zuo-fft-shi-de-pin-pu-ling-zhi-cha-zhi-wen-ti/2514b466ba987b1f7c8a6bff3da0a1a4675c4412b3eb7d1226101332dd0bdb78.png" class="" title="Zero Padding之后的频谱">  <p>可以频谱的周期并没有变，变的只是采样点数变大了，所以时域分辨率变高了。</p><h3 id="Zero-Interlacing"><a href="#Zero-Interlacing" class="headerlink" title="Zero Interlacing"></a>Zero Interlacing</h3><p>这里还有一种情况是在两根谱线的中间插零，会遇到什么情况呢？同样我们采用上述的方法进行验证，得到如下的Zero Interlacing之后的频谱，如下所示，</p><img src="/2023/02/20/zuo-fft-shi-de-pin-pu-ling-zhi-cha-zhi-wen-ti/031596c7abf436625d61701d5f99a6fd03fea7956bdcb7bfebae2ab1d3d40bc8.png" class="" title="Zero Interlacing之后的频谱">  <p>可以发现，时域谱数据的周期数量变多了，变为了原先的2倍，并且仔细观察后可以发现，增加的周期和原始的周期的数据是重复的。</p><h2 id="结合我在做MATLAB模型时看到的数据"><a href="#结合我在做MATLAB模型时看到的数据" class="headerlink" title="结合我在做MATLAB模型时看到的数据"></a>结合我在做MATLAB模型时看到的数据</h2><p>读者应该可以明白了，为什么我在量化后会遇到间断出零的情形，这是因为量化导致两个周期变一样了，因为实际上两个周期应该是有一定的相位差的，只是相位差非常小，量化误差导致了相位差被忽略，在这种情形下，自然就会出现频谱插零的情形了。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>频谱插零基本的原因是时域序列中出现了周期重复的情形，一般需要先排查时域中是否出现周期重复的量。针对我的模型，解决方案有三种：</p><ol><li>提高量化位数，减小量化误差将两个周期量化为同一个的情形；</li><li>将第二个周期的数据删去；</li><li>加入噪声。</li></ol><p>以上内容都是我的个人想法，没有经过其他人的验证。</p>]]></content>
      
      
      <categories>
          
          <category> 数字信号处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFT </tag>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DCO的Verilog模型</title>
      <link href="/2023/02/13/dco-de-verilog-mo-xing/"/>
      <url>/2023/02/13/dco-de-verilog-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文写Verilog模型，主要受到了两篇文章的启发，一篇是：</p><p>“Event-driven Simulation and modeling of phase noise of an RF oscillator”</p><p>还有一篇是复旦大学俞思辰的博士论文：</p><p>“无线射频领域中宽带全数字频率综合器的研究与设计”。</p><p>写在这里给需要的读者参考，并且向两篇论文的作者致谢，感谢他们给予我这个美妙的思路。</p><h2 id="为什么要用Verilog？"><a href="#为什么要用Verilog？" class="headerlink" title="为什么要用Verilog？"></a>为什么要用Verilog？</h2><p>Verilog模型是全数字建模模型，比较适合于数字电路，由于我们的Cadence中的电路大部分都是模拟电路，尽管如此，Cadence中也提供了数字电路的解决方案，那就是Verilog-A，这个语言模型能够帮助我们在模拟电路中快速建模数字电路。但是Verilog-A本质还是一个过采样的模型。</p><p>为什么我们不需要过采样呢？因为DCO模型中，我们每个周期的抖动都是确定的，由一个正态分布的随机数给定，在这个基础之上，我们根据窄带FM近似原理，只需要获取时钟上升沿或者下降沿的时间戳就可以获取整个电路的性能模型了。所以我们只关注时间戳，不关注其中的过程，根据这个说法，我们就不需要额外进行过采样的操作了，这样只会浪费我们的数据资源和计算资源。</p><p>Verilog就是基于边沿进行计算的仿真软件，因此，我们采用Verilog进行我们的模型的建模。如果从仿真时间角度进行分析，Verilog和Verilog-A仿真同样的模型，Verilog比Verilog-A仿真要快2~3个数量级。</p><h2 id="Verilog代码"><a href="#Verilog代码" class="headerlink" title="Verilog代码"></a>Verilog代码</h2><pre class=" language-Verilog"><code class="language-Verilog">`timescale 1ps/1fsmodule DCO_test #(  parameter wander_rms = 0.70894,  parameter jitter_rms = 0) (  input wire period0,  input wire en,  output reg clk);  reg smp = 0;  real jitter=0;  real jitter_prev=0;  real wander = 0;  real scale = 100;  real period_nom = 33.33333333333;  real period = 0;  real randvar;  real delay = 0;  real half = 2;  integer handle;  integer seed = -561;  initial begin    handle = $fopen("zero_crossing.csv");    clk = 1;    delay = period_nom*scale/2;    period = period_nom*scale;  end    always begin    forever begin        period = period_nom*scale;        // randvar = $dist_normal(seed,0,jitter_rms*scale);        // jitter = randvar;        // period = period + jitter - jitter_prev;        // jitter_prev = jitter;        randvar = $dist_normal(seed,0,wander_rms*scale);        wander = randvar/1000;        period = period + wander;        delay = period/half;        // 下降沿        #(delay);        clk = smp;  // 1->0        smp = ~smp;        // 上升沿        #(delay);        $fdisplay(handle,"%.9f",$realtime/scale, ",", clk);        clk = smp;  // 0->1        smp = ~smp;    end  endendmodule</code></pre><p>上面给出了详细的Verilog建模的代码，在代码中给出标称周期以及Period Jitter的均方根值，我们就可以得到最终的数据，采用<code>$fdisplay()</code>函数将数据从Modelsim中转换到csv文件格式，并最终在MATLAB中进行数值分析。</p><h3 id="杂散的来源"><a href="#杂散的来源" class="headerlink" title="杂散的来源"></a>杂散的来源</h3><p>如果读者将scale设置为10，并且在<code>$fdisplay</code>中的参数设置为<code>$time</code>之后，读者就会发现在10GHz处会产生一个Spur，如下图所示，</p><img src="/2023/02/13/dco-de-verilog-mo-xing/69bc60ddf95f7e7f2bc35b998d864a93f8da8a97bf90da382480a9ff19104c3d.png" class="" title="带有杂散的DCO输出相位噪声功率谱密度">  <p>这大概是由于取整操作造成的，类似于DeltaSigma中的杂散。</p><p>如果读者将<code>$fdisplay</code>中的参数设置为<code>$realtime</code>之后，产生的相位噪声功率谱密度如下所示，</p><img src="/2023/02/13/dco-de-verilog-mo-xing/9e1619b3c1e15caf695de3b3030e3bdcd331abdd96b400a750fca1a3ca669a12.png" class="" title="不带有杂散的DCO输出相位噪声功率谱密度">  <p>因此这个问题大概率是因为时间戳的时间精度不够造成的。（此处是我猜测的结论，没有确定的被验证）</p><h2 id="MATLAB数据分析模块"><a href="#MATLAB数据分析模块" class="headerlink" title="MATLAB数据分析模块"></a>MATLAB数据分析模块</h2><pre class=" language-MATLAB"><code class="language-MATLAB">clc;clear;filename = 'zero_crossing.csv';data = csvread(filename,1,0);   zerocrossings = data(:,1)./1e12;N = length(zerocrossings);TDEV = zeros(1,N);T0_avg=(zerocrossings(N)-zerocrossings(1))/(N-1);for i=1:N    TDEV(i)=zerocrossings(i)-(i)*T0_avg;endphi=2*pi*(TDEV./T0_avg);SpectrumSSB = FFTSpectrum(phi,1/T0_avg);NoisePower = 0;Expectation = 0;for i = 6 :length(SpectrumSSB)    NoisePower = NoisePower + SpectrumSSB(i)^2;endJitterRMS = sqrt(NoisePower/(2*pi/T0_avg)^2)std(TDEV)mean(TDEV)</code></pre><p>上述主函数主要完成了数据的处理，转换，以及计算操作，获得最终的相位功率谱密度。具体的相位噪声功率谱密度由下面的函数代码进行执行，</p><pre class=" language-MATLAB"><code class="language-MATLAB">function [SpectrumSSB] = FFTSpectrum(Signal,Fs)    Signal_window = length(Signal)*1/Fs;    Spectrum_Resolution = 1/Signal_window;    Spectrum_Complex = fft(Signal);    Spectrum_Magnitude_DSB = abs(Spectrum_Complex)/length(Signal);    for i=2:length(Signal)/2        % Pay Attention to sqrt(2). This is required due to magnitude        % spectrum being added is equivalent to multiplied by sqrt(2)        Spectrum_Magnitude_SSB(i) =  (Spectrum_Magnitude_DSB(i+1)+Spectrum_Magnitude_DSB(length(Signal)+1-i))/sqrt(2);    end    Spectrum_Magnitude_SSB(1) = Spectrum_Magnitude_DSB(1);    L = 10*log10(Spectrum_Magnitude_SSB.^2/Spectrum_Resolution);    semilogx((0:Spectrum_Resolution:length(Signal)/2*Spectrum_Resolution-Spectrum_Resolution),L);    title('Phase Noise');    xlabel('Hz');    ylabel('dBc/Hz');    SpectrumSSB = Spectrum_Magnitude_SSB;end</code></pre><p>基于上述操作，就可以完成数据相位噪声功率谱密度的评估工作。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我们打通了Verilog-Modelsim-MATLAB的仿真通道，通过Verilog建模，在Modelsim中仿真，最后在MATLAB中进行数据处理和计算的操作表明这样的模式是可行的。</p><p>仿真的时间复杂度和空间复杂度相对于Verilog-A的模型都得到了极大的控制。</p>]]></content>
      
      
      <categories>
          
          <category> ADPLL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADPLL </tag>
            
            <tag> Verilog建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DCO时域模型建模</title>
      <link href="/2023/02/07/dco-shi-yu-mo-xing-jian-mo/"/>
      <url>/2023/02/07/dco-shi-yu-mo-xing-jian-mo/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近需要对ADPLL中的DCO进行时域建模，初步考虑采用Verilog-A进行时域模型建模，之前的模型产生了诸多问题，例如对于DCO的$\sigma_{jitter}$大小的设置，在网上查阅到相关的模型，这些模型对于$\sigma_{jitter}$都非常小。通过公式计算后得到，在我们的应用中，$\sigma_{jitter}=1fs$。但是我们的PLL输出的时钟的$\sigma_{jitter}$应该有$50fs$。为什么$1fs$的模型可以导致$50fs$的结果呢？这是我的疑问之一。</p><p>其次对于DCO输出质量的测量问题，我也不是很清楚，为此，我查阅了论文：</p><p>“Event-Driven Simulation and Modeling of Phase  Noise of an RF Oscillator”</p><p>这篇论文内详细说明了DCO该如何进行时域建模，并且根据文献：</p><p>“Spectral Analysis of Time-Domain Phase Jitter Measurements”</p><p>以及文献：</p><p>“Experimental verification of the link between timing jitter and phase noise”</p><p>这两篇文献弄清楚了绝对抖动（Absolute Jitter）和周期抖动（Period Jitter）之间的关联与区别。如果对这些概念感兴趣的读者可以查阅我的阅读笔记：”时域抖动测量的谱分析”和”事件驱动型的仿真中的DCO相位噪声建模”两篇文章。</p><h2 id="模型代码"><a href="#模型代码" class="headerlink" title="模型代码"></a>模型代码</h2><pre class=" language-Verilog-A"><code class="language-Verilog-A">//Verilog A for ADPLL, DCO_A, veriloga`include "constants.vams"`include "disciplines.vams"// 下面的代码如果没有会出现错误如下：// ERROR (SPECTRE-16041): Analysis was skipped due to inability to compute operating point.nature Voltage    abstol = 1e-12;    access = V;    blowup = 1e308;    units = "V";endnaturemodule DCO_A(OUT, VSS, VDD, IN_A, FREQ_A, dT_A);electrical OUT, VSS, VDD, IN_A, FREQ_A, dT_A;parameter real Fmin = 30G-1G from (0:inf);parameter real Fmax = 30G+1G from (0:inf);parameter real Vlo = 0, Vhi = 900m;real jitter = 1f from [0:0.25/Fmax);    // Period Jitterreal ttol = 1u/Fmax from (0:1/Fmax);real FullRange = 2^7, Input_Value = 0;real freq, phase, dT;integer n, seed;genvar i;analog begin    @(initial_step) seed = -561;    $bound_step(0.6/freq);    // Generate the frequency using binary input data    Input_Value = V(IN_A);    // Calculate the output frequency    freq = 30G;    // Add the Phase Noise    freq = freq/(1+dT*freq);    // Perform circular integration idtmod(expr, ic, modulus, offset)    phase = 2*`M_PI*idtmod(freq, 0.0, 1.0, -0.5);    @(cross(phase + `M_PI/2, +1, ttol) or cross(phase-`M_PI/2, +1, ttol))begin        dT = $rdist_normal(seed, 0, jitter);    //[Mean = 0; STD = 1]        n = (phase >= -`M_PI/2) && (phase < `M_PI/2);    end    //Generate Output    V(OUT) <+ transition(n ? Vhi : Vlo, 0, ttol);    V(FREQ_A) <+ freq;    V(dT_A) <+ dT;endendmodule</code></pre><h3 id="频率产生"><a href="#频率产生" class="headerlink" title="频率产生"></a>频率产生</h3><pre class=" language-Verilog-A"><code class="language-Verilog-A">// Add the Phase Noisefreq = freq/(1+dT*freq);</code></pre><p>代码中的频率变化是通过如下的公式实现的，</p><p>$$<br>\Delta f = -f_0^2\Delta T<br>$$</p><p>上面的公式已经在本博客多篇相关的文章推导和出现过了，如果不清楚的读者可以回去翻看我先前的博客。这里仅仅对这一公式成立的条件做一个说明，该公式成立的条件是$\Delta T$要足够小，一般情况下在我们的ADPLL应用中通常是满足的。另外需要说明的是这里的符号问题，可以看到这里有一个负号，直观上的理解就是周期变长了，频率自然会变小，频率变化率为负值，这里就是负号的来源。</p><p>接下去推导代码中的公式，我们可以直接写出新频率的数学表达式，如下所示，</p><p>$$<br>f_{new} = f_0+\Delta f=f_0-f_0^2\Delta T=f_0(1-f_0\Delta T)<br>$$</p><p>又知有以下关系成立，</p><p>$$<br>1-f_0\Delta T\approx\frac{1}{1+f_0\Delta T}<br>$$</p><p>所以有，</p><p>$$<br>f_{new}=\frac{f_0}{1+f_0\Delta T}<br>$$</p><p>上式与代码中的公式是对应的。</p><h3 id="相位产生和高低电平产生机制"><a href="#相位产生和高低电平产生机制" class="headerlink" title="相位产生和高低电平产生机制"></a>相位产生和高低电平产生机制</h3><p>本代码的相位信息是通过idtmod的函数实现的，通过此函数我们可以限制代码中变量的最大值，降低代码的空间复杂度。该函数的输出值域为$[-0.5, 0.5]$，再考虑乘上系数$2\pi$之后，最终的值域为$[-\pi,\pi]$，可以发现覆盖整个$2\pi$的范围的。</p><p>本代码的高低电平是通过cross结合@语句的判断方式实现的，代码如下所示，</p><pre class=" language-Verilog-A"><code class="language-Verilog-A">@(cross(phase + `M_PI/2, +1, ttol) or cross(phase-`M_PI/2, +1, ttol))begin    dT = $rdist_normal(seed, 0, jitter);    //[Mean = 0; STD = 1]    n = (phase >= -`M_PI/2) && (phase < `M_PI/2);end</code></pre><p>可以看到cross函数判断现在相位是否进行到从左向右穿过$-\frac{\pi}{2}$，或者从左向右穿过$\frac{\pi}{2}$。如果是，则需要产生对应的边沿抖动，并判断到底是生成上升沿还是下降沿，直观上可以如下图所示。</p><img src="/2023/02/07/dco-shi-yu-mo-xing-jian-mo/8a81f5a7b986ca5f73b28d5893941b7a9be98dfba9f9b32c8ce0b99ac22c9411.png" class="" title="高低电平产生机制">  <p>如果phase上穿$-\frac{\pi}{2}$，那么phase一定$\geq-\frac{\pi}{2}$并且$&lt;\frac{\pi}{2}$，所以n为1；反之，n为0。这样我们就可以看到最终的0，1随相位的分布图如上图所示。</p><p>值得注意的是，这个模型的抖动是作用在周期上的，波形的占空比是严格的50%，时间戳的数学描述如下所示，</p><p>$$<br>t[i]-t[i-1]=T_0+TDEV[i]<br>$$</p><h2 id="如何测量"><a href="#如何测量" class="headerlink" title="如何测量"></a>如何测量</h2><p>根据该模型，我们产生的是方波数据，如何根据方波给出相位噪声功率谱密度呢？Bogdan在其论文：”Event-Driven Simulation and Modeling of Phase Noise of an RF Oscillator”中给出了一些提示。</p><p>方波的有用信息就是它的过零点，其过零点是确定的，假设第n个周期的上升沿时刻的时间戳为$t[n]$，我们可以把方波的这些时间戳全部取出来，假设我们的数据长度为$N=length(t)$，那么我们的平均周期为$T_0=(t[n]-t[1])/(N-1)$。有了这个信息之后就可以继续计算绝对抖动了，绝对抖动的表达式如下所示，</p><p>$$<br>TDEV[i]=t[i]-i\cdot T_0<br>$$</p><p>那么根据绝对抖动的值，通过关系$\Delta\phi=2\pi f_0\Delta t$，我们可以将时间抖动转换$TDEV$为相位噪声$\phi$，如下所示，</p><p>$$<br>\phi[i]=2\pi f_0TDEV[i]<br>$$</p><p>有了相位噪声信息之后，我们可以直接对相位噪声$\phi[n]$进行fft操作，绘制出$\phi[n]$的功率谱密度。</p><p>至此我们打通了Verilog-A代码到噪声功率密度谱的通道，为后期建模打下了坚实的基础。</p>]]></content>
      
      
      <categories>
          
          <category> ADPLL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADPLL </tag>
            
            <tag> DCO </tag>
            
            <tag> 时域建模 </tag>
            
            <tag> Verilog-A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时域抖动测量的谱分析</title>
      <link href="/2023/02/03/shi-yu-dou-dong-ce-liang-de-pu-fen-xi/"/>
      <url>/2023/02/03/shi-yu-dou-dong-ce-liang-de-pu-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文的内容来自于</p><p>“Un-Ku Moon, K. Mayaram and J. T. Stonick, “Spectral analysis of time-domain phase jitter measurements,” in IEEE Transactions on Circuits and Systems II: Analog and Digital Signal Processing, vol. 49, no. 5, pp. 321-327, May 2002, doi: 10.1109/TCSII.2002.802343.”</p><p>我阅读这篇文章的主要目的在于弄清楚各种抖动的定义到底是什么，它们之间到底有什么关系。</p><h2 id="jitter的种类"><a href="#jitter的种类" class="headerlink" title="jitter的种类"></a>jitter的种类</h2><p>作者说通常用来描述jitter的量有，”period jitter”、”edge-to-edge jitter”、”cycle-to-cycle jitter”、”absolute jitter”、”tracking jitter”等等。</p><p>本文的目的就是总结这些量，并且弄清它们之间的关系。</p><h2 id="抖动-amp-相位噪声"><a href="#抖动-amp-相位噪声" class="headerlink" title="抖动&amp;相位噪声"></a>抖动&amp;相位噪声</h2><p>假设一个理想的无抖动的信号为$s(t)$，带有抖动的信号为$s_j(t)=s(t+j(t))$，我们直接对上述两个信号做傅里叶展开，理想的信号如下，</p><p>$$<br>s(t)=c_1cos(\omega_ot)+c_2cos(2\omega_ot)+c_3cos(3\omega_ot)+···<br>$$</p><p>带有抖动的信号如下，</p><p>$$<br>s_j(t)=c_1cos(\omega_ot+\omega_oj(t))+c_2cos(2\omega_ot+2\omega_oj(t))+···\<br>=c_1cos(\omega_ot+\phi(t))+c_2cos(2\omega_ot+2\phi(t))+···\<br>$$</p><p>在有抖动的信号的傅里叶展开式里，有两种抖动的表达形式，一个是$\omega_oj(t)=\phi(t)$，我们马上可以看到这里有单位的转换了，$j(t)$的单位为$[s]$，$\phi(t)$的单位为$[rad]$。</p><p>我们把单位为$[s]$的$j(t)$称为时间抖动，Jitter；把单位为$[rad]$的$\phi(t)$称为相位噪声，Phase Noise。</p><p>所以这里我们搞清楚了相位噪声和抖动的关联与区别。</p><h2 id="rad-2-x2F-Hz-还是-dBc-x2F-Hz"><a href="#rad-2-x2F-Hz-还是-dBc-x2F-Hz" class="headerlink" title="$rad^2/Hz$还是$dBc/Hz$"></a>$rad^2/Hz$还是$dBc/Hz$</h2><p>这里我在看Bogdan的文章”Event-Driven Simulation and Modeling of Phase Noise of an RF Oscillator”也存在疑问，他原文是这样描述的，</p><img src="/2023/02/03/shi-yu-dou-dong-ce-liang-de-pu-fen-xi/9736fbeb59e7d3b005162168b65e0ce74856377c68326fab9a33ca31554c52cc.png" class="" title="单边谱到双边谱的转换">  <p>这里的谱的单位为$[rad^2/s]$，可是我一直以为是$[dBc/Hz]$，这两个到底有什么关联呢？作者马上给出了答案。</p><h3 id="Narrow-Band-FM-Approximation"><a href="#Narrow-Band-FM-Approximation" class="headerlink" title="Narrow-Band FM Approximation"></a>Narrow-Band FM Approximation</h3><p>这里使用到了其实在”ADPLL相位域MATLAB模型”中我就推导过的一个近似方法。说起来也是挺有趣的，当时在做ADPLL的相位域模型，在测量输出信号的相位噪声的时候，我直接对几十GHz的信号做了采样操作，并且想要得到频谱分辨率为10kHz级别的相位噪声谱密度。（真是一个天真的想法）</p><p>上述操作是不行的，闫老师当时就指出了问题，我一直没有找到对应的理论，后来我在2023年初的春节假期里进行了推导，发现确实是那么回事，没想到推导的结论就是我们的窄带FM近似… <span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>这里就不做推导了，需要的话可以去我那篇文章里看看，这里就把结论直接写出来，</p><p>$$<br>a(t)=cos(\omega_ot+\phi(t))\approx cos(\omega_ot)-sin(\omega_ot)\phi(t)<br>$$</p><p>上述式子成立的条件就是$\phi(t)\rightarrow0$或者是$\phi(t)&lt;&lt;2\pi$。</p><p>如果是符合窄带FM特征的抖动，就可以直接将相位抖动$\phi(t)$的频谱放在基频$\omega_o$处。当然这样做需要换一下单位，由原先的[dBc/Hz]换成[rad^2/Hz]。</p><p>可以看到，这两个单位如果符合窄带FM近似的条件的话，是可以自由转换的，当然前提是必须要满足窄带FM近似的条件。</p><p>作者在这里还非常严谨地补充了，如果抖动不符合窄带FM近似地条件，那么相位噪声谱密度的形状是怎么样的，是一型Bessel函数的形状，我上网搜了一下，大概长下面这个样子，</p><img src="/2023/02/03/shi-yu-dou-dong-ce-liang-de-pu-fen-xi/ec18feafc1fcc585b6c20d2d544c52dd712206a5ef4f68e553eff609c62cf570.png" class="" title="一型Bessel函数">  <p>真的非常的诡异，作者为了防止我们进一步掉入钻研Bessel函数的陷阱，告诉了我们，”In the analysis of oscillator/PLL systems and applications, the narrow-band assumption is typically accurate”，也就是说在振荡器和PLL系统里面，一般窄带FM近似就足够准确了。</p><h2 id="Two-Most-Commonly-Used-Jitter-Types"><a href="#Two-Most-Commonly-Used-Jitter-Types" class="headerlink" title="Two Most Commonly Used Jitter Types"></a>Two Most Commonly Used Jitter Types</h2><p>作者说这里采用的描述和拉扎维的一篇论文”A study of oscillator jitter due to supply and substrate noise”比较类似，作者简单介绍了两种Jitter的类型，Period Jitter以及Absolute Jitter</p><h3 id="Period-Jitter"><a href="#Period-Jitter" class="headerlink" title="Period Jitter"></a>Period Jitter</h3><img src="/2023/02/03/shi-yu-dou-dong-ce-liang-de-pu-fen-xi/3113c573728942340ac467210cf03e4381b7f2f246cc6571bda3f91155927ac3.png" class="" title="Period Jitter示意图">  <p>实际测量的变化是周期长度的变化，周期的定义为一个上升沿到下一个上升沿。因为测量的周期的变化，有些人称这种Jitter为edge-to-edge jitter、cycle jitter、cycle-to-cycle jitter。作者在这边还贴心地提示了，cycle-to-cycle jitter这一说法是有歧义地，如下所示，</p><img src="/2023/02/03/shi-yu-dou-dong-ce-liang-de-pu-fen-xi/22594e82edf4299e6b833344c20ff2f713717b4bfcb3c1b5f38ea79ea13d4c33.png" class="" title="Cycle-to-cycle不同的定义">  <p>作者说这种period jitter的描述一般在数字应用（例如微处理器）中经常采用，因为数字电路中比较关心时钟边沿之间的数据锁存情况。</p><h3 id="Absolute-Jitter"><a href="#Absolute-Jitter" class="headerlink" title="Absolute Jitter"></a>Absolute Jitter</h3><p>Absolute jitter，绝对抖动也是常用的一种抖动衡量办法，有的时候tracking jitter是这种抖动的另一个名字。作者说相对于tracking jitter，absolute jitter这个名字更加有用，所以作者采用absolute jitter来指代这种与理想源之间的绝对时间偏差。</p><img src="/2023/02/03/shi-yu-dou-dong-ce-liang-de-pu-fen-xi/3c6a901d969cd9200e0a1812dd7d148f28ef2e28f861dea2792f08eaee060af8.png" class="" title="Absolute Jitter示意图">  <h3 id="其他的名字"><a href="#其他的名字" class="headerlink" title="其他的名字"></a>其他的名字</h3><table><thead><tr><th>文章作者</th><th>period jitter的别名</th><th>absolute jitter的别名</th></tr></thead><tbody><tr><td>Maneatis</td><td>cycle-to-cycle jitter</td><td>tracking jitter</td></tr><tr><td>Herzel &amp; Razavi</td><td>cycle jitter</td><td>long term jitter</td></tr></tbody></table><p> 本文在使用名称的同时还会给出具体的表达式，以防止出现误解。</p><h2 id="以二阶PLL为例讲解这些不同的jitter之间的区别"><a href="#以二阶PLL为例讲解这些不同的jitter之间的区别" class="headerlink" title="以二阶PLL为例讲解这些不同的jitter之间的区别"></a>以二阶PLL为例讲解这些不同的jitter之间的区别</h2><p> 作者给出了二阶PLL相关的公式，并介绍了二阶PLL相关的概念，这些概念将会帮助读者进一步理解jitter之间的关联和区别。</p><h3 id="测量开环PLL（单独工作的振荡器）"><a href="#测量开环PLL（单独工作的振荡器）" class="headerlink" title="测量开环PLL（单独工作的振荡器）"></a>测量开环PLL（单独工作的振荡器）</h3><p> 作者先给出了绝对抖动的定义，absolute jitter，如下图所示，</p> <img src="/2023/02/03/shi-yu-dou-dong-ce-liang-de-pu-fen-xi/31644a73b827a381f1a60af100a66f035ce5667a9c7490615c2f5c33d0203316.png" class="" title="绝对抖动示意图">  <p>并且给出了一般的振荡器的相位噪声模型，$|X(\omega)^2|\propto1/\omega^2$，这是在只考虑白噪声的前提下的。</p><p>接着作者给出了周期偏移的定义：$p_1(n)=x(n)-x(n-1)$，假如两次时间戳偏移的大小和方向完全一样，那么周期偏移完全为零。接下去，作者又做了推广，如下，</p><p>$$<br>p_N(n)=x(n)-x(n-N)<br>$$</p><p>对于$\sigma_N^2$的大小，作者专门做了推导，过程比较复杂，最终的结果如下所示，</p><img src="/2023/02/03/shi-yu-dou-dong-ce-liang-de-pu-fen-xi/eb620f9b9239894149664c5247d3b9a3e396d6517b511386c33694b479c9caa4.png" class="" title="$P_N的噪声功率谱密度$">  <p>读者可以看到，随着$N$不断增大，起到的滤波作用就越小，当$N=1$时，低通滤波的效果是最强的，作者还绘制了图片来描述这一问题，如下所示，</p><img src="/2023/02/03/shi-yu-dou-dong-ce-liang-de-pu-fen-xi/1f4633351d0676774e7686ff3c693e9033f73a991b20a0939ab8e67bd300abb4.png" class="" title="N">  <h3 id="重要结论"><a href="#重要结论" class="headerlink" title="重要结论"></a>重要结论</h3><p>所以这里我给出结论，在Bogdan的VHDL模型中，采用的是$N=1$的噪声功率谱密度情形，也就是Period Jitter；而在一般测量PLL的$Jitter_{rms}$时，我们采用的是$N=length(Data)$的方式进行测算的，所以Period Jitter由于自身携带了滤波效应，所以计算出的$Jitter_{rms}$自然就会小；而$N=length(Data)$的方式测算出的噪声功率谱密度曲线与绝对抖动的情形最为接近，滤波效应小，所以计算出的$Jitter_{rms}$比较大。</p><p>读者可以记住的结论是：$p_N(n)=x(n)-x(n-N)$一式中的N越大，其抖动越趋近于绝对抖动。N越小，低通滤波效应越强，抖动大小越小。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 相位噪声 </tag>
            
            <tag> Jitter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件驱动型的仿真中的DCO相位噪声建模</title>
      <link href="/2023/02/03/shi-jian-qu-dong-xing-de-fang-zhen-zhong-de-dco-xiang-wei-zao-sheng-jian-mo/"/>
      <url>/2023/02/03/shi-jian-qu-dong-xing-de-fang-zhen-zhong-de-dco-xiang-wei-zao-sheng-jian-mo/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文内容来自于</p><p>“R. B. Staszewski, C. Fernando and P. T. Balsara, “Event-driven Simulation and modeling of phase noise of an RF oscillator,” in IEEE Transactions on Circuits and Systems I: Regular Papers, vol. 52, no. 4, pp. 723-733, April 2005, doi: 10.1109/TCSI.2005.844236.”</p><p>我本人在做ADPLL的仿真时，在对jitter进行建模时，不清楚jitter的作用机制是怎么样的，并且也不清楚按照简单的正太随机数叠加在频率上，到底对最终的相位噪声又怎么样的影响。所以，希望通过这篇文章理清这其中的逻辑和机制，之后在面对抖动建模问题时，至少有一个思考的方向和思路。</p><h2 id="DCO的一些噪声来源"><a href="#DCO的一些噪声来源" class="headerlink" title="DCO的一些噪声来源"></a>DCO的一些噪声来源</h2><img src="/2023/02/03/shi-jian-qu-dong-xing-de-fang-zhen-zhong-de-dco-xiang-wei-zao-sheng-jian-mo/5e478434c08cd28e2dda29db2883323794a0d5e0122caf46ed351c9b39f8240b.png" class="" title="DCO噪声来源"> <h2 id="为什么使用VHDL而不是使用Verilog？"><a href="#为什么使用VHDL而不是使用Verilog？" class="headerlink" title="为什么使用VHDL而不是使用Verilog？"></a>为什么使用VHDL而不是使用Verilog？</h2><p>作者给出的解释时VHDL支持实数（浮点数）类型的信号，由于通信里面信号有些是在幅值上是连续的，所以使用VHDL能够对这类型号做更好的建模。</p><img src="/2023/02/03/shi-jian-qu-dong-xing-de-fang-zhen-zhong-de-dco-xiang-wei-zao-sheng-jian-mo/597c330f4447b47228c928520e6558ed904c4f410ff40198575bfb3f099ad493.png" class="" title="使用VHDL而不是Verilog的好处">  <p>所以作者选择了VHDL对整个模型进行仿真，原因如下，</p><ul><li>VHDL相比于SPICE或者analog mixed-signal VHDL(VHDL-AMS)更加快速</li><li>VHDL相比C、MATLAB等环境能够与硬件形成比较好的关联和匹配，而不是像C、MATLAB一样是一种高层次的行为模型，与硬件完全割裂开来。</li></ul><h2 id="基本的一些时域等式"><a href="#基本的一些时域等式" class="headerlink" title="基本的一些时域等式"></a>基本的一些时域等式</h2><p>我们假设$f_o$为我们的标称振荡频率，换句话说也就是我们的理想震荡频率，定义$T_o=\frac{1}{f_o}$为我们的理想震荡周期。</p><p>定义$\Delta T$为时钟周期减少的量，那么定义新的时钟周期如下，</p><p>$$<br>T=T_o-\Delta T<br>$$</p><p>新的时钟周期的变化一定为导致标称频率$f_o$发生$\Delta f$的变化，那么新的震荡频率如下所示，</p><p>$$<br>f=f_o+\Delta f<br>$$</p><p>如果我们的周期变化的长度远远小于我们的时钟周期$\Delta T &lt;&lt; T_o$，即$\frac{\Delta T}{T_o}&lt;&lt;1$，那么我们可以得到如下的周期变化量$\Delta T$与频率变化量$\Delta f$之间的关系，</p><p>$$<br>\Delta f\approx f_o\frac{\Delta T}{T_o}=f_o^2\Delta T=\frac{\Delta T}{T_o^2}<br>$$</p><p>上述式子表明，在$\Delta T$非常小的时候，可以认为$\Delta T$与$\Delta f$之间是线性关系，以中心频率的平方为斜率。</p><h3 id="频偏与时偏线性关系的推导"><a href="#频偏与时偏线性关系的推导" class="headerlink" title="频偏与时偏线性关系的推导"></a>频偏与时偏线性关系的推导</h3><p>下面推导一下上面的结论，</p><p>$$<br>f_o+\Delta f=\frac{1}{T_o-\Delta T}=\frac{1}{T_o}\frac{1}{1-\frac{\Delta T}{T_o}}=f_o(1+f_o\Delta T)<br>$$</p><p>上面的式子成立的原因是$\frac{1}{1-x}$的泰勒展开，</p><p>$$<br>\frac{1}{1-x}=1+x+x^2+x^3+···+x^n+o(x^n)<br>$$</p><p>所以，</p><p>$$<br>\frac{1}{1-\frac{\Delta T}{T_o}}=1+\frac{\Delta T}{T_o}<br>$$</p><p>证明完毕。</p><h2 id="相位噪声的时域建模"><a href="#相位噪声的时域建模" class="headerlink" title="相位噪声的时域建模"></a>相位噪声的时域建模</h2><p>作者这边先给出了振荡器的相位噪声的频域模型，如下图所示，</p><img src="/2023/02/03/shi-jian-qu-dong-xing-de-fang-zhen-zhong-de-dco-xiang-wei-zao-sheng-jian-mo/d0fafbd47b633e7e46eb9ac9def006d15fae9aca60460e6735bd1de41a9e6f60.png" class="" title="相位噪声的频域模型">  <p>这边三段曲线代表了不同的来源的相位噪声，第一段$1/\omega^3$和第二段$1/\omega^2$应该比较熟悉了，第一段是$1/f$噪声造成的；第二段是热噪声造成的。第三段可能大家平时不会去关注，是由于输出buffer等造成的噪声。</p><p>作者把这两种相位噪声造成的时钟在时域内的时间戳的偏差分类为：</p><ul><li>jitter</li><li>wander</li></ul><p>作者给几个区域的时域时间戳偏移下了定义：说$1/\omega^0$的区域为非累积性jitter；$1/\omega^2$的区域为累积性的wander；$1/\omega^3$的区域为多种wander贡献的加权和。</p><p>上述描述还是非常不明确，什么是jitter？什么是wander？读到这里我会有这些疑问。</p><h3 id="振荡器Jitter的建模"><a href="#振荡器Jitter的建模" class="headerlink" title="振荡器Jitter的建模"></a>振荡器Jitter的建模</h3><p>这里作者先从最右侧曲线的$1/\omega^0$的部分开始建模，作者先给出了下图，下图描述了该部分造成的nonaccumulatitve jitter，那么什么是nonaccumulative jitter???</p><img src="/2023/02/03/shi-jian-qu-dong-xing-de-fang-zhen-zhong-de-dco-xiang-wei-zao-sheng-jian-mo/792a4b604878f3554d97107b3c51e004b85180efda8bd2831cad60a8dbb079b5.png" class="" title="非累积性时间戳偏差（jitter）">  <p>图片下方的刻度$T_0$的整数倍，表示了理想等间距(equidistant)的工作在$f_0$的时钟的上升沿时刻。这里的抖动的成因作者说是因为输出的实体buffer造成的，这句话可以理解；作者又说这些时间误差将会叠加在每一个理想的时间戳出现的时刻上。到这里我大概能明晰了，因为这种抖动不是振荡器形成时钟的时候产生的，所以并不会影响到周期，当前时刻的抖动也不会对下一个时刻的抖动产生影响。（这句话并不是作者说的，只是我自己的猜测）哈哈，果然，马上作者就说了：”These timing errors do not influence one another. “。这句话直接印证了我的猜测。</p><p>那么分析了这么多，这种噪声应该如何进行建模呢？作者说这些抖动都是独立同分布的，可以使用Additive White Gaussian Noise(AWGN)进行建模。</p><p>作者为了更加清晰地，没有歧义地描述这个问题，马上给出了这个时间戳偏移的数学表达式，如下所示，</p><p>$$<br>t_j[i]=i\cdot T_0 + \Delta t[i]\<br>TDEV_j[i]=\Delta t[i]<br>$$</p><p>所以可以看到偏移完全是独立同分布的服从正态分布的随机变量，补一个插曲，这里又和我研一的时候选修的随机过程建立了关联，我记得这种独立同分布且服从正态分布的随机过程为布朗运动。</p><p>作者马上给出了一个推论period deviation，周期偏移，的方差为时间戳偏差的两倍，因为$p_1[i]=t_j[i]-t_j[i-1]=T_0+\Delta t[i]-\Delta t[i-1]$，因为两个$i.i.d.$的随机变量的方差对加法和减法都是加倍。</p><p>根据上述描述，作者给出了如何计算该种时间戳偏移的均方根值得方法，作者将这个量称为rms jitter, $\sigma_{\Delta t}$。具体的计算公式如下，</p><p>$$<br>\sigma_{\Delta t}=\frac{T_0}{2\pi}\cdot\sqrt{\mathcal{L}\cdot f_0}<br>$$</p><p>其中，$\mathcal{L}$表示了相位噪声功率的双边谱密度。可以看到这个式子和我们之前使用的积分再转换的计算均方根的抖动的公式是一样的，如果不熟悉的读者可以再回去看看我的”ADPLL相位域MATLAB模型”一文。</p><p>作者还给了一个例子，说了典型值大概为$\sigma_{\Delta t}=33fs$，如下所示，</p><img src="/2023/02/03/shi-jian-qu-dong-xing-de-fang-zhen-zhong-de-dco-xiang-wei-zao-sheng-jian-mo/f4bd0e6ab579162fda1a5ca48f1e677315e6fb08445639c218c870dc4b433866.png" class="" title="Nonaccumulative Jitter Example">  <h3 id="振荡器Wander的建模"><a href="#振荡器Wander的建模" class="headerlink" title="振荡器Wander的建模"></a>振荡器Wander的建模</h3><p>作者又对热噪声引起的Wander进行了建模，这里终于要开始解决Wander和Jitter的区别了。作者说这种wander属于accumulative jitter，属于累积性的。这个其实从噪声源的本质也可以理解，这个噪声是产生于决定时钟周期的过程中的，（时钟内部），换句话说，这个噪声一定程度上是时钟周期诸多变量当中的一个。作者说，当前的时间戳还取决于先前噪声的综合；作者还说，这种行为被建模为随机游动（随机过程中的概念，真希望之前好好学习随机过程）。</p><img src="/2023/02/03/shi-jian-qu-dong-xing-de-fang-zhen-zhong-de-dco-xiang-wei-zao-sheng-jian-mo/a2d5e09e1c4c8a5b6fa2b7c0f128ddcd81ffffefb73e3f97837bff9ec865e088.png" class="" title="Wander的时域模型">  <p>同样的，为了避免混淆，作者马上给出了Wander的数学表达式，</p><p>$$<br>t_w[i]=i\cdot T_0+\sum^i_{l=1}\Delta T[l]\<br>TDEV_w[i]=\sum^i_{l=1}\Delta T[l]<br>$$</p><p>可以看到这里和jitter的区别在于存在一个累加的操作，而jitter的$TDEV$是与先前噪声样本无关的。</p><p>这里作者给出了$\Delta T$的rms值得公式，如下所示，</p><p>$$<br>\sigma_{\Delta T}=T_0\cdot\Delta\omega\sqrt{\frac{\mathcal{L}{\Delta\omega}}{2\pi\omega_0}}=\frac{\Delta f}{f_0}\cdot\sqrt{T_0}\cdot\sqrt{\mathcal{L}{\Delta\omega}}<br>$$</p><p>注意，这里求的抖动不是$TDEV_\omega$的均方根抖动，而是$\Delta T$的均方根抖动。所以这里就是我一直产生问题的地方，这个$\sigma_{\Delta T}$求出来其实非常小，大概只有几个$fs$但是造成的$jitter_{rms}$其实是挺大的。</p><h3 id="Wander标准差的推导"><a href="#Wander标准差的推导" class="headerlink" title="Wander标准差的推导"></a>Wander标准差的推导</h3><p>本文作者对于这个公式给出了两个引用，分别是：</p><ul><li>[9] T. C. Weigandt, B. Kim, and P. R. Gray, “Analysis of timing jitter in CMOS ring oscillators,” in Proc. IEEE Solid-State Circuits Conf., vol. 4, Jun. 1994, pp. 27–30.</li></ul><img src="/2023/02/03/shi-jian-qu-dong-xing-de-fang-zhen-zhong-de-dco-xiang-wei-zao-sheng-jian-mo/34ce1808b33171be62819275d67cc7bdbe48062939a5f630aeea17f4f95da96f.png" class="" title="[9]引用中的相关描述">  <ul><li>[10] A. Zanchi, A. Bonfanti, and S. Levantino et al., “General SSCR vs. cycle-to-cycle jitter relationship with application to the phase noise in<br>PLL,” in Proc. Southwest Symp. Mixed-Signal Design, Feb. 2001, pp. 32–37.</li></ul><img src="/2023/02/03/shi-jian-qu-dong-xing-de-fang-zhen-zhong-de-dco-xiang-wei-zao-sheng-jian-mo/c609e1caa85df065ede669242c96cb2f54ca2cf21432b46453476443888607ab.png" class="" title="[10]引用中的相关描述">  <p>上述两个引用都没有对这个公式的推导，在[10]引用中，作者A. Zanchi et al.描述了这个公式的来源，在[10]引用一文中的[1]引用中：</p><p>“C. Samori, A. L. Lacaita, A. Zanchi and F. Pizzolato, “Experimental verification of the link between timing jitter and phase noise”, IEEE Elec. Lett., vol. 34, no. 21, pp. 2024-2025, Oct. 1998.”</p><p>在这篇文章中，作者对该内容进行了详细的推导，现将我理解的推导过程列为如下，</p><p>在PLL中，频率谱与相位谱的关系如下所示，</p><p>$$<br>\begin{equation}<br>S_{f_o}(f_n)=f_n^2S_\phi(f_n)<br>\end{equation}<br>$$</p><p>假设我们的时间抖动远远小于我们的时钟周期，有下式成立（此式常用，已经在本人博客多篇相关文章中描述过），</p><p>$$<br>\begin{equation}<br>\Delta f_o=-\frac{\Delta T_o}{T_o^2}=-f_o^2\Delta T_o<br>\end{equation}<br>$$</p><p>由式（2）我们可以得到下面的表达式</p><p>$$<br>\begin{equation}<br>\sigma_{f_o}^2=f_o^4\sigma_{T_o}^2<br>\end{equation}<br>$$</p><p>这里我们假设我们的独立振荡器只有热噪声，那么其频率谱可以表示为一个平带热噪声，双边噪声功率谱密度为$S_{f_o}(f_n)$，那么我们可以得到频率方差如下，</p><p>$$<br>\begin{equation}<br>\sigma_{f_o}^2=f_o\cdot S_{f_o}(f_n)<br>\end{equation}<br>$$</p><p>再将式(1)代入式(4)，有，</p><p>$$<br>\begin{equation}<br>\sigma_{f_o}^2=f_o\cdot S_{f_o}(f_n)=f_of_n^2S_\phi(f_n)<br>\end{equation}<br>$$</p><p>再由式(3)得到下式的关系，</p><p>$$<br>\begin{equation}<br>\sigma_{f_o}^2=f_o^4\sigma_{T_o}^2<br>\end{equation}<br>$$</p><p>将式(5)与式(6)整理可以得到，</p><p>$$<br>\sigma_{T_o}^2=\frac{f_n^2}{f_o^3}S_\phi(f_n)<br>$$</p><p>需要注意的是，上式成立的条件是：</p><ol><li>$\sigma_{T_o}$足够小；</li><li>$S_{f_o}(f_n)$为平带的白噪声。</li></ol><p>如果2条件不成立，那么我们可以参考文献：</p><p>E. J. Baghdady, R. N. Lincoln and B. D. Nelin, “Short-term frequency stability: Characterization, theory, and measurement,” in Proceedings of the IEEE, vol. 53, no. 7, pp. 704-722, July 1965, doi: 10.1109/PROC.1965.3995.</p><p>该文献给出了频谱与timing jitter之间的关系。</p><p>仍需要注意的是，这里的抖动指的是短期抖动，并不是长期抖动，与我们的所认知的长期抖动是不符合的。（这是我自己的认知，不知道是否正确）</p><h3 id="wander的例子"><a href="#wander的例子" class="headerlink" title="wander的例子"></a>wander的例子</h3><p>在我们的应用中，中心频率为$f_o=30GHz$，周期为$T_o=33.3ps$，在频偏@$\Delta f=610.87kHz$，相位噪声功率谱密度为$\mathcal{L{\Delta f}}=10^{-101.38/10}=7.27\cdot10^{-11}rad^2/Hz$，最后计算出来的$\sigma_{\Delta t}\approx1fs$</p><h2 id="如何根据时间戳给出相位噪声功率谱密度？"><a href="#如何根据时间戳给出相位噪声功率谱密度？" class="headerlink" title="如何根据时间戳给出相位噪声功率谱密度？"></a>如何根据时间戳给出相位噪声功率谱密度？</h2><p>我先暂时略去了作者关于$1/f$噪声建模的描述、以及作者对振荡器VHDL代码的描述。目前还没有考虑到这一步。作者对于测绘振荡器时间戳的相位噪声功率谱密度相关的内容是非常有意义的。时间戳的绝对值的偏移是我们用来计算的量，为了避免混淆，在这里给出数学表达式，这个量的数学表达式如下所示，</p><p>$$<br>TDEV[i]=t[i]-i\cdot T_0<br>$$</p><p>作者这边说，”Relationship between $TDEV$ and phase noise $\phi$ is straightforward: $\phi[i]=2\pi(TDEV[i]/T_0)$.”。实际上这个关系就是我们常用的如下的数学关系，直观上理解就是横坐标变化量$\Delta t$乘以斜率$2\pi f_0$等于纵坐标变化量$\Delta\phi$。</p><p>$$<br>\Delta\phi=2\pi f_0\Delta t<br>$$</p><p>直接对上述转换后的数据进行$FFT$操作就可以得到我们的幅度谱频谱了，平方后得到功率谱，再除以我们的频谱分辨率$f_{res}$就可以得到我们的噪声功率谱密度了。</p><p>至此，我认为作者已经完整描述了如何使用VHDL进行建模并且如何进行结果分析的流程，接下去就等着我进行复现和实践了！！</p>]]></content>
      
      
      <categories>
          
          <category> ADPLL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADPLL </tag>
            
            <tag> 仿真建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MOS简易电路分析</title>
      <link href="/2023/02/02/mos-jian-yi-dian-lu-fen-xi/"/>
      <url>/2023/02/02/mos-jian-yi-dian-lu-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文来源于</p><p>“A. Sheikholeslami, “Looking into a Node [Circuit Intuitions],” in IEEE Solid-State Circuits Magazine, vol. 6, no. 2, pp. 8-10, Spring 2014, doi: 10.1109/MSSC.2014.2315062.”</p><h2 id="本文利用基本的MOS模型"><a href="#本文利用基本的MOS模型" class="headerlink" title="本文利用基本的MOS模型"></a>本文利用基本的MOS模型</h2><p>本文利用的MOS基本模型如下图所示，</p><img src="/2023/02/02/mos-jian-yi-dian-lu-fen-xi/ee845d74a1b2e3b1bcf15e7a5c73109ff3e2c78e0eb2e443133869acd324f690.png" class="" title="MOS基本模型">  <p>可以看到作者还考虑了体效应带来的JFET的跨导电流源的作用$g_{mb}$。</p><p>作者还提到了这种方法的动机，常用的暴力法使用KCL/KVL进行求解的方式会存在两个缺点：1、经常会出错，计算过于复杂；2、对于电路的工作原理不能提供直观的解释。</p><p>本文通过几种基本元素（building block的概念）的建立帮助读者快速分析电路。</p><h2 id="8种基本模型"><a href="#8种基本模型" class="headerlink" title="8种基本模型"></a>8种基本模型</h2><p>本文给出了8种常用的模型，来计算从端子看入的阻抗，8种模型如下图所示，</p><img src="/2023/02/02/mos-jian-yi-dian-lu-fen-xi/b581203bd56c9c0cf87b05cfb6cf559d4f8bbb07c2783d854584c03a38d4e149.png" class="" title="8种常用的模型">  <h3 id="模型一"><a href="#模型一" class="headerlink" title="模型一"></a>模型一</h3><p>模型一是一个简单的PMOS，它的源和漏都接地，这时，从栅极看进去的等效电路是一个无穷大的电阻。</p><img src="/2023/02/02/mos-jian-yi-dian-lu-fen-xi/c9dc6c3064ec0ebad7ef0cc52c24adec7d2765bc4ec57c2959bb42bf207d09f9.png" class="" title="模型一的电路图">  <p>即使源和漏不是接地，从栅极看进去的电阻也是无穷大的。</p><h3 id="模型二"><a href="#模型二" class="headerlink" title="模型二"></a>模型二</h3><p>NMOS栅极和源极均接地，从漏极看进去，只能看到一个$r_o$，如下图所示，</p><img src="/2023/02/02/mos-jian-yi-dian-lu-fen-xi/1cd57cf28e124d6abf8b7d8159d8a3490803fb7ebf6e8264227e1ff4be7e5aae.png" class="" title="模型二的电路图">  <p>可以从MOS管的等效模型，如下图所示，分析出，如果G与S均接地，那么跨到受控源的电流就为零，相当于该器件不存在，所以也就只能看到一个$r_o$了</p><img src="/2023/02/02/mos-jian-yi-dian-lu-fen-xi/ee845d74a1b2e3b1bcf15e7a5c73109ff3e2c78e0eb2e443133869acd324f690.png" class="" title="MOS基本模型">  <h3 id="模型三"><a href="#模型三" class="headerlink" title="模型三"></a>模型三</h3><p>该电路的MOS管的D与G均小信号接地，这时从S看入的电路为</p><p>$$<br>r_o||1/(g_{m}+g_{mb})<br>$$</p><img src="/2023/02/02/mos-jian-yi-dian-lu-fen-xi/cd52a47a7bd1d6f2a1df1a701db2f40e654fd0eeb002973388d413772ae5452b.png" class="" title="模型三的电路图">  <h3 id="模型四"><a href="#模型四" class="headerlink" title="模型四"></a>模型四</h3><p>这种情况下从漏看入的阻抗为</p><p>$$<br>r_o||1/(g_m)<br>$$</p><p>需要注意的是，由于体和漏都接地，所以体效应的跨导就被忽略了。</p><img src="/2023/02/02/mos-jian-yi-dian-lu-fen-xi/9bc4dd586311e50cd5c7807077a6399a4a3bec62f1546d6e271b15ee4bd507f6.png" class="" title="模型四的电路图">  <h3 id="模型五"><a href="#模型五" class="headerlink" title="模型五"></a>模型五</h3><p>此模型类似Cascode结构，这种结构作者没有进行推导过，我在这里用我想出的一种非常简单的方法推导一下。</p><img src="/2023/02/02/mos-jian-yi-dian-lu-fen-xi/95d664f1931fb634777ab47661c4434ba5cfac20b703e770c4c9f9db3a7f6241.png" class="" title="模型五的电路图">  <p>我的导师曾经说过，要摒弃从电压的角度分析和观看电路，要学会从电流的角度分析和观看电路，这里也不例外，我们先从电流的角度来看看这个电路</p><img src="/2023/02/02/mos-jian-yi-dian-lu-fen-xi/3b767e1e1319d50143930f32d1e34000091ee3cb42907561838c851a7760b031.png" class="" title="Cascode电路分析模型">  <p>上面一张图是我分析电路经常会画的一张图，将MOS的$r_o$绘制在原先的图上，接下去在输出施加一个向里的电流，观看在输出端产生的电压变化。</p><p>接下去读者想象自己是那个电流，一开始，MOS管的S是没有电压的，所以$V_{GS}=0$，电流不可能从MOS管的跨导电流源上走，只能走$r_o$。</p><p>这里教授读者一个小技巧，那就是我这些图里的MOS管符号都是指只有受控电流源的MOS管，非理想的代表沟道长度调制效应的$r_o$已经分离出去了。从这个层面将，读者完全可以把MOS的符号看作是一个理想的受控电流源。</p><p>接着上面的电流继续说，假如我是$i_x$，那么我一定会走$r_o$，直接的结果就是在$r_o$两端产生大小为$i_1r_o$的电压差。</p><p>接下去作为电流，我会有两个方向行走，一个是往上走，进入MOS的源，一个是往下走，进入电阻。当然，我作为电流没办法在进入电路之前就知道该往哪边走，不过有一个原则那就是我肯定往电阻小的支路行走，这样产生的电压最小。从直观上来讲，当然是往MOS的源走的电阻比较小，因为一般认为$1/g_m$是比较小的，但是从定量计算的角度来说，我们还是需要进一步定量算一下。</p><p>这里的精髓在于无论往上走还是往下走，产生总的电位是一样的，也就是说往下走的电流经过R产生一个电压，这个电压反过来通过MOS的跨导电流源产生一个向上的电流，这个机制会进行相互牵制相互调节，直到最后达到一个平衡。</p><p>用数学的语言表达上述的关系就是，</p><p>$$<br>(i_1-i_2)Rg_m=i_2<br>$$</p><p>上面的式子中，$(i_1-i_2)$表示了流入R的电流，作用在$R$上，产生一个电压，通过$g_m$生成向上的电流$i_2$。我们一下子就得到了如下的$i_1$和$i_2$的关系，如下所示，</p><p>$$<br>\frac{i_1}{1+g_mR}=\frac{i_2}{g_mR}<br>$$</p><p>所以可以发现我们可以把$i_1$均分$(1+g_mR)$、把$i_2$均分$(g_mR)$份之后，所得到的element是一样的。这个所谓的element就是我们的$i_x$。</p><p>聪明的读者应该马上可以直接写出我们的$v_x$，如下所示，</p><p>$$<br>v_x=i_x(1+g_mR)r_o+i_xR<br>$$</p><p>我们为了清晰，这里再解释一下上述式子，由于我们把所有的电流都分解为了$i_x$的倍数，如下所示</p><p>$$<br>i_1=(1+g_mR)i_x\<br>i_2=g_mRi_x<br>$$</p><p>所以输出电流为$i_1$作用在$r_o$上的电压降加上$i_1-i_2=i_x$作用在$R$上产生的压降，也就是上面的式子了，稍微归纳一下，我们可以得到输出电阻为，</p><p>$$<br>r_{out}=\frac{v_x}{i_x}=(1+g_mR)r_o+R<br>$$</p><h3 id="模型六"><a href="#模型六" class="headerlink" title="模型六"></a>模型六</h3><p>可以看到模型六的电路图中为在MOS的D上加上电阻$R_D$，栅极接地，要求从源看入的阻抗。</p><img src="/2023/02/02/mos-jian-yi-dian-lu-fen-xi/0bfc5283ce426dd5f8a191663a243cf86d3d4b153c1117abd5b68b77a194d098.png" class="" title="模型六的电路图">  <p>这里给读者一个思考的空间，利用上面模型五的方法可以一模一样地求解出上图所示地输出阻抗，请读者自行尝试求解，之后再往下看我给地解决方案。</p><p>首先先绘制出我想要的可以使用电流观点进行分析的电路草图，如下所示，</p><img src="/2023/02/02/mos-jian-yi-dian-lu-fen-xi/e296b719a7a9389eacb3cca70af69aacdb5db678e586000f2109c3536253e7fe.png" class="" title="模型六的电流法分析草图">  <p>像上图标识的那样，我们先要在想要测试的端口施加一个电流$i_x$，然后读者假想自己是$i_x$，想要钻进阻碍小（电阻小）的通路。我的导师曾经教导过我们，MOS管的源总是最敏感的，所谓最敏感，就是这个地方阻抗最小，很小的电压变化就可以产生巨大的电流变化。所以电流一定先流入的是MOS的源，我们称这个电流为$i_2$，接下去电流会有两个方向，一个是流向$R$，一个是流向$r_o$，我们认为流入$R$以及$r_o$的两路电流最终会达到一个平衡，在这个时候，在输出产生的电压差通过跨导电流源$g_m$产生的电流刚好为$i_2$，上述关系可以使用下面的数学表达式进行表达，</p><p>$$<br>((i_2-i_1)R-i_1r_o)g_m=i_2<br>$$</p><p>简单整理之后我们可以获得下面的表达式，</p><p>$$<br>\frac{i_2}{g_mR+g_mr_o}=\frac{i_1}{g_mR-1}=i_0<br>$$</p><p>上式将$i_2$以及$i_1$分解为$i_0$的倍数，所以我们可以用$i_0$表达出$i_x$和$v_x$</p><p>$$<br>i_x=i_2-i_1=(1+g_mr_o)i_o\<br>v_x=\frac{i_2}{g_m}=\frac{(g_mR+g_mr_o)i_0}{g_m}<br>$$</p><p>马上我们可以得到输出阻抗为，</p><p>$$<br>r_{out}=\frac{v_x}{i_x}=\frac{R+r_o}{1+g_mr_o}<br>$$</p><h3 id="模型七和模型八"><a href="#模型七和模型八" class="headerlink" title="模型七和模型八"></a>模型七和模型八</h3><p>我个人觉得这篇文章接下去的内容在实际中作用不大，可能是本人目前的水平不到，待之后水平上升之后再看看，说不定能有新的体会。</p>]]></content>
      
      
      <categories>
          
          <category> ISSC Magazine阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电路分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FVF跟随器的电路分析</title>
      <link href="/2023/02/02/fvf-gen-sui-qi-de-dian-lu-fen-xi/"/>
      <url>/2023/02/02/fvf-gen-sui-qi-de-dian-lu-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文内容来源于</p><p>“A. Sheikholeslami, “Voltage Follower, Part II [Circuit Intuitions],” in IEEE Solid-State Circuits Magazine, vol. 15, no. 1, pp. 17-19, winter 2023, doi: 10.1109/MSSC.2022.3218083.”</p><h2 id="FVF名称的来源"><a href="#FVF名称的来源" class="headerlink" title="FVF名称的来源"></a>FVF名称的来源</h2><p>下图(a)表示了简单电压跟随器SVF，(b)表示了反转电压跟随器FVF两种电压跟随器。</p><img src="/2023/02/02/fvf-gen-sui-qi-de-dian-lu-fen-xi/8bc3bd30a1296133f77525eb9c61c6995b6b4fa577cc93b9919d027432a9ece2.png" class="" title="跟随器示意图"> <p>其中第一种跟随器大部分人都学过，是三种MOS基本组态的其中一种，常称为源跟随器；第二种跟随器如果没有做过Buffer的人基本不太会了解到，是第一种跟随器的改良方案。</p><p>之所以称为翻转Flipped，作者的原话是：” In fact, moving the current source from the source to the drain of M1 is referred to as flipping, and hence the name FVF”。翻译过来就是原先电流源接在M1的源上；之后电流源接在M1的漏上，电流源的位置发生了翻转，这就是名字的由来。</p><h2 id="FVF的输出跨导"><a href="#FVF的输出跨导" class="headerlink" title="FVF的输出跨导"></a>FVF的输出跨导</h2><p>这里作者使用了一种我从来没有见过的方法求解了跨导，作者实际上求解了短路跨导，先将输出接地，再将电流源置零，之后求解变换之后的电路的输入电压到输出电流的传输函数，如下图所示，</p><img src="/2023/02/02/fvf-gen-sui-qi-de-dian-lu-fen-xi/c5657d450c52ca6e21605b193839dc396ecb0227eca8a570563e88e34dcd5b16.png" class="" title="FVF短路跨导分析">  <p>上图中（b）的Gm表达式很容易能分析出来，如下所示，</p><p>$$<br>G_m=\frac{i_{sc}}{v_{in}}=g_{m1}r_{o1}g_{m2}<br>$$</p><p>此篇文章是主要描述电路直觉的，所以作者在给出公式的基础之上，给出了电路基于公式的工作原理，原文如下，</p><img src="/2023/02/02/fvf-gen-sui-qi-de-dian-lu-fen-xi/2a50ad43473043a6709e3069f7fe893a1289597a38b7a32cc2b7cd254a089290.png" class="" title="FVF基于公式的直觉分析">  <p>简单翻译一下，就是电路的跨导增加了$g_mr_o$倍，作者在这里说，这个倍数的来源是M1管。紧接着，作者给出了一个非常有意思的结论，在FVF电路里面，电流是依靠M2提供的，而不是M1提供的。以前我从没有这样想过，所以我每次看FVF电路的时候都感觉到100分的别扭。接着，作者又说M1的作用仅仅是将输入信号放大了一个倍数之后，将输出给到了M2的栅极，并由M2的跨导进行一个转换。</p><p>这里作者利用之前的一篇文章的结论进行了FVF输出阻抗的推导，具体请看下图，</p><img src="/2023/02/02/fvf-gen-sui-qi-de-dian-lu-fen-xi/65c1cc952a764d4a0d50d594f021578d570e2c77ae699731287774ca6e2c2c39.png" class="" title="FVF输出阻抗推导"> <p>作者先在输出施加了一个大小为$v_x$的信号源，如果可以测量出流入的电流$i_x$，那么就可以获知输出阻抗。</p><p>这里作者先是将M1以及M2剥离开来，认为流入M1的电流为$i_1$，流入M2的电流为$i_2$，由于M1的漏是开路的，所以$i_1=0$。</p><p>接下去单独取出M1分析其漏极和栅极短路到地的时候，$v_x$作用在源的时候，产生的短路电流$i_{sc}$，需要用到前一篇文章的结论，在<a href="https://zbw0520.github.io/2023/02/02/mos-jian-yi-dian-lu-fen-xi/">https://zbw0520.github.io/2023/02/02/mos-jian-yi-dian-lu-fen-xi/</a>这篇文章里给出了具体的解释，这里直接使用这篇文章的结论，</p><p>$$<br>i_{sc}=v_x(g_{me}+\frac{1}{r_o})<br>$$</p><p>上式是给出了短路电流，也就是Norton’s Current Source的电流大小，接下去根据Norton到Thevenin的转换可知，开路电压为Norton电流乘以输出阻抗，也就是下面的式子表达，</p><p>$$<br>v_oc=v_d=i_{sc}r_o=v_x(1+g_{me}r_o)<br>$$</p><p>所以可以看到最终的M1的漏极电压为源极电压的$(1+g_mr_o)$倍，那么M2上产生的电流就用下面的表达式表达，</p><p>$$<br>i_2=v_x(1+g_{me}r_o)g_m+\frac{v_x}{r_o}<br>$$</p><p>如果假设$g_mr_o&gt;&gt;1$，可以得到下面的结论，</p><p>$$<br>i_2=g_{me}r_og_mv_x\<br>r_{out}=\frac{v_x}{i_2}=\frac{1}{g_{me}r_og_m}<br>$$</p><h2 id="FVF的输出增益"><a href="#FVF的输出增益" class="headerlink" title="FVF的输出增益"></a>FVF的输出增益</h2><p>FVF的输出增益大小可以使用$G_mR_{out}$的算法进行计算，计算的结果如下所示，</p><p>$$<br>\frac{V_{out}}{V_{in}}\approx g_mr_og_m\frac{1}{g_{me}r_og_m}=\frac{g_m}{g_{me}}<br>$$</p><p>根据作者的这个系列的前一篇文章，作者说这个增益与SVF也就是普通的Source Follower的增益是一样的。<strong>FVF通过相比SVF更大的跨导和更低的输出阻抗获得了和SVF一样的输出增益。</strong></p><h2 id="FVF的极点分布"><a href="#FVF的极点分布" class="headerlink" title="FVF的极点分布"></a>FVF的极点分布</h2><p>对于SVF的极点分布作者是这样说的，”the signal path from the input to output of the SVF has a single pole, corresponding to the output node”，翻译过来就是SVF仅仅在输出有一个极点。</p><p>对于FVF的极点分布作者是这样说的，”the signal path of the FVF has two poles: one at the output node and one at the gate of M2.”，也就是说FVF在输出和M2的栅上各有一个极点。</p><h2 id="这篇文章的心得"><a href="#这篇文章的心得" class="headerlink" title="这篇文章的心得"></a>这篇文章的心得</h2><p>这篇文章给了我一个全新的视角来审视我做的FVF电路，我以前仅仅是考虑输出阻抗，但是从来没有考虑过输入到输出的传输函数。这里作者使用了将问题进行分解，先求电路的短路电导纳，具体方法是将输出短接到地，在输入施加一个源，测量输出吐出的电流大小，则电路的短路跨导就是$G_m=\frac{i_{sc}}{v_{in}}$。因为我不做信号的放大，所以以前从来没有这么考虑过这个问题。使用这个方法还可以很方便地计算我们的极点。</p><p>并且这篇文章利用戴维南和诺顿等效来计算输出阻抗，也是我以前从来没有接触过的方法，我感觉这个方法应该会极大地简化我们的计算过程。</p>]]></content>
      
      
      <categories>
          
          <category> ISSC Magazine阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Source Follower </tag>
            
            <tag> FVF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADPLL中的DSM</title>
      <link href="/2023/02/01/adpll-zhong-de-dsm/"/>
      <url>/2023/02/01/adpll-zhong-de-dsm/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>为什么要了解DSM（Delta-Sigma Modulator）呢？因为在我们的ADPLL里，存在DCO的量化噪声，这个量化噪声按照最低可实现的最小频率LSB计算，也不能满足我们的应用需求，（见”ADPLL相位域MATLAB模型”这篇文章）这时候，我们考虑采用DSM将带内量化误差水平降低，达到降低抖动的目的。</p><h2 id="了解DSM的前世今生"><a href="#了解DSM的前世今生" class="headerlink" title="了解DSM的前世今生"></a>了解DSM的前世今生</h2><p>此部分内容源自于下面的文献</p><p>B. Razavi, “The Delta-Sigma Modulator [A Circuit for All Seasons],” in IEEE Solid-State Circuits Magazine, vol. 8, no. 2, pp. 10-15, Spring 2016, doi: 10.1109/MSSC.2016.2543061.</p><p>DSM的前一代产物是DM，全程为Delta Modulator，如下图所示，</p><img src="/2023/02/01/adpll-zhong-de-dsm/0df55351e1ee5ebc4cbe061d99c4971be9d51753a8e60873043b6edee9b6e2e4.png" class="" title="Delta Modulator">  <p>假设我们的量化器只提供量化噪声，那么整体环路的传输函数主要由积分器决定，假设积分器有增益$A$，那么积分器的线性模型如下所示，</p><p>$$<br>H_{sum}=\frac{A}{s}<br>$$</p><p>那么环路的输入-输出的传输函数为，</p><p>$$<br>H_{CL}=\frac{1}{1+H_{sum}}=\frac{s}{s+A}<br>$$</p><p>从上述传输函数中可以看到，在$\omega&lt;A$的带宽内，环路对输入是存在一定的衰减的，这就意味着我们的环路对输入信号有低通滤波的特性。</p><p>为了消除这种滤波的特性（差分特性），Inose在1962年将积分器由反馈路径移动至前馈路径上，就产生了我们希望的DSM，即Delta-Sigma Modulator，如下图所示，</p><img src="/2023/02/01/adpll-zhong-de-dsm/80c12b47d747f157804d425f6dfb6efab42d324759ffaabbfd5e8f78e3b868a4.png" class="" title="Delta-Sigma Modulator">  <p>其输入传输函数如下所示，</p><p>$$<br>H_{CL}=\frac{H_{sum}}{1+H_{sum}}=\frac{A}{s+A}<br>$$</p><p>可以看到，在低频处，系统的输入基本没有衰减，在$\omega&gt;A$的带宽处，开始以$20dB/dec$的速度进行衰减，所以，只要我们的输入信号是一定的低频信号，我们就不会破坏输入信号。</p><h2 id="一阶数字DSM"><a href="#一阶数字DSM" class="headerlink" title="一阶数字DSM"></a>一阶数字DSM</h2><p>如下图所示，下面的两张图中的左图表示了数字DSM的硬件实现图，右图表示了数字DSM的z域系统框图。</p><img src="/2023/02/01/adpll-zhong-de-dsm/10e5913b9a0c85a2eb0b9b280e2710fd9e2efe60cf9b740f3246286b9cbea332.png" class="" title="一阶数字DSM的硬件图以及系统框图">  <p>左图中的数字DSM的硬件实现图中，有两个器件组成：1. 全加器。2. 延时单元（寄存器）。这两个器件共同构成了DSM的硬件实现。我个人从DSM的本质可以解释一下这个硬件实现，DSM的本质是算出与目标值的差，再将本次的差留存到下一次累加到结果中，根据这种描述，这个差实际上就是全加器的结果$-E(n)$，经过一个触发器给到下一次的运算。至于这里的负号的原因是因为为了和右侧的线性模型中的符号对应，在右侧的线性模型中，$Y(z)=E(z)(1-z^{-1})+X(z)$，左侧对应的表达式就是 $Y(n)+(-E(n))=X(n)+(-E(n-1))$。读者仔细分析一下就可以明白其中的道理了，上述说法也自然说明了左右两个模型是完全等价的。</p><h3 id="一阶数字DSM的噪声频域特性"><a href="#一阶数字DSM的噪声频域特性" class="headerlink" title="一阶数字DSM的噪声频域特性"></a>一阶数字DSM的噪声频域特性</h3><p>在一阶数字DSM中，噪声的来源主要是$E(z)$，该噪声经过环路整形$1-z^{-1}$之后，会获得一个新的噪声曲线，现在分析环路的噪声频率特性。</p><p>$$<br>H_E(z)=1-z^{-1}<br>$$</p><p>上述表达式描述了环路的噪声传递函数，根据$z$变换与$\omega$变换的等价变换,</p><p>$$<br>z=e^{sT_s}=e^{j\omega T_s}<br>$$</p><p>其中，$T_s$为采样周期，根据上式有如下表达式，</p><p>$$<br>H_E(\omega)=1-e^{-j\omega T_s}=1-cos(-\omega T_s)-jsin(-\omega T_s)$$</p><p>进一步化简有，</p><p>$$<br>H_E(\omega)=1-cos(\omega T_s)+jsin(\omega T_s)<br>$$</p><p>由于我们需要求解函数的噪声功率的传递函数，所以我们对上式进行取模平方操作，有，</p><p>$$<br>|H_E(\omega)|^2=(1-cos(\omega T_s))^2+sin^2(\omega T_s)=2-2cos(\omega T_s)<br>$$</p><p>根据倍角公式，$sin^2\alpha=\frac{1-cos2\alpha}{2}$，有，</p><p>$$<br>|H_E(\omega)|^2=2-2cos(\omega T_s)=4sin^2(\frac{\omega T_s}{2})<br>$$</p><p>所以读者可以看到一阶的DSM的噪声传递函数是一个二次sin函数的1/4，低频处增益低，高频处增益高。下图将$4sin(\frac{2\pi x}{20})$绘制了出来</p><img src="/2023/02/01/adpll-zhong-de-dsm/ad929be430786b179db54e889a739fc05de2aba6a2bb9c3f5b183118d3055071.png" class="" title="Noise Shaping Effect">  <p>从上图中可以看出明显的NoiseShaping效应，这里的Nyquist频率为$\frac{f_s}{2}=5$，假设$f_B$为信号频率，过采样率定义为如下，</p><p>$$<br>OSR=\frac{f_s/2}{f_B}<br>$$</p><p>曲线下方的面积与$M^3$成正比。</p><h2 id="DSM的杂音问题"><a href="#DSM的杂音问题" class="headerlink" title="DSM的杂音问题"></a>DSM的杂音问题</h2><p>假设$Vin=0.001V_{ref}$，那么$D_{out}$的输出就为1个1和999个0，这样循环周期重复，假如有足够的样本，就会有杂音落在我们的信号带内，导致出现额外的杂散，可以采取dithering打散这种周期性，将这些杂音变到我们的噪底上。</p><h2 id="高阶DSM"><a href="#高阶DSM" class="headerlink" title="高阶DSM"></a>高阶DSM</h2><p>高阶DSM的框图如下所示，</p><img src="/2023/02/01/adpll-zhong-de-dsm/15b4ba971fb64e251023e42f9dea4f1adfa11f6098ed55067a1cd5fbd886573b.png" class="" title="二阶DSM的系统框图">  <p>高阶DSM对于输入来说是没有影响的，但是每增大一个DSM的阶数，就会在噪声上乘以一个$(1-z^{-1})$的系数，对噪声进行整形。</p>]]></content>
      
      
      <categories>
          
          <category> ADPLL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADPLL </tag>
            
            <tag> DSM </tag>
            
            <tag> 混合信号电路设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跟着chatGPT学习Python</title>
      <link href="/2023/01/18/gen-zhao-chatgpt-xue-xi-python/"/>
      <url>/2023/01/18/gen-zhao-chatgpt-xue-xi-python/</url>
      
        <content type="html"><![CDATA[<h2 id="废话少说先上代码-accept"><a href="#废话少说先上代码-accept" class="headerlink" title="废话少说先上代码:accept:"></a>废话少说先上代码<span class="github-emoji"><span>🉑</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f251.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h2><h3 id="我自己写的代码"><a href="#我自己写的代码" class="headerlink" title="我自己写的代码"></a>我自己写的代码</h3><pre class=" language-Python"><code class="language-Python">def get_stock_list_from_local():    """    从本地获取数据库中的所有股票列表    :return: stock_list    :rtype: pandas.DataFrame    """    # 初始化DataFrame对象用于存储股票代码信息    column_name = "stock_code"    stock_list = pd.DataFrame(columns=[column_name])    # 获取file_root路径    file_root = "E:\\Code\\project_quantEx\\RFTrader\\data\\price"    # 获取路径下的所有文件名    files = os.listdir(file_root)    for file in files:        if file[0] != "_":            code_baostock = convert_stock_code_2baostock(file[:11])            stock_list = pd.concat([stock_list, pd.DataFrame([code_baostock], columns=[column_name])],                                   ignore_index=True)    return stock_list</code></pre><h3 id="chatGPT给出修改后的代码"><a href="#chatGPT给出修改后的代码" class="headerlink" title="chatGPT给出修改后的代码"></a>chatGPT给出修改后的代码</h3><pre class=" language-Python"><code class="language-Python">def get_stock_list_from_local():    """    从本地获取数据库中的所有股票列表    :return: stock_list    :rtype: pandas.DataFrame    """    # 初始化DataFrame对象用于存储股票代码信息    column_name = "stock_code"    stock_list = pd.DataFrame()    # 获取file_root路径    file_root = "E:\\Code\\project_quantEx\\RFTrader\\data\\price"    # 获取路径下所有csv文件    files = glob.glob(file_root + "/*.csv")    for file in files:        try:            code_baostock = convert_stock_code_2baostock(file[:11])            if not stock_list.isin([code_baostock]).any().stock_code:                stock_list.loc[len(stock_list)] = code_baostock        except Exception as e:            print(f'Error occurred while processing {file} : {e}')    return stock_list</code></pre><h3 id="chatGPT给出的修改意见"><a href="#chatGPT给出的修改意见" class="headerlink" title="chatGPT给出的修改意见"></a>chatGPT给出的修改意见</h3><ol><li>You could use the <code>glob</code> library to get a list of files in the directory, this way you can filter files based on the extension or a pattern, it will be more efficient than the <code>os.listdir()</code> function.</li><li>You could use a try-except block around the <code>convert_stock_code_2baostock(file[:11])</code> function call, to handle any errors that might occur if the file name is not in the expected format, or if the conversion function is not working correctly.</li><li>You could add a check to make sure that the file is a CSV file, before trying to convert the file name to the baostock code format.</li><li>You can use <code>isin()</code> function to filter the stock codes that are already in the stock_list dataframe, so you can skip reading the same file multiple times.</li><li>you can use <code>pd.DataFrame()</code> instead of <code>pd.DataFrame(columns=[column_name])</code> to initialize the dataframe, this way you can use <code>.loc</code> to add data to the dataframe instead of using <code>pd.concat()</code>.</li><li>You could consider adding some logging to the function to log any errors or important events that occur during execution.</li><li>If you have a large amount of data, you can consider using multi-threading or multiprocessing to speed up the process of reading and processing the files.</li><li>You can use <code>pd.to_csv()</code> method to save the dataframe in a csv format.</li></ol><h2 id="逐条分析"><a href="#逐条分析" class="headerlink" title="逐条分析"></a>逐条分析</h2><p>可以看出chatGPT总共给出了8条修改意见<span class="github-emoji"><span>😲</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f632.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，我都震惊了，仔细看来，每一条基本上都有一定的道理，感觉就像是一个非常懂行的老Python工程师在帮我修改代码一样，我感觉到如果不断用这种方式对代码进行学习，我的Python代码能力一定能够得到非常大的增长<span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>✔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>。</p><h3 id="使用glob库对目录中的文件进行读取，并且加入check是否文件是csv格式的功能"><a href="#使用glob库对目录中的文件进行读取，并且加入check是否文件是csv格式的功能" class="headerlink" title="使用glob库对目录中的文件进行读取，并且加入check是否文件是csv格式的功能"></a>使用<code>glob</code>库对目录中的文件进行读取，并且加入check是否文件是csv格式的功能</h3><p>这里，chatGPT给出的建议是使用<code>glob</code>中的方法对文件进行读取，使用这个的好处是，可以根据文件名进行筛选，可以不用在后面的代码中对读取到的字符串进行筛选。这里给出我写的和chatGPT给出的代码片段。</p><pre class=" language-Python"><code class="language-Python"># 我写的files = os.listdir(file_root)# chatGPT写的files = glob.glob(file_root + "/*.csv")</code></pre><p>可以看到，这里的<code>glob</code>方法直接对读取文件的形式进行了筛选，我在代码后面还使用了if分支用于判断文件名字符串是不是我想要的文件名，因为一般Python Package中一般会有一个额外的文件叫做<code>__init__.py</code>，这个文件是起到什么作用的呢？</p><img src="/2023/01/18/gen-zhao-chatgpt-xue-xi-python/80998c9c5f379496231cfd251555bf62b02aae3edf230e2e75eace61caad3531.png" class="" title="__init__.py文件的作用">  <p>从图中我们可以看到，chatGPT说这个文件有三个作用：</p><ol><li>作为一种标识用于表明本文件夹是一个Python包，当Python解释器遇到这种文件夹时，会认为这是一个包，并且将会在这个包中搜寻需要引入代码的模块。简单来说，就是一种包的标识符，告诉Python解释器，我是个包，快来分析我！<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>用来定义包的初始化代码，这种初始化代码将会在包第一次被引入的时候执行。在你想要给定一些全局变量或者进行一些初始化操作的时候非常有用。</li><li>同时这个文件也可以用来定义包的全局API。这个我暂时还不太懂，可以之后再看看。<span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li></ol><p>说完了这个文件，我们再说回我们的代码，可以看到这里chatGPT给出了一个方法，帮助我们一步解决读取数据、筛选文件的操作，提升了效率，至于这个包读取文件的速度是不是更快，还需要进一步验证，这里我们可以问问chatGPT。</p><img src="/2023/01/18/gen-zhao-chatgpt-xue-xi-python/77ac7b8d89154e1f55c709fb5d09c6160df50fea18c685278c7e2a203dc46455.png" class="" title="chatGPT给出的os.listdir()与glob.glob()的区别"><p>总结下来呢就是，在性能上，如果没有筛选要求的，使用<code>os.listdir(file_root)</code>是最好的，因为这个更快一些，但是如果你有筛选需求的话，<code>glob.glob(file_root + "/*.csv")</code>是更好的选择。</p><p>所以，这里，我们学到了一个筛选文件名获取文件的更好方式，就是使用<code>glob.glob()</code>方法，其内部参数使用字符串的形式，内部加入通配符来进行匹配。</p><h3 id="使用try-except模块来防止出现异常情况"><a href="#使用try-except模块来防止出现异常情况" class="headerlink" title="使用try-except模块来防止出现异常情况"></a>使用try-except模块来防止出现异常情况</h3><p>这里chatGPT推荐我们使用try-except模块来对异常进行处理，具体的代码区别如下所示。</p><pre class=" language-Python"><code class="language-Python"># 我写的if file[0] != "_":    code_baostock = convert_stock_code_2baostock(file[:11])    stock_list = pd.concat([stock_list, pd.DataFrame([code_baostock], columns=[column_name])],                            ignore_index=True)# chatGPT写的try:    code_baostock = convert_stock_code_2baostock(file[:11])    if not stock_list.isin([code_baostock]).any().stock_code:        stock_list.loc[len(stock_list)] = code_baostockexcept Exception as e:    print(f'Error occurred while processing {file} : {e}')</code></pre><p>那么为什么要使用try-except模块呢？我们可以继续来问问chatGPT。<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><img src="/2023/01/18/gen-zhao-chatgpt-xue-xi-python/ce072fefca11b1c79f44e44573356fd75c7f1acf32c6579f74b96b4d2c5f67ef.png" class="" title="chatGPT解释为什么要使用try-except模块">  <p>总结下来呢，就是两点，一个是使用抛出异常的操作可以方便你deBug的时候迅速定位错误的位置，方便你deBug。这一点我深有体会，我在deBug代码的时候，因为我自己设计的代码没有try-except操作，所以我通常会定位错位置。另一个重要原因是这会帮助你防止程序出错之后立马就停止运行了，帮助程序把错误的代码分离出来。总的来说呢，使用try-except模块是一个非常好的代码习惯。</p><h3 id="使用isin-方法防止出现重复的stock-code问题"><a href="#使用isin-方法防止出现重复的stock-code问题" class="headerlink" title="使用isin()方法防止出现重复的stock_code问题"></a>使用isin()方法防止出现重复的stock_code问题</h3><p>这里chatGPT推荐我们加入额外的判断语句，来判断我们要添加进stock_list的数据是不是会与已有数据产生重复，如果不重复，则执行在stock_list尾部添加股票代码的操作，这里贴出代码。</p><pre class=" language-Python"><code class="language-Python"># 我写的stock_list = pd.concat([stock_list, pd.DataFrame([code_baostock], columns=[column_name])],                                   ignore_index=True)# chatGPT写的if not stock_list.isin([code_baostock]).any().stock_code:    stock_list.loc[len(stock_list)] = code_baostock</code></pre><p>可以看出，chatGPT加入了额外的分支，这是用于检查我们的code_baostock的code是否在我们的stock_list里的，具体可以看下面chatGPT给出的说明。</p><img src="/2023/01/18/gen-zhao-chatgpt-xue-xi-python/1eb272b7b87a66bf7156526d04e1674d08d0f8220f4b5fdbe958e3cb84db62ac.png" class="" title="chatGPT说明any()以及isin()方法的作用">  <p>总的来说呢，就是stock_list.isin([code_baostock])这个其实是生成了一个<code>dataFrame</code>。我以前一直以为这个语句是产生一个值…<span class="github-emoji"><span>😓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f613.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，这里我也是看了好半天才看明白的。所以这个<code>dataFrame</code>没有办法直接进行判断的，因为我们的逻辑是只要有一个符合，我们就不执行下面的操作，所以这里使用了<code>any()</code>方法，是为了提取<code>dataFrame</code>中的<code>boolean</code>信息，进行逻辑判断，最后再选取对应的列<code>.stock_code</code>，产生最终的布尔值。</p><h3 id="使用-loc-方法进行DataFrame数据的添加"><a href="#使用-loc-方法进行DataFrame数据的添加" class="headerlink" title="使用.loc()方法进行DataFrame数据的添加"></a>使用<code>.loc()</code>方法进行DataFrame数据的添加</h3><p>这里chatGPT推荐我们使用<code>.loc()</code>对DataFrame数据进行追加，下面是代码片段。</p><pre class=" language-Python"><code class="language-Python"># 我写的stock_list = pd.concat([stock_list, pd.DataFrame([code_baostock], columns=[column_name])],                                   ignore_index=True)# chatGPT写的stock_list.loc[len(stock_list)] = code_baostock</code></pre><p>可以看到这里的逻辑是再最后一行添加code_baostock数据，这一部分值得好好研究，因为loc的用法我其实还不是特别清晰，之前使用这个方法的时候，经常会出现各种异常，所以这里应该要解决一下。</p><img src="/2023/01/18/gen-zhao-chatgpt-xue-xi-python/902c4c7d04dda5a4761263db6fb65ede05c3ed4754f8460e58b335725643cbb1.png" class="" title="picture 6">  <p>这里可以看到，官方源码中的注释给出了具体的解释说明，我总结成如下几点</p><pre class=" language-Python"><code class="language-Python">df.loc['viper'] # 返回一行数据，数据格式为Series，注意这里数据为原先DataFrame中的一行数据，这里的入参也是行的标签df.loc[['viper', 'sidewinder']] # 返回两行数据，数据格式为DataFrame，入参是两行标签组成的Seriesdf.loc['cobra', 'shield']   # 返回行标签为'cobra'，列标签为'shield'的数据</code></pre><p>一个重要的观察是，loc一般需要两个参数，才能指定DataFrame中的具体位置的数据，否则返回的肯定是数据阵列；并且loc方法的入参先输入的一定是行标签，所以需要注意的是不要搞错了。最后需要注意的是，loc方法数输入模式是<code>[]</code>不要搞错成<code>()</code>了。</p><h3 id="最后三条（有了可以锦上添花，但没有实现）"><a href="#最后三条（有了可以锦上添花，但没有实现）" class="headerlink" title="最后三条（有了可以锦上添花，但没有实现）"></a>最后三条（有了可以锦上添花，但没有实现）</h3><ol><li>可以再执行的过程中添加日志功能？这个好像不太需要，因为我们的方法非常简单，没有特别的对日志的需求。当然，你要说一定要添加的话，可以添加日志说明对csv文件进行更改的操作之类的，这个可以先不着急实现。</li><li>如果数据量大的话，可以加入多线程操作，来加快文件的调取。我觉得这个是有必要的，增加速度也是一个考虑之一，但是我之后可能考虑采用关系型数据库MySQL或者非关系型数据库MongoDB，目前csv文件存储数据的方案只是一个暂时的方案。</li><li>使用pd.to_csv()方法对数据进行存放。目前暂时没有这个需求<span class="github-emoji"><span>❌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li></ol>]]></content>
      
      
      <categories>
          
          <category> 代码重构与解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> pandas.DataFrame </tag>
            
            <tag> 代码重构 </tag>
            
            <tag> chatGPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pandasDataFrame使用简介</title>
      <link href="/2023/01/17/pandasdataframe-shi-yong-jian-jie/"/>
      <url>/2023/01/17/pandasdataframe-shi-yong-jian-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="写再最前面"><a href="#写再最前面" class="headerlink" title="写再最前面"></a>写再最前面</h2><p>最近再实现我的RFTrader量化工具的时候，使用pandas.DataFrame的类来封装我的标的数据，在使用的过程中有许多不清晰的地方，我在这里做一个整理，希望在我之后的编程过程中，如果有不熟悉的地方，可以考虑翻过头来看看，到底是什么问题，并且总结一下，看看还存在哪些问题，方便之后在编程过程中，少犯错误。</p><h2 id="Intro-to-DataFrames"><a href="#Intro-to-DataFrames" class="headerlink" title="Intro to DataFrames"></a>Intro to DataFrames</h2><p>这里的内容源自于<a href="https://www.youtube.com/watch?v=e60ItwlZTKM" target="_blank" rel="noopener">https://www.youtube.com/watch?v=e60ItwlZTKM</a>，这个视频中，详细讲解了12个实用的pandas.DataFrame案例，我看完之后觉得之前很多的问题都明确了，并且有所收获，这里记录一下。</p><h3 id="pandas与NumPy的关系"><a href="#pandas与NumPy的关系" class="headerlink" title="pandas与NumPy的关系"></a>pandas与NumPy的关系</h3><p>pandas是基于NumPy实现的，所有pandas库会引用NumPy的包。</p><img src="/2023/01/17/pandasdataframe-shi-yong-jian-jie/5336a731f4bdc63724e989c073aa7b4a6b2f45022856160dd901a2ee272e00b0.png" class="" title="pandas与NumPy的关系">  <h3 id="pandas与NumPy的区别"><a href="#pandas与NumPy的区别" class="headerlink" title="pandas与NumPy的区别"></a>pandas与NumPy的区别</h3><img src="/2023/01/17/pandasdataframe-shi-yong-jian-jie/08f07d2ac12fa5d5e3db3a2b79062511f8d0ea6d2c992b86094e9c23fa367aa2.png" class="" title="pandas与NumPy的区别">  <h3 id="pandas的官方链接"><a href="#pandas的官方链接" class="headerlink" title="pandas的官方链接"></a>pandas的官方链接</h3><p><a href="https://pandas.pydata.org/" target="_blank" rel="noopener">https://pandas.pydata.org/</a></p><h3 id="pandas-cheatsheet链接"><a href="#pandas-cheatsheet链接" class="headerlink" title="pandas cheatsheet链接"></a>pandas cheatsheet链接</h3><p><a href="https://pandas.pydata.org/Pandas_Cheat_Sheet.pdf" target="_blank" rel="noopener">https://pandas.pydata.org/Pandas_Cheat_Sheet.pdf</a></p><h3 id="从csv文件中读取数据并打包为DataFrame对象"><a href="#从csv文件中读取数据并打包为DataFrame对象" class="headerlink" title="从csv文件中读取数据并打包为DataFrame对象"></a>从csv文件中读取数据并打包为DataFrame对象</h3><pre class=" language-Python"><code class="language-Python">file_name = "Data.txt"df.pd.read_csv(file_name)</code></pre><h3 id="获取前几个数据、后几个数据"><a href="#获取前几个数据、后几个数据" class="headerlink" title="获取前几个数据、后几个数据"></a>获取前几个数据、后几个数据</h3><pre class=" language-Python"><code class="language-Python">df.head()   # 获取前5个数据df.tail(3)  # 获取后3个数据</code></pre><h3 id="获取DataFrame的数据类型信息、索引信息、列名信息、值信息"><a href="#获取DataFrame的数据类型信息、索引信息、列名信息、值信息" class="headerlink" title="获取DataFrame的数据类型信息、索引信息、列名信息、值信息"></a>获取DataFrame的数据类型信息、索引信息、列名信息、值信息</h3><pre class=" language-Python"><code class="language-Python">print(df.dtypes)print(df.index)print(df.columns)print(df.values)    # 一般不会这样获取DataFrame的值</code></pre><h3 id="获取数据的统计信息"><a href="#获取数据的统计信息" class="headerlink" title="获取数据的统计信息"></a>获取数据的统计信息</h3><pre class=" language-Python"><code class="language-Python">df.describe()   # 会返回均值、标准差、最小值、最大值等统计信息，很有用</code></pre><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><pre class=" language-Python"><code class="language-Python">df.sort_values('record_high',ascending=False)   # 对列名为record_high的数据进行降序排序</code></pre><h3 id="对数据进行裁剪"><a href="#对数据进行裁剪" class="headerlink" title="对数据进行裁剪"></a>对数据进行裁剪</h3><pre class=" language-Python"><code class="language-Python">df.avg_low                          # 返回列名为avg_low的数据df['avg_low']                       # 返回列名为avg_low的数据，同上df[2:4]                             # 返回第3行和第4行数据df[['avg_low','avg_high']]          # 返回列名为'avg_low','avg_high'的两列数据df.loc[:,['avg_low','avg_high']]    # 返回列名为'avg_low','avg_high'的两列数据，同上df.loc[9,['avg_precipitation']]     # 返回列名为'avg_precipitation'以及第10行的数据df.iloc[3:5,[0,3]]                  # 返回第4行和第5行数据，返回第0行~第2行数据 loc. by index</code></pre><h3 id="对数据进行过滤筛选（filtering）"><a href="#对数据进行过滤筛选（filtering）" class="headerlink" title="对数据进行过滤筛选（filtering）"></a>对数据进行过滤筛选（filtering）</h3><pre class=" language-Python"><code class="language-Python">df[df.avg_low > 1.0]                        # 返回df中avg_low中比1大的数据df[df['month'].isin(['Jun','Jul','Aug'])]   # 返回列month中数据为'Jun','Jul','Aug'的数据</code></pre><h3 id="对DataFrame中的数据进行赋值操作（Assignment）"><a href="#对DataFrame中的数据进行赋值操作（Assignment）" class="headerlink" title="对DataFrame中的数据进行赋值操作（Assignment）"></a>对DataFrame中的数据进行赋值操作（Assignment）</h3><pre class=" language-Python"><code class="language-Python">df.loc[9,['avg_precipitation']] = 101.3       # 将列名为'avg_precipitation'，第10行的单元格赋值为101.3df.loc[9,['avg_precipitation']] = np.nan      # 将列名为'avg_precipitation'，第10行的单元格赋值为nan(Not A Number)df.loc[:,'avg_low'] = np.array([5]*len(df))   # 将列名为'avg_low'下的所有数据赋值为5df['avg_day'] = (df.avg_low+df.avg_high)/2    # 新增列，列名为'avg_day'，其值为avg_high列与avg_low的均值</code></pre><h3 id="对列进行重命名"><a href="#对列进行重命名" class="headerlink" title="对列进行重命名"></a>对列进行重命名</h3><pre class=" language-Python"><code class="language-Python">df.rename(columns = {'avg_precipitation':'avg_rain'}, inplace=True) # 将原名为'avg_precipitation'新命名为'avg_rain'，并且在原df中生效更改df = df.rename(columns = {'avg_precipitation':'avg_rain'})  # 功能同上，inplace=True相当于df = df.rename()</code></pre><h3 id="将数据写入csv文件"><a href="#将数据写入csv文件" class="headerlink" title="将数据写入csv文件"></a>将数据写入csv文件</h3><pre class=" language-Python"><code class="language-Python">df.to_csv('Data.csv')</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> pandas.DataFrame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADPLL相位域MATLAB模型</title>
      <link href="/2022/12/28/adpll-xiang-wei-yu-matlab-mo-xing/"/>
      <url>/2022/12/28/adpll-xiang-wei-yu-matlab-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面-heavy-check-mark"><a href="#写在前面-heavy-check-mark" class="headerlink" title="写在前面:heavy_check_mark:"></a>写在前面<span class="github-emoji"><span>✔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h2><p>本文章主要的目的是为了给ADPLL的MATLAB模型做一个注释，并且解释编写代码过程中遇到的问题，以后我可能将代码上传到Github的私有仓库中，方便后期的使用。</p><h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><p>需要先在MATLAB中，根据Leeson Equation计算出需要的PLL带宽，其实Leeson公式说了那么玄幻的东西，根本上来说就是下面的式子，</p><p>$$<br>L(\Delta \omega)=\alpha\frac{\omega^2}{\Delta \omega^2}<br>$$</p><p>Leeson公式所表示的量的单位为$dBc/Hz$，所以从本质上来说，指的是功率谱密度，之所以有自变量的平方在分母上，一方面是因为VCO中存在$\frac{1}{s}$的项，另一方面，Leeson公式表示的量为功率了，给平方了。</p><p>通过Leeson公式可以根据GSM中的$-162dBc/Hz$的Reference值反推在特定信号频率$\omega$下，VCO或者说DCO的相位噪声估计表达式，进而根据给定的均方根抖动(Jitter RMS)得出PLL所需要的带宽。</p><p>在得到PLL的带宽之后，PLL的带内噪声也马上就可以知道了，直接从Leeson公式上获得即可。</p><h3 id="给定ADPLL参数"><a href="#给定ADPLL参数" class="headerlink" title="给定ADPLL参数"></a>给定ADPLL参数</h3><p>此处给定了ADPLL设计需要的一些参数：</p><ul><li>fR：参考频率，设定为100MHz；</li><li>fV：可变频率，设定为30GHz；</li><li>FCW：频率控制字，本质上为$\frac{fV}{fR}$，这里为300；</li><li>jitter_rms：抖动的均方根值，设定为50fs；</li><li>PhaseMargin：环路的相位裕度，设定为60度（角度值）。</li></ul><h3 id="计算ADPLL的DCO相位噪声谱密度alpha-L-val"><a href="#计算ADPLL的DCO相位噪声谱密度alpha-L-val" class="headerlink" title="计算ADPLL的DCO相位噪声谱密度alpha_L_val"></a>计算ADPLL的DCO相位噪声谱密度alpha_L_val</h3><p>此处计算的方法是待定系数法，由于DCO器件的热噪声的功率谱密度由DCO积分后，由下式表达，</p><p>$$<br>L(\Delta\omega)=\frac{\alpha_L\omega_v^2}{\Delta\omega^2}=\frac{\alpha(\omega_v)}{\Delta\omega}<br>$$</p><p>这里有几点需要注意的，首先是$\alpha(\omega_v)$是可变频率函数，对应不同频率处的相位噪声谱密度是不一样的，所以这一点需要提前考虑在内，否则会导致最后的数据出错；另一个问题是这个函数要确定到底采用角频率还是使用Hz作为频率的单位，因为在之后做积分进行带宽计算的过程中，不同的单位会导致结果相差一个$2\pi$，具体来说，可以用下面的式子进行说明，</p><p>$$<br>\int^\infty_{BW}L(\Delta\omega)d\Delta\omega=\int^\infty_{BW*2\pi}\frac{\alpha_L\omega_V^2}{\Delta\omega^2}d\Delta\omega=2\pi\int^\infty_{BW}\frac{\alpha_L f_V^2}{\Delta f^2}d\Delta f<br>$$</p><p>所以，我们需要在这里仔细规定频率到底是以角频率为单位进行计算，还是以Hz为单位进行计算的，在整体的程序中，要保持一致，以防止出现错误。</p><h3 id="计算ADPLL的带宽"><a href="#计算ADPLL的带宽" class="headerlink" title="计算ADPLL的带宽"></a>计算ADPLL的带宽</h3><p>这里采用待定系数法，先待定出$\alpha_L$的大小，再进一步代入我们想要的中心频率大小，就可以得到一个以频偏$\Delta\omega$为自变量的噪声功率谱密度的函数$L(\Delta\omega)$了。为了得到其与抖动$jitter$的关系，我们可以使用下面的关系，</p><p>$$<br>jitter_{rms}2\pi f_V=\sqrt{\int^\infty_{BW}\frac{\alpha_L f_V^2}{\Delta f^2}d\Delta f}<br>$$</p><p>上面的关系的本质是，抖动与相位噪声功率的rms值是通过斜率$2\pi f_V$联系起来的，这一点再ADI的一篇博客中有做解释，这里就不再进行解释了，本质上就是一个求导的过程。</p><p>另外，此处进行计算使用的$jitter_{rms}$的大小为$50fs$，带内$25fs$（TDC量化噪声）与带外$25fs$（DCO热噪声）均匀分配，得到最终的结果。这里需要注意的是，这里考虑的还不够完善，因为根据这种计算的出的TDC量化噪声不仅仅再带内有$25fs$的jitter贡献，还有带外$25fs$的jitter贡献。</p><p>其实，读者仔细思考一下，这里的带内&amp;带外$25fs$的抖动总和为$50fs$的描述本身就是有问题的，因为抖动本身就是标准差，对于标准差而言，两个$25fs$标准差的和为$25\sqrt{2}fs$，所以我们实际应该设计的抖动大小为$25\sqrt{2}\approx35fs$。</p><p>最终程序计算出来的ADPLL的带宽应该在$611kHz$处。</p><h3 id="计算ADPLL的环路参数"><a href="#计算ADPLL的环路参数" class="headerlink" title="计算ADPLL的环路参数"></a>计算ADPLL的环路参数</h3><p>在计算ADPLL的环路参数的时候，需要考虑闭环传输函数对噪声的影响，目前我还没有对这个进行考虑。整个环路的图如下图所示，</p><img src="/2022/12/28/adpll-xiang-wei-yu-matlab-mo-xing/867e120588e5c0733ff93461108a6c3924b67cd3a7b3d08aa2249571c3e7e2af.png" class="" title="环路信号流图">  <p>可以看到的是，本系统的滤波器为一阶滤波器，其传输函数如下所示，</p><p>$$<br>TF_{filter}=\alpha+\frac{\rho f_R}{s}<br>$$</p><p>可以看到这个滤波器贡献了一个<code>@origin</code>的极点；贡献了一个位于$\frac{\rho f_R}{\alpha}$的零点。</p><p>DCO的传输函数如下所示，</p><p>$$<br>TF_{DCO}=\frac{f_R2\pi}{s}<br>$$</p><p>可以看到DCO贡献了一个<code>@origin</code>的极点。</p><p>电路的总开环增益为，</p><p>$$<br>OLTF = \frac{f_R}{s}(\alpha+\frac{\rho f_R}{s})<br>$$</p><p>接下去需要根据两个条件解出$\alpha$和$\rho$的值，两个条件分别是</p><ol><li>BW处增益为$0dB$</li><li>BW处相位为$60$</li></ol><p>由于BW的值在先前的模块中已经求解出来了，为$611kHz$，所以两个条件一定可以解出两个未知数，如下式所示</p><p>$$<br>\begin{cases}<br>(\alpha f_RBW2\pi)^2+\rho^2f_R^4=(BW2\pi)^4 \<br>\frac{\alpha BW2\pi}{\rho f_R}=tan(\frac{PM\pi}{180})<br>\end{cases}<br>$$</p><p>代入参数之后可得$\alpha=3.32\times10^{-2}$，$\rho=7.3659\times10^{-4}$</p><h3 id="计算TDC的量化噪声水平以及精度"><a href="#计算TDC的量化噪声水平以及精度" class="headerlink" title="计算TDC的量化噪声水平以及精度"></a>计算TDC的量化噪声水平以及精度</h3><p>此处的TDC量化噪声是根据带宽处的DCO热噪声引起的相位噪声曲线的插值给出的，用数学表达式如下所示，<strong>注意</strong>此处为单边谱，并且相位噪声自变量的单位为Hz。</p><p>$$<br>S_{N,TDC}=L(BW)<br>$$</p><p>这里通过计算可以得知$S_{N,TDC}=-101.3947dB$，<strong>注意</strong>这里是单边谱的功率谱密度。</p><p>接下去我们希望计算一下TDC需要的绝对精度大小，这里我们就需要推导一下TDC的量化噪声。量化噪声功率一般由下式表达，</p><p>$$<br>NoisePower_{Q}=\frac{LSB^2}{12}<br>$$</p><p>在TDC中，LSB就是我们的时间精度，我们可以指定时间精度为变量$t_{res}$，代入上述公式可以知道我们TDC的”噪声”功率大小，如下所示，</p><p>$$<br>NoisePower_{TDC}=\frac{t_{res}^2}{12}<br>$$</p><p>这个地方需要说明的是，这里的”功率”没有实际的意义，只是一个统计上方差的概念，现在我们把方差变为标准差，</p><p>$$<br>\sigma_{TDC}=\frac{t_{res}}{\sqrt{12}}<br>$$</p><p>接下去使用抖动rms（标准差）和相位噪声rms的关系有，</p><p>$$<br>\sigma_\phi=2\pi f_V\sigma_{TDC}=\frac{2\pi f_V t_{res}}{\sqrt{12}}<br>$$</p><p>量化噪声总功率均匀分布在奈奎斯特带内，即$[-\frac{f_s}{2},\frac{f_s}{2}]$之间，所以单边谱密度可以用如下表达式，</p><p>$$<br>L=\frac{\sigma_\phi^2}{f_s/2}=\frac{(2\pi f_Vt_{res})^2}{6f_s}<br>$$</p><p>所以可以反向导出$t_{res}$关于L（单边谱密度）的函数，如下所示</p><p>$$<br>t_{res}=\frac{\sqrt{6f_sL}}{2\pi f_V}<br>$$</p><p>通过计算可知，$t_{res}=1.108ps$</p><p>此外，读者还需要关注TDC量化噪声到输出的传输函数，因为TDC量化噪声作用在鉴相器的位置，所以可以认为是输入，其传输函数就是整体的闭环传输函数，如下所示，</p><p>$$<br>CLTF=\frac{OLTF}{1+OLTF}=\frac{\alpha f_Rs+\rho f_R^2}{s^2+\alpha f_Rs+\rho f_R^2}<br>$$</p><p>在相位裕度为$PM=60$时，其BODE图如下所示，</p><img src="/2022/12/28/adpll-xiang-wei-yu-matlab-mo-xing/a5ac739e42a8b1b520490d55e5fa3504eff7978e602abe89459b3f3ee4e99b55.png" class="" title="picture 2">  <p>可以看到在带宽处有3dB左右的突起，这部分有可能会影响到最后的积分大小，需要仔细考虑，这一部分我还没有进行考虑，不过就目前的结果来看，对于jitter的影响不大，如果就这个理想的传输函数来说，也就增加了$3fs$的均方根抖动。</p><p>最终的噪声谱密度如下图所示，</p><img src="/2022/12/28/adpll-xiang-wei-yu-matlab-mo-xing/729e3df93530bfe0cdd5cad4a02fab986ba3a6659943cef91a806d1007453a84.png" class="" title="TDC量化噪声@输出的噪声谱密度">  <p>可以看到TDC的量化噪声谱密度在带内表现为平带噪声，但是在带外会以$20dB/dec$的速度进行滚降，这个速度太过缓慢，会导致带外的TDC噪声不能被有效抑制，这部分噪声与DCO的热噪声相当了，肯定是不行的。解决的办法可以是采用高阶环路滤波器实现，目前使用的环路滤波器还是一阶的，可以采用二阶的环路滤波器实现。</p><h3 id="计算DCO量化噪声"><a href="#计算DCO量化噪声" class="headerlink" title="计算DCO量化噪声"></a>计算DCO量化噪声</h3><p>DCO的量化噪声功率也可以使用TDC一样的量化噪声功率进行计算，如下所示，</p><p>$$<br>\sigma_{DCO}^2=\frac{f_{res}^2}{12}<br>$$</p><p>这一部分量化噪声的功率其实是均匀分布在奈奎斯特带内，即$[-\frac{f_s}{2},\frac{f_s}{2}]$之间，所以单边谱密度可以由下式表示，</p><p>$$<br>L=\frac{\sigma_{DCO}^2}{f_s/2}=\frac{f_{res}^2}{6f_s}<br>$$</p><p>要注意DCO量化噪声作用的位置我还没有非常明确，我目前是加在振荡器前，但是加在normalization之后，这样做的原因还是不是非常明确。</p><p>以上述位置施加量化噪声之后，我们需要知道传输函数的表达式，该位置到输出的开环传输函数为，</p><p>$$<br>OLTF_{DCO}=\frac{2\pi}{s}<br>$$</p><p>其闭环传输函数就是在上式的基础之上加上一个如下的系数即可，</p><p>$$<br>CLTF_{DCO}=\frac{OLTF_{DCO}}{1+OLTF}=\frac{s^2}{s^2+\alpha f_Rs+\rho f_R^2}\frac{2\pi}{s}=\frac{2\pi s}{s^2+\alpha f_Rs+\rho f_R^2}<br>$$</p><p>我们可以分析一下这个闭环传输函数的系数，当频率达到环路带宽之后，基本上就不会对噪声产生影响了，唯一有影响的就是开环的增益，也就是$20dB/dec$的滚降；然而在带内，我们可以看到，噪声会以$20dB/dec$速度滚升，这是由于<code>@origin</code>的零点造成的。</p><p>其实带内的对于噪声的抑制也不够，根据之后的仿真结果，带内的DCO量化噪声会额外产生$30fs$的rms抖动，造成总的rms抖动从$36fs$上升到$47fs$。所以呢，可以考虑采用一些其他的计数来抑制带内的DCO量化噪声，可以考虑DSM，使用抖动将低频量化噪声功率抖到高频去，再通过环路滤波器滤除这一部分噪声功率。注意：以上分析都是按照我自己的理解分析的，合理性还需要进一步考证。</p><h3 id="将计算出来的参数代入Simulink模型中进行分析"><a href="#将计算出来的参数代入Simulink模型中进行分析" class="headerlink" title="将计算出来的参数代入Simulink模型中进行分析"></a>将计算出来的参数代入Simulink模型中进行分析</h3><p>本程序的特色在于可以可视化地进行建模，即使用Simulink进行可视化的相位域建模。Simulink模型的主框图如下所示，</p><img src="/2022/12/28/adpll-xiang-wei-yu-matlab-mo-xing/3d850b6abf51488b23ac3e032a0fcd5d297005a0a3e093e34d0ba9c49c953728.png" class="" title="SimulinkADPLL相位域模型图">  <p>这一部分模型可以看到不是特别复杂，主要包括了鉴相器、环路滤波器和DCO，噪声是通过<code>Band-Limited White Noise</code>的模块产生的，最后的输出由<code>To Workspace</code>模块抓取并以数组形式返回到Matlab工作区，基本的模型就是这样的，下面我们来仔细看看这些模块建模的时候是怎么考虑的，并且有哪些需要注意的。</p><p>首先一个要注意的是，本模型是相位域模型，理论上，一个sinWave的信号的相位是不断增长的，但是这里却采用了阶跃信号作为相位域模型的输入激励，有同学可能就要问了，为什么这里不是采用ramp信号呢？并且最后采集的Signal理论上也是一个阶跃信号，你怎么能够分析出相位噪声这种信息呢？</p><p>其实在一开始建模的时候，本人采取的策略是再输入使用阶跃信号模拟频率的变化，然后利用一个积分器产生对应的相位信息，再用这个相位信息作为模型的输入，输出的相位信息通过一个<code>sin</code>模块之后产生对应的sinWave，再将sinWave做fft之后采取其主频的边带放大后作为PhaseNoise的功率谱密度。当然，这是可行的，但代价是非常长的仿真时间，以及巨大的计算量。</p><p>读者可以想象，对一个$30GHz$的信号的相位，这个相位信息的数据规模会随着时间的增长而增长，并且由于Signal需要识别到$30GHz$的正弦波，频谱的范围就要扩展到至少60GHz，假设$100GHz$的采样率，对于时域来说，时间分辨率就要为$10ps$，并且频谱的分辨率至少为$10KHz$，因为我们需要足够低频的分量才能看清带内噪声，在这个前提下，时域数据的时间长度要至少为$100\mu s$，这个的数据量消耗是非常巨大的，并且会导致仿真时间到一个无法接受的长度。</p><p>在这个背景下，这个模型采用了一种技巧，避免了采样$30GHz$信号的操作，而是直接对一个DC量进行采样，这一部分其实可以进行数学层面的推导，在这里，我仔细推导一下。</p><p>在推导之前，先要熟悉一下我们之前高数学过的欧拉公式(Euler’s Formula)，如下所示，</p><p>$$<br>e^{j\omega t}=cos(\omega t)+jsin(\omega t)<br>$$</p><p>欧拉公式的复$e$指数函数的傅里叶变换对应的就是$\delta$函数，所以可以认为我们傅里叶变换里的building block在频域上是$\delta$函数而在时域上就是我们的复$e$指数，如下</p><p>$$<br>e^{j\omega_0 t}=2\pi\delta(\omega-\omega_0)<br>$$</p><p>在图形上可以认为是右半边频谱的一根单独的谱线，我们可以想象，左侧时域中的相位为$\omega_0t$，所以一种常用的方法就是想象我们的频谱是一个三维坐标，三个维度的信息分别是$\omega$频率、$Re$实数轴、$Im$复数轴，实数轴与复数轴共同决定了我们的相位信息（$arctan\frac{Im}{Re}$）以及幅度信息（$\sqrt{Im^2+Re^2}$）。</p><p>所以我们可以使用Phasor Diagram（三维坐标）来理解我们的信号。我们只需要记住一个结论，就是$sin$函数比$cos$函数要滞后$90$，体现在频谱上就是sin的起始Phasor向量是$1\angle0$，而cos的起始Phasor向量是$1\angle-90$。这样我们又多了一种全新的方法来理解我们的欧拉公式，想要获得位于右半轴的$e^{j\omega t}$的频谱，我们只需要将$sin$函数提前$90$即可，在复数域中，表示这一操作只需要乘以$1\angle 90 =j$即可，可以看到和我们的欧拉公式是完全符合的。</p><p>$$<br>e^{j\omega t}=cos(\omega t)+jsin(\omega t)<br>$$</p><p>假如我们现在在有用信号上叠加了一个$\phi(t)$，如下所示</p><p>$$<br>Signal=sin(2\pi f_Vt+\phi(t))<br>$$</p><p>利用和差化积公式，可以进行分解，得到下面的表达式，</p><p>$$<br>Signal=sin(2\pi f_Vt)cos(\phi(t))+cos(2\pi f_Vt)sin(\phi(t))<br>$$</p><p>如果我们的$\phi(t)$足够小，在我们的这个情况中是符合的，因为</p><p>$$<br>3\sigma_\phi=2\pi f_Vjitter_{rms}=3\cdot2\pi(30\times10^9)(50\times10^{-15})\approx9.42\times10^{-3}\times3\approx\frac{9\pi}{1000}\rightarrow1.62<br>$$</p><p>上述式子表明$99.7%$的jitter变化都会在$1.62$以内，我们再来分析一下这个误差大概是多少，</p><p>$$<br>sin(\frac{9\pi}{1000})-\frac{9\pi}{1000}=-3.7671\times 10^{-6}<br>cos(\frac{9\pi}{1000})-1=-3.9969\times 10^{-4}<br>$$</p><p>假如上述的误差在应用中可以接受，那么可以转换为下面的表达式</p><p>$$<br>Signal=sin(\omega_0 t)+cos(\omega_0 t)\phi(t)<br>$$</p><p>上面的这个式子告诉我们，因为加上$sin(\omega_0 t)$在频域中相当于对中心频率进行操作，并不会产生其他的频率分量，这是由我们的时域和频域的线性性质保证的；另一方面，乘上$\phi(t)$在频域中相当于对中心频率和$\phi(t)$做了混频（卷积）操作，对我们希望了解的边带信息进行了一个频谱的搬移$\delta(\omega-\omega_0)*\Phi(\omega)$，也就是使用$\omega_0=0$还是$\omega_0=30GHz$，最终获得的边带信息是一样的。所以我们从理论上证明了，相位域模型在DC处工作的相位噪声谱密度和在30GHz处工作的相位噪声谱密度是等价的。</p><p>所以我们采用的方案是使用一个阶跃信号来作为激励验证环路的相位裕度等信息，并截取环路settle之后的时域输出信号进行频谱分析，获取我们的相位噪声。</p><p>接下来介绍Phase Detector模块，其内部还没有考虑TDC的增益，仅仅是对相位信息做了个加法，并且除以$2\pi$将相位信息由弧度的单位转换为fV时钟周期的个数。</p><img src="/2022/12/28/adpll-xiang-wei-yu-matlab-mo-xing/e146772b7c1397cb32da2a9fba4d974d089e6452a505b6c067e3574945210cb0.png" class="" title="Phase Detector内部框图"><p>接下来介绍Loop Filter，目前的Loop Filter实际采用的是一阶IIR滤波器，转换为s域波形后，如下图所示，</p><img src="/2022/12/28/adpll-xiang-wei-yu-matlab-mo-xing/74a79a42b5b6d5254248fa6bbb49ad1552f8cdc58528076106b684f4dde0c108.png" class="" title="Loop Filter内部框图">  <p>该一阶滤波器存在的问题就是对TDC的带外噪声抑制只有$20dB/dec$，目前从仿真的角度来看是不能满足我们的需求的，后期可能会通过提升滤波器阶数的形式来提升系统对TDC带外噪声的抑制能力。</p><p>接下来介绍我们的DCO模型，DCO模型的量化噪声是通过Band-Limited White Noise给定的，并且其中的fR倍数来自于$z$域到$s$域的转换，$2\pi$的作用是之前提到的单位转换，并且DCO内部本身的积分器由$\frac{1}{s}$模块进行建模。</p><img src="/2022/12/28/adpll-xiang-wei-yu-matlab-mo-xing/d11924281ff6bd4da640c3b7ff22206619ca71b7d8726c11a6e2ffa30c504e54.png" class="" title="DCO内部框图">  <h3 id="获取Signal数据并做傅里叶变换生成我们的相位噪声谱密度，并计算RMS抖动"><a href="#获取Signal数据并做傅里叶变换生成我们的相位噪声谱密度，并计算RMS抖动" class="headerlink" title="获取Signal数据并做傅里叶变换生成我们的相位噪声谱密度，并计算RMS抖动"></a>获取Signal数据并做傅里叶变换生成我们的相位噪声谱密度，并计算RMS抖动</h3><p>这一部分功能主要是通过FFTspectrum的函数实现的，其代码如下</p><pre class=" language-MATLAB"><code class="language-MATLAB">function [SpectrumSSB] = FFTSpectrum(Signal,Fs)    Signal_window = length(Signal)*1/Fs;    Spectrum_Resolution = 1/Signal_window;    Spectrum_Complex = fft(Signal);    Spectrum_Magnitude_DSB = abs(Spectrum_Complex)/length(Signal);    for i=2:length(Signal)/2        % Pay Attention to sqrt(2). This is required due to magnitude        % spectrum being added is equivalent to multiplied by sqrt(2)        Spectrum_Magnitude_SSB(i) =  (Spectrum_Magnitude_DSB(i+1)+Spectrum_Magnitude_DSB(length(Signal)+1-i))/sqrt(2);    end    Spectrum_Magnitude_SSB(1) = Spectrum_Magnitude_DSB(1);    L = 10*log10(Spectrum_Magnitude_SSB.^2/Spectrum_Resolution);    semilogx((0:Spectrum_Resolution:length(Signal)/2*Spectrum_Resolution-Spectrum_Resolution),L);    title('Phase Noise');    xlabel('Hz');    ylabel('dBc/Hz');    SpectrumSSB = Spectrum_Magnitude_SSB;end</code></pre><p>可以看到的是，代码里fft的功能是使用matlab自带的函数实现的，这个产生了一个双边的复数谱，我们只对幅度和功率感兴趣，所以使用abs做了转换，产生了双边幅度谱，之后使用一个循环遍历我们的双边谱数列，将数据进行镜像翻转并叠加，产生我们的单边幅度谱，这里需要特别注意 <span class="github-emoji"><span>❗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，我在这里犯了错误，花费了几个星期才找到，在幅度谱做叠加的时候，我们始终要记得频谱是功率叠加，所以幅度谱相加之后，要除以$\sqrt(2)$。之后我们也要注意在转换功率谱的时候直接做平方即可，但是在产生功率谱密度的时候，要除以频率分辨率的带宽，这是因为在做fft时，算法将频率分辨率内所有的功率叠加用一根谱线表示，这时候如果要知道密度，需要除以这一段的带宽，也就是我们的频谱分辨率，之后再进行对数显示即可。</p><p>在计算RMSjitter的时候，我们需要使用我们的功率谱，这里的设计时FFTspectrum函数将幅度谱作为参数传递出去，在函数外进行RMSjitter的计算，所以我们还需要做平方的操作才能转换为功率谱，这里由于计算总功率，直接将所有的谱线的功率进行叠加即可，最后使用下面的数学关系导出RMSjitter即可，要注意的是我们使用的全部都是单边谱，这一点不要搞错。</p><p>$$<br>jitter_{rms}=\sqrt{\frac{\sigma^2_{L}}{(2\pi f_V)^2}}<br>$$</p><h3 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h3><p>我们做了DCO量化噪声的仿真，确定了DCO量化噪声对输出相位噪声的影响，下图为DCO量化噪声产生的相位噪声的单边功率谱密度，蓝线为实际噪声源的结果，红线为理想噪声源的结果。</p><img src="/2022/12/28/adpll-xiang-wei-yu-matlab-mo-xing/23dd2a76a551264b82d5a44d88a4bf99a83df6e7e0127c3ec21f3c5c51ff04bf.png" class="" title="Phase Noise From DCO Quantization Noise">  <p>该频谱积分获得的RMSjitter和设计的jitter如下表格所示，</p><table><thead><tr><th>Nominal Jitter RMS</th><th>Output Jitter RMS</th></tr></thead><tbody><tr><td>$36fs$</td><td>$33.6fs$</td></tr></tbody></table><p>可以看到结果还是符合得很好的，注意，此时的DCO带内噪声根据评估后发现为$30fs$左右，总的$Jitter_{rms}$为$44fs$左右，意味着带内的噪声水平也不可忽略，可能考虑通过DSM实现将低频噪声抖到高频去。此外，还有一个值得思考的事情是，DCO的量化噪声我故意设置的和TDC的量化噪声以及DCO的热噪声相当，这时的频率精度为$127.59KHz$，可以看到，如果我们想要进一步压低我们的DCO带外量化噪声，使得DCO带外量化噪声的$Jitter_{rms}$的功率比DCO的热噪声的功率小一个数量级的化，根据我们的精度和噪声功率的公式，</p><p>$$<br>\sigma_{DCO}^2=\frac{f_{res}^2}{12}<br>$$</p><p>我们可以发现精度至少要提升$\sqrt{10}\approx3$倍左右，也就是说精度要提升到$40KHz$这个量级。这个数量级对于我们后期的设计来说也是具有指导性意义的。</p><p>我们还做了TDC量化噪声的仿真，先使用之前的程序计算出需要的TDC的量化噪声功率谱密度水平，再代入我们的Band limited White Noise模块中，就可以得到最终的单边谱密度了，如下所示，蓝线为实际噪声源的结果，黄线为理想噪声源的结果。</p><img src="/2022/12/28/adpll-xiang-wei-yu-matlab-mo-xing/f6a0f9ffa739098f611c3b30e3c2bb0de6466aaf996849d51a302acfbbe2b570.png" class="" title="Phase Noise From TDC Quantization Noise">  <p>该频谱积分获得的RMSjitter和设计的jitter大小如下表格所示，</p><table><thead><tr><th>Nominal Jitter RMS</th><th>Output Jitter RMS</th></tr></thead><tbody><tr><td>$50fs$</td><td>$50.454fs$</td></tr></tbody></table><p>可以看到模型和理论计算符合得还是很好的，值得注意的是，在带外部分得TDC得量化噪声与我们的DCO的热噪声水平相当了，这是我们不希望看到的，我们希望至少带外要由DCO的热噪声和量化噪声主导，所以我们这里可能需要采用高阶IIR环路滤波器才可以满足我们的需求，否则我们就需要进一步提升我们的TDC的精度，这对于我们来说是比较困难的，所以后面可以采取2阶环路滤波器的设计，来降低我们的带外TDC噪声。</p><h2 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h2><p>本代码运行在i7-7700HQ的2.8GHz的CPU的电脑，该电脑拥有16GB内存，代码存储在SSD上，运行时间经过测量为81.44s，大约为1min20s，可以看到这个代码的时间复杂度和空间复杂度都不高，完全可以在一般的个人PC机上运行，不需要额外的算力支持。</p>]]></content>
      
      
      <categories>
          
          <category> ADPLL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADPLL </tag>
            
            <tag> PLL </tag>
            
            <tag> 模拟电路设计 </tag>
            
            <tag> 混合信号集成电路设计 </tag>
            
            <tag> MATLAB建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通信标准以及与收发机器件参数</title>
      <link href="/2022/12/21/tong-xin-biao-zhun-yi-ji-yu-shou-fa-ji-qi-jian-can-shu/"/>
      <url>/2022/12/21/tong-xin-biao-zhun-yi-ji-yu-shou-fa-ji-qi-jian-can-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要写这篇文章-question"><a href="#为什么要写这篇文章-question" class="headerlink" title="为什么要写这篇文章:question:"></a>为什么要写这篇文章<span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h2><p>主要的原因在于考虑PLL参数的时候，会产生对一些问题的疑问，例如GSM通信中，为什么要求$L&lt;-162dBc/Hz$ @ $20MHz$，这是让问非常困惑的地方，所以在这里对通信标准做一个简单的归类，并且各个通信标准对收发机动态范围、时钟抖动等参数的要求在这里做一个总结，方便之后在不同应用下对电路参数进行一个基本的估计。</p><h2 id="从GSM到5G-rocket"><a href="#从GSM到5G-rocket" class="headerlink" title="从GSM到5G :rocket:"></a>从GSM到5G <span class="github-emoji"><span>🚀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f680.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h2><p>GSM通信在我很小的时候就已经有应用了，最典型的就是2G通信，那时候的网速还是非常感人，大概就是几十kb/s<span class="github-emoji"><span>🐢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f422.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，我还深刻地记得当时还不知道什么是网页，那时候的手机只有电话通信的功能，现在我的手机已经可以无压力4k了<span class="github-emoji"><span>🚀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f680.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>…通信的发展实在是太快了<span class="github-emoji"><span>✔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>🙉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f649.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h2 id="GSM通信的标准"><a href="#GSM通信的标准" class="headerlink" title="GSM通信的标准"></a>GSM通信的标准</h2><p>GSM的全称为(the Global system for mobile communications)，由欧洲人<span class="github-emoji"><span>🇪🇺</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f1ea-1f1fa.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>指定的规则，GSM自从发布之后衍生出好多版本，例如，GSM900、DCS1800等，其中DCS1800是使用范围最广的，这其中的900、1800均指的是中心频率。</p><p>这两类GSM的通信区别如下图所示。</p><table><thead><tr><th>Name</th><th>Centre Freq.</th><th>Max. Output Power</th><th>Range</th></tr></thead><tbody><tr><td>GSM900</td><td>900MHz</td><td>8W</td><td>60km</td></tr><tr><td>DCS1800</td><td>1800MHz</td><td>1W</td><td>20km</td></tr></tbody></table><p>GSM的参数如下面的表格所示</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Uplink</td><td>890-915MHz</td></tr><tr><td>Downlink</td><td>935-960MHz</td></tr><tr><td>Transfer rate</td><td>9.6Kbps</td></tr><tr><td># of carriers</td><td>124</td></tr><tr><td>Carrier separation</td><td>200KHz</td></tr><tr><td>Modulation</td><td>GMSK</td></tr><tr><td>Access method</td><td>TDMA\FDMA</td></tr><tr><td>Time slots</td><td>8</td></tr><tr><td>$\phi_{rms}$</td><td>$\leq 5\deg$</td></tr></tbody></table><h2 id="3G通信的标准"><a href="#3G通信的标准" class="headerlink" title="3G通信的标准"></a>3G通信的标准</h2><p>3G通信相比GSM来说的优势在于提升了数据速率和服务种类。3G通信采用了CDMA技术，即码分复用技术，增大了频带利用率 ，主要的版本有WCDMA(Wideband Code Division Multiple Access)，以及CDMA2000(Code Devision Multiple Access 2000)</p><p>3G通信的参数如下面的表格所示</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Uplink</td><td>1920-1980MHz</td></tr><tr><td>Downlink</td><td>2110-2170MHz</td></tr><tr><td>Transfer rate</td><td>2Mbps</td></tr><tr><td>Carrier separation</td><td>200KHz</td></tr><tr><td>Modulation</td><td>QPSK &amp; QAM</td></tr><tr><td>Access method</td><td>CDMA</td></tr><tr><td>$\phi_{rms}$</td><td>$\leq 2\deg$</td></tr></tbody></table><h2 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h2>]]></content>
      
      
      <categories>
          
          <category> 通信标准 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟IC设计 </tag>
            
            <tag> 通信标准 </tag>
            
            <tag> 混合信号IC设计 </tag>
            
            <tag> RFIC设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADPLLPDModelling</title>
      <link href="/2022/12/19/adpllpdmodelling/"/>
      <url>/2022/12/19/adpllpdmodelling/</url>
      
        <content type="html"><![CDATA[<h2 id="昨天世界杯阿根廷夺冠了！"><a href="#昨天世界杯阿根廷夺冠了！" class="headerlink" title="昨天世界杯阿根廷夺冠了！"></a>昨天世界杯阿根廷夺冠了！</h2><p>先写一个见证历史的时刻，阿根廷足球队在艰难的拼搏下获得了世界杯冠军的荣耀，整个过程真的是跌宕起伏，像是人生一样，经历了大起大落，感觉法国队和阿根廷队谁获得冠军真的需要依靠一些运气，你要说阿根廷队完全碾压法国队也没有，甚至比赛的最后时间在97s内姆巴佩连进两球之后以及在之后的加时赛中，阿根廷差点大门就要失守，还好马丁内斯扛住了考验，在之后的点球大战里，马丁内斯凭借出色的预判技巧以及运气，帮助阿根廷队获得了冠军，今夜属于阿根廷！ <span class="github-emoji"><span>⚽</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26bd.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>🥇</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f947.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>🇦🇷</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f1e6-1f1f7.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h2 id="回到ADPLL，为什么写这篇文章？"><a href="#回到ADPLL，为什么写这篇文章？" class="headerlink" title="回到ADPLL，为什么写这篇文章？"></a>回到ADPLL，为什么写这篇文章？</h2><p>写这篇文章的目的主要是帮助之后的自己快速理解一些概念，在之后有概念不清晰的时候还能再回来看看 <span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>。这篇文章主要是帮助我记忆和理解Robert Bogdan Staszewski的Phase-Domain All-Digital Phase-Locked Loop这篇文章，在这篇文章里，Bogdan主要介绍了ADPLL的基本相位域模型。</p><h2 id="ADPLL的框图模型"><a href="#ADPLL的框图模型" class="headerlink" title="ADPLL的框图模型"></a>ADPLL的框图模型</h2><p>ADPLL的基本模型如下图所示，</p><img src="/2022/12/19/adpllpdmodelling/52cc956677224dbf476efbbb2dda2a4c0de06e27077c42272c1cf641e45f0d56.png" class="" title="ADPLL模型框图"><p>其基本原理就是通过两个计数器，计数器的计数触发信号分别为<code>参考时钟</code>和<code>可变时钟</code>，这里的<code>可变时钟</code>指的是频率综合器生成的目标时钟，比方说10GHz、1GHz这种比较高速的时钟；而<code>参考时钟</code>一般就是比较低速的了，例如，50MHz这种速率的时钟。这里给出了具体时钟的大小的目的不是说所有的ADPLL的<code>参考时钟</code>和<code>可变时钟</code>都是个速率，而是给读者一个概念，这两个时钟应该是差了好多数量级的。</p><p>计数器对<code>参考时钟</code>和<code>可变时钟</code>这两个时钟进行计数时，每一次时钟边沿累加的量是不一样的，</p><p>$$R_V[n]=\sum_{i=0}^{n}1$$<br>$$R_R[n]=\sum_{i=0}^{n}FCW$$</p><p>可以看到，<code>参考时钟</code>计数器使用的累加量是FCW，也就是频率控制字，而<code>可变时钟</code>计数器使用的累加两是1。如何理解呢？其实这里都是统计了在一定时间内<code>可变时钟</code>走过的边沿个数；一个假设CKV是CKR的频率的FCW倍，那么在一个CKR的时钟周期里，应该走了FCW个CKV的上升沿。这里就全部可以说得通了，Phase Detector中检测的就是两个信号在走过时，CKV应该有的上升沿、以及CKV实际走过的上升沿的差，再通过TDC实现再一个CKV周期内的相位差的检测，就可以得到当前时刻下，实际CKV走过的上升沿和CKV应该走过的上升沿的差了。</p><h3 id="ADPLL时钟同步问题"><a href="#ADPLL时钟同步问题" class="headerlink" title="ADPLL时钟同步问题"></a>ADPLL时钟同步问题</h3><p>CKR时钟被高速的CKV时钟clocked，这里说的被clocked的意思是被同步，我们说A时钟被B时钟clocked也就是说，A时钟同步到B时钟的边沿，换句话说，A时钟的边沿通过某种方式与B时钟的边沿在同一时刻发生，这样就保证了数字系统内时钟的同步性。</p><p>原先没有同步前的CKV与CKR的相位关系可以表达如下式</p><p>$$\theta_V[k]=k$$<br>$$\theta_R[k]=k\cdot N+\theta_0$$</p><p>其中，k表示第k个上升沿，$\theta_V[k]$表示了第k个CKV的上升沿的相位，当然，这个相位信息归一化为走过的CKV周期的个数；$\theta_R[k]$表示了到第k个CKR的上升沿时走过的CKV的周期个数。</p><p>同步之后的CKV与CKR变为如下所示</p><p>$$\theta_V[k]=k$$<br>$$\theta_R[k]=k\cdot N+\theta_0+\epsilon[k]$$</p><p>可以看到区别就在于在CKR的相位表达式中，多了一项$\epsilon[k]$，当然这一项表示了由于clocking或者说同步导致的相位损失或者增加，从这一含义中，我们可以知道$\epsilon[k]$的范围为$[0,1)$。</p><p>这一误差的存在会导致Phase Detector输出的数据不正常，因为Phase Detector回去的相位信息都是同步之后的相位信息，如下图所示，</p><img src="/2022/12/19/adpllpdmodelling/300856c4eb6dca8515a4c82c84ef9f79450a35e15d82d34109be7b40549d76f2.png" class="" title="由于Retiming造成的误差">  <p>这是，如果我们使用同步之后的相位信息进行操作，我们会发现CKV与CKR之间会出现一个循环的误差，如果不考虑带宽限制，那么在输出上，就会体现出出现杂散Spurs的情况。这里的这个误差可以通过基于TDC的小数误差校正电路进行校正。</p><h3 id="TDC校正电路"><a href="#TDC校正电路" class="headerlink" title="TDC校正电路"></a>TDC校正电路</h3><p>TDC的最小分辨精度和PLL的噪声是什么关系呢？</p><p>首先，我们要知道，TDC的噪声主要是量化噪声，假设TDC的量化精度为LSB，那么，量化时间噪声功率$\sigma_t^2$由下面的式子表达，</p><p>$$\sigma_t^2=\Delta t_{res}^2/12$$</p><p>根据上式，我们可以进一步转换，将$\sigma_t^2$转化为相位噪声功率$\sigma_\phi^2$，下面的式子的转换思路是将时间上的rms值与电压上的rms值通过斜率$A*\omega_v$做关联。</p><p>$$\sigma_\phi^2=\sigma_t^2(2\pi f_V)^2$$</p><p>那么将上面的两个式子做合并，我们就有下面的式子，</p><p>$$\sigma_\phi^2=\frac{4\pi^2}{12}\Delta t_{res}^2f_V^2 $$</p><p>由于量化噪声均匀分布在奈奎斯特带内，并且TDC的采样速率为参考频率的速率，所以我们可以有TDC导致的相位噪声谱密度为上式除以一个奈奎斯特频率$f_R$，如下式所示</p><p>$$\phi_{n,TDC}=\frac{4\pi^2}{12}\frac{\Delta t_{res}^2f_V^2}{f_R}[dBc/Hz]$$</p><p>为了有一个直观的感受，我们可以代入一些数字进去观察一下结果，例如，我们假设$f_V=2.4GHz$，$f_R=13MHz$，$\Delta t_{inv}=40ps$，计算结果如下表示</p><p>$$\phi_{n,TDC}=10log(\frac{4\pi^2}{12}\frac{(40ps)^2(2.4GHz)^2}{13MHz})=-86dBc/Hz$$</p><h3 id="相位域信号的模运算"><a href="#相位域信号的模运算" class="headerlink" title="相位域信号的模运算"></a>相位域信号的模运算</h3><p>由于相位域的数据不可能无穷大，所以要限制给定相位域中的数据的带宽，带给定带宽下，如何去比对两个数据的大小？</p><p>其实，在数字电路里，采用有限带宽的数据直接就可以保证两个数据在做减法的时候，可以获取想要获取的小角度数据，例如下图所示，</p><img src="/2022/12/19/adpllpdmodelling/f1eba9c7ec3a4b6741a66bd5959ad9a401be2c01a8b118e7c119d290fa83b049.png" class="" title="模运算示意图">  <h2 id="ADPLL的相位域模型"><a href="#ADPLL的相位域模型" class="headerlink" title="ADPLL的相位域模型"></a>ADPLL的相位域模型</h2><p>ADPLL的相位域模型如下图所示，</p><img src="/2022/12/19/adpllpdmodelling/abb0ef0a543d6aa08061805bd68b4c5b185db80588288b12dc0d969187e0c4a2.png" class="" title="picture 4">  <p>可以看到，该模型是一个线性模型，且用$z$域表达，为了我们可以更好地分析系统的稳定性等性质，我们需要将系统转换到连续域$s$域当中进行分析，这其中涉及到$z$域到$s$域的一个近似问题。</p><p>具体来说，$z$的定义如下所示，</p><p>$$z=e^\frac{s}{f_R}$$</p><p>其中，$s=j\omega=j2\pi f$，这里的$f$指的是信号变化的带宽，如果信号变化的带宽远远小于采样频率$f_R$，那么，我们可以得到下式的关系，</p><p>$$z=\lim_{s&lt;&lt;f_R}e^\frac{s}{f_R}\approx 1+\frac{s}{f_R}$$</p><p>其本质上就是一个等价无穷小。如果我们将上面的式子带入到模型中，我们可以获得下图所示的模型。</p><img src="/2022/12/19/adpllpdmodelling/d0d29494346ceb5fdd438212138c0496e56ad06629d7325cd3b9d524f6a7017e.png" class="" title="picture 5">  <p>其中，对于累加器的近似由下式表达，</p><p>$$\frac{1}{z-1}\approx\frac{1}{1-1+\frac{s}{f_R}}=\frac{f_R}{s}$$</p><p>值得注意的是，这里的积分器有一个有限的增益为$f_R$，所以在后面会存在特殊的增益项$f_R$。</p><h3 id="计算开环传输函数"><a href="#计算开环传输函数" class="headerlink" title="计算开环传输函数"></a>计算开环传输函数</h3><p>实际上，电路的开环传输函数已经非常显然了<span class="github-emoji"><span>😃</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，其中需要特别注意的是，在计算电路的开环传输函数的时候，我们不能把$N$这个增益项算在里面，因为反馈回路并没有把$N$包纳在里面。这里我们可以陈述一个结论，反馈系统的计算从反馈结束点开始到反馈开始点结束，这里的反馈结束点就是Phase Detector中的加法器，称为反馈结束点的原因是因为反馈回路在此点结束，汇入开环路径；这里的反馈开始点就是输出，称为反馈开始点的原因是因为反馈回路从输出位置开始和开环路径分离，开始形成了一个单独的回路。</p><p>那么，电路的开环传输函数由下式表示，</p><p>$$H_{ol}(s)=\frac{1}{2\pi}\cdot(\alpha+\frac{\rho f_R}{s})\cdot\frac{f_RK_{DCO}2\pi}{\hat{K}_{DCO}s}=\frac{\alpha f_Rs+\rho f_R^2}{s^2}$$</p><p>$$=\frac{\alpha f_Rs+\rho f_R^2}{s^2}$$</p><h3 id="计算闭环传输函数-amp-阻尼系数等参数"><a href="#计算闭环传输函数-amp-阻尼系数等参数" class="headerlink" title="计算闭环传输函数&amp;阻尼系数等参数"></a>计算闭环传输函数&amp;阻尼系数等参数</h3><p>电路的反馈系数为1，我们可以马上写出电路由$\phi_R$到$\phi_V$的传输函数，如下所示，</p><p>$$\frac{\phi_V}{\phi_R}=N\frac{H_{ol}(s)}{1+H_{ol}(s)}=N\frac{\alpha f_Rs+\rho f_R^2}{s^2+\alpha f_Rs+\rho f_R^2}$$</p><p>可以看出该系统是一个两极点，一零点系统，根据自动控制原理，我们可以按照二阶系统的基本模型进行自然频率，阻尼系数等的设计。</p><p>$$\alpha f_R=2\zeta\omega_n$$<br>$$\rho f_R^2=\omega_n^2$$</p><p>由上述表达式可以解出自然频率$\omega_n$以及阻尼系数$\zeta$的表达式，并且可以看出，由于传输函数是二极点系统，所以这是一个Type II的PLL。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>那么，这篇文章到这里就结束了，本篇文章主要内容参考了一篇TCAS II文章：“Phase-Domain All-Digital Phase-Locked Loop”，由Bogdan写的，内容对设计非常有帮助，感兴趣的读者可以阅读一下。</p><p>在之后的文章里，我想写一写关于各种通信标准的来源以及推导的，比方说GSM通信、3G通信等。这将会帮助我们更好地理解PLL、ADC等器件的指标参数等。</p><p>那么这篇文章到这里就结束了<span class="github-emoji"><span>✔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，有问题的同学可以在评论区留言哦！<span class="github-emoji"><span>😃</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>]]></content>
      
      
      <categories>
          
          <category> ADPLL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ADPLL </tag>
            
            <tag> PLL </tag>
            
            <tag> 模拟电路设计 </tag>
            
            <tag> 混合信号集成电路设计 </tag>
            
            <tag> 论文阅读 </tag>
            
            <tag> 模型建立 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DummyInsertion</title>
      <link href="/2022/12/15/dummyinsertion/"/>
      <url>/2022/12/15/dummyinsertion/</url>
      
        <content type="html"><![CDATA[<h2 id="Dummy-OD-DOD-Rules"><a href="#Dummy-OD-DOD-Rules" class="headerlink" title="Dummy OD (DOD) Rules"></a>Dummy OD (DOD) Rules</h2><h3 id="Must"><a href="#Must" class="headerlink" title="Must"></a>Must</h3><ol><li>It is must to use TSMC’s auto-fill utilities to insert dummy OD. Don’t change any dimension and variable in utility. <strong>必须</strong>要使用TSMC提供的自动插dummyOD的工具进行dummy的插入，并且<strong>不可以改变</strong>任何工具里的参数。</li><li>Use the dummy layer ODBLK properly. This layer(CAD layer no. 150;20) directs TSMC utility that the area covered should be blocked from DOD, DPO fill operations. ODBLK is for excluding DOD and excluding dummy Poly(DOD).需要正确使用**ODBLK(150;20)**，这一层次会告诉TSMC工具不对这一块进行dummy插入的操作。</li><li>Don’t put DOD in areas covered by the following marker layers:<ul><li>Well resistor under STI(NWDMY)</li><li>Region of chip corner stress relief pattern, seal-ring, and CDU pattern<br> TSMC’s fill generation utility will not add DOD into these regions, as these layers are well defined. The ODBLK covered areas should not cover or overlap the above areas for DRC reasons.<br> DOD不能被放置在NWDMY、芯片的角上、密封环、以及CDU形状附近。</li></ul></li></ol><h3 id="Recommended"><a href="#Recommended" class="headerlink" title="Recommended"></a>Recommended</h3><ol><li>It is recommended to use filler cells with OD/PO to fill a large empty area in the standard-cell-based block during the P&amp;R stage. 有标准单元（MOS管）的附近，最好采用与MOS管相同形态的Dummy对周围环境进行填充（目前我们就是这么做的），理由是TSMC的工具的填充可能会不太准确，手动插入dummy会使形状更为规整。</li><li>It is suggested to make sure that the ODBLK layer covers sensitive circuits, such as:<ul><li>PAD areas for high frequency signals</li><li>SRAM sensitive functional blocks and bit cell arrays</li><li>Analog/RF circuits(DAC/ADC, PLL. Inductor) and so on…<br> 在敏感的电路附近（模拟电路、PAD区域），要使用**ODBLK(150;20)**对层进行屏蔽处理</li></ul></li><li>It is recommended to manually add DOD uniformly inside regions covered by the ODBLK layer, to gain better process window and electrical performance. 在**ODBLK(150;20)**层次覆盖的区域，要采用手动插入dummy以保证足够的性能。</li></ol><h2 id="Dummy-Poly-DPO-Rules"><a href="#Dummy-Poly-DPO-Rules" class="headerlink" title="Dummy Poly (DPO) Rules"></a>Dummy Poly (DPO) Rules</h2><h3 id="Must-1"><a href="#Must-1" class="headerlink" title="Must"></a>Must</h3><ol><li>Good Poly uniformity is the key to meet the PO CD as well as circuit performance requirement. You must fill the DPO globally and uniformly even if the original drawn poly already satisfies the required poly density rule (PO.DN.1). The designer may wish to add dummy poly to improve the stability of the poly line dimension on silicon. 需要保持Poly的均一性，并且保证全局都要均一地插入DPO。</li><li>It is must to use TSMC’s auto-fill utilities to insert dummy PO. Don’t change any dimension and variable in utility. 必须要使用TSMC的自动插Poly工具来插入dummy Poly。</li><li>Use the dummy layer POBLK properly. This layer (CAD layer no. 150;21) directs the TSMC utility that the area covered should be blocked from DPO, DOD fill operations. POBLK is for excluding DPO and excluding dummy OD (DOD). 要使用**POBLK(150;21)**在特定区域来屏蔽DPO的填充。</li><li><ol start="3"><li>Don’t put DPO in areas covered by the following marker layers:</li></ol><ul><li>Region of chip corner stress relief pattern, seal-ring, and CDU pattern<br> TSMC’s fill generation utility will not add DOD into these regions, as these layers are well defined. The POBLK covered areas should not cover or overlap the above areas for DRC reasons.<br> DOD不能被放置在NWDMY、芯片的角上、密封环、以及CDU形状附近。</li></ul></li></ol><h3 id="Recommended-1"><a href="#Recommended-1" class="headerlink" title="Recommended"></a>Recommended</h3><ol><li>It is recommended to use filler cells with OD/PO to fill a large empty area in the standard-cell-based block during the P&amp;R stage. 有标准单元（MOS管）的附近，最好采用与MOS管相同形态的Dummy对周围环境进行填充（目前我们就是这么做的），理由是TSMC的工具的填充可能会不太准确，手动插入dummy会使形状更为规整。</li><li>It is suggested to make sure that the POBLK layer covers sensitive circuits, such as:<ul><li>PAD areas for high frequency signals</li><li>SRAM sensitive functional blocks and bit cell arrays</li><li>Analog/RF circuits(DAC/ADC, PLL. Inductor) and so on…<br> 在敏感的电路附近（模拟电路、PAD区域），要使用**POBLK(150;21)**对层进行屏蔽处理</li></ul></li><li>It is recommended to manually add DPO uniformly inside regions covered by the POBLK layer, to gain better process window and electrical performance. 在**POBLK(150;21)**层次覆盖的区域，要采用手动插入dummy以保证足够的性能。</li></ol><h2 id="Dummy-Metal-DM-Rules"><a href="#Dummy-Metal-DM-Rules" class="headerlink" title="Dummy Metal (DM) Rules"></a>Dummy Metal (DM) Rules</h2><h3 id="Must-2"><a href="#Must-2" class="headerlink" title="Must"></a>Must</h3><ol><li><p>To improve the metal CMP process window, you must fill the DMn globally and uniformly even if the originally drawn Mn has already met the density rule (Mn.DN.1/Mn.DN.2)</p><ul><li>Use the utility dummy fill as a method for inserting dummy metal insertion. Utility dummy fill is better for IP blocks, library cells, and full custom cells</li><li>It is must to use TSMC’s auto-fill utilities to insert dummy metal. Don’t change any dimension and variable in utility.</li></ul></li></ol><p>  需要在全局层面上插入DMn，并且保证均一性，即使我们原先的金属密度已经满足设计需求了。使用dummy fill工具作为为IP设计插入dummy 的一种方式；使用TSMC的自动插入dummy的工具在全局层面插入dummy metal。这些都是<strong>必须的</strong><br>2. Use the dummy layer DMxEXCL properly. This layer directs TMSC’s utility that the area covered should be blocked from DM fill operations. All metal (geometry) beneath a customer-drawn blockage layer(DMxEXCL) must meet the density rule specified in Mn sections. 正确使用DMxEXCL层，该层次会禁止插入dummy，所有该层次下的区域都需要满足Mn层次的密度要求。<br>3. For DMxEXCL, use GDS layer numbers 150;n。对于屏蔽层，使用代号为150;n的层用作屏蔽。<br>4. 为了保证准确的RC提取操作，需要在插入dummy之后进行RC的提取，换句话说，插入dummy会引起RC数据的不精确，并且要把金属厚度是密度的函数这一特性打开。（我怀疑这里有可能就是之前我们看到金属方块电阻是金属线宽和线间距的函数的解释）<br>5. Don’t put DMn in areas covered by the following marker layers:</p><ul><li>Regions of chip corner stress relief pattern, and seal-ring.<br>   不要在芯片角的附近以及密封环附近使用金属屏蔽层。</li></ul><h3 id="Recommended-2"><a href="#Recommended-2" class="headerlink" title="Recommended"></a>Recommended</h3><ol><li>It is suggested to make sure that DMxEXCL is drawn over the following:<ul><li>Sensitive circuits &amp; Analog circuits(DAC\ADC &amp; PLL)</li><li>RF application circuits</li><li>Pad areas for high frequency signals<br>在敏感电路、ADC电路四周、告诉信号的PAD附近，需要使用DMxEXCL层对全部电路进行屏蔽操作，也就是说这部分的dummy是需要手动插入的。</li></ul></li></ol><h2 id="什么是process-control-for-CD"><a href="#什么是process-control-for-CD" class="headerlink" title="什么是process control for CD?"></a>什么是process control for CD?</h2><img src="/2022/12/15/dummyinsertion/002f93582507d3bfc5d3b996f94bbfa1e61dcc37d6a76751ff3ac664151d481b.png" class="" title="process control for CD">  <h2 id="什么是-Chip-Overlay"><a href="#什么是-Chip-Overlay" class="headerlink" title="什么是 Chip Overlay?"></a>什么是 Chip Overlay?</h2><img src="/2022/12/15/dummyinsertion/33b8f4d191cf744ca566408b53be2e87e313e6ad2215cf0f3190f7e2ae275c50.png" class="" title="Chip Overlay">  <p>这个链接解释了Chip Overlay是什么；由什么原因引起的；以及该如何解决？</p><ul><li><a href="https://www.youtube.com/watch?v=IdlYgHaIIPA" target="_blank" rel="noopener">https://www.youtube.com/watch?v=IdlYgHaIIPA</a></li></ul><h2 id="什么是-IP-abutment"><a href="#什么是-IP-abutment" class="headerlink" title="什么是 IP abutment?"></a>什么是 IP abutment?</h2><img src="/2022/12/15/dummyinsertion/b6c20a773a93fe57c3f8a17cf954f9d0005192ded5ed574b1b9ab0401b0a88b9.png" class="" title="IP abutment">  ]]></content>
      
      
      <categories>
          
          <category> IC设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dummy Insertion </tag>
            
            <tag> IC设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最近Crypto的风波与趣闻</title>
      <link href="/2022/12/15/zui-jin-crypto-de-feng-bo-yu-qu-wen/"/>
      <url>/2022/12/15/zui-jin-crypto-de-feng-bo-yu-qu-wen/</url>
      
        <content type="html"><![CDATA[<h2 id="最近发生了什么？"><a href="#最近发生了什么？" class="headerlink" title="最近发生了什么？"></a>最近发生了什么？</h2><p>在2022年11月，FTX交易所的创始人Sam Bankman-Fried宣布了自己破产的新闻，震荡了整个币圈，所有人都在害怕这会是继Luna事件之后，又一次对Crypto市场产生重大打击的事件… <span class="github-emoji"><span>😥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f625.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，本人持有了BNB、ETH两种tokens，发生这样的事，我只能庆幸我一开始不知道FTX，只知道CZ开的Binance… <span class="github-emoji"><span>😌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 我对Binance是非常有信心的，因为Binance会通过很多途径来维护投资者的利益，具体我经历过什么，在这里就不细说了，免得透露一些其他人的隐私。不过，我想说的是，我对Binance是非常忠心的，包括Binance提供的各种服务，我也非常感兴趣。为了支持Binance，我还上网购买了一件Binance的盗版卫衣 <span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，说来惭愧，因为没有找到正版的，只能搞一件盗版的支持一下CZ了。</p><h2 id="我的Crypto经历-rocket-moon"><a href="#我的Crypto经历-rocket-moon" class="headerlink" title="我的Crypto经历 :rocket: :moon:"></a>我的Crypto经历 <span class="github-emoji"><span>🚀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f680.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>🌔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f314.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h2><p>我在2021年5月购买了全新的电脑，电脑的显卡非常不错，是RTX2060的显卡，当时我的显卡是闲置的，很多时候并用不上，我就想能不能用显卡进行挖矿，于是乎，我在2021年的5月第一次进行了挖矿的操作，并且当时我印象很深刻，在Binance的ETHpool中进行挖矿，一台RTX2060显卡的电脑可以实现一天十几块人民币的收入。在挖矿期间，ETH的现货价格在不断飙升，看得我都惊呆了 <span class="github-emoji"><span>😲</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f632.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，于是我就从家里拿了一部分资金进行了ETH的现货投资。我印象非常深刻，在2021年的劳动节期间，我现货账户中的ETH以每天将近10%的增长速度在不断增长，那个五一节我真的非常兴奋，五一节每天ETH的涨幅都大大超出了我的预期，爽死了…时间马上来到了9月头上，当时我在临时宿舍里熬夜看着我的ETH翻倍了，这是我人生中的第一次投资的翻倍，我马上寻找了一家C2C，将现货兑换成人民币，看到银行卡的数字，我激动得一晚上都没太睡着。后来，Crypto产生了一个比较大规模的回撤，我在回撤结束时，又重新利用利润拿回来同等数量的ETH，但是，非常不幸，Binance在年底被我国政府限期撤离，我本来可以再次翻倍的现货账户，没办法，只能含泪退出了…其实国内的账户也没有真正地被清退，现在想起来真的是非常遗憾。第一次接触Crypto以来，币圈就给我带来了不菲的收入，让我对币圈这一样新奇的事物充满了正面的看法 <span class="github-emoji"><span>💯</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4af.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，在之后的那次Crypto价格腰斩的阶段，我没有持有任何仓位，这也保证了我的本金一方面可以回到比较稳定的股票市场，另一方面，也让我真正实现了收益，我是用这部分收益购买了一些个人需求地物品，另一方面，又重新投入了一部分Crypto。目前，我基本持有两大主流币，加上我的信仰币：币安币。</p><h2 id="现在为什么购买了Crypto？"><a href="#现在为什么购买了Crypto？" class="headerlink" title="现在为什么购买了Crypto？"></a>现在为什么购买了Crypto？</h2><p>我个人认为，虚拟货币是未来一个重要的财富集中地，一方面因为虚拟货币不受政府的控制，不会无限增发，其总量能够保持稳定，另一方面，在虚拟货币上搭建的Web3应用最近也是层出不穷，受到大家的追捧，当然，我在这里并没有要大家去购买Web3题材的虚拟币的意思。 <span class="github-emoji"><span>😃</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，此外，Crypto还具备黄金不具备的属性，可以快速地转移和交易。为了规避CEX的倒闭风险，我目前是将Crypto存入了币安旗下的Trust Wallet钱包中，这种钱包不会受到CEX的控制，非常的安全，并且也不会出现资金被盗、密钥忘记的情形，<span class="github-emoji"><span>💵</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4b5.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>。我认为，从长远来看，Crypto还是很有前景的，当前世界杯的大背景下，CZ与卡塔尔合作，在很多地方都使用了支持Binance交易的操作，我认为这是一种信号，标志着Crypto走入人们日常生活的可行性，包括现在各国央行也都在紧锣密鼓地推出自家地数字货币，我觉得是一种趋势，未来是虚拟货币的天下，我觉得是不会错的，希望我在四五十岁地时候，能够见到Bitcoin比肩黄金的情形，并且希望我能以自己的这段在时代的浪潮里冲浪的经历为傲。</p><h2 id="关于Binance最近的FUD"><a href="#关于Binance最近的FUD" class="headerlink" title="关于Binance最近的FUD"></a>关于Binance最近的FUD</h2><p>我个人认为Binance的FUD纯粹出于三方面原因，一方面是Binance在FTX倒下之后，处于Monopoly的状态，一方面SBF的金主看CZ不爽，另一方面，CEX交易所的利益相关者也看CZ不爽；另一方面是Binance一直处在没有被监管的状态，美国政府看CZ也很不爽；第三，最近孙割的火币也在奋力发展国际业务，看到占据市场绝大部分份额的Binance，孙割自然把他视作是假想敌了。俗话说，树<span class="github-emoji"><span>🌳</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f333.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>大招风。我觉得其实大可不必担心Binance的状况，因为CZ看上去就是一个非常靠谱的人；另一方面，Binance在Crypto市场中占据的作用告诉我们，如果Binance倒下了，那么Crypto必将遭受一场重创，所有参与者都会损失很大一部分资金。我认为在Binance中交易的交易者没必要离开，保持正常心态进行交易就好了，Binance倒下的概率微乎其微。为此，为了不让自己变成旁观者，我也持有了一部分BNB，以保证之后参与Binance Smart Chain的过程中，有相应的介质可以充当手续费和参与资格。</p><h2 id="关于现阶段的资产配置问题-heavy-exclamation-mark-NFA（Not-Finance-Advice）-heavy-exclamation-mark"><a href="#关于现阶段的资产配置问题-heavy-exclamation-mark-NFA（Not-Finance-Advice）-heavy-exclamation-mark" class="headerlink" title="关于现阶段的资产配置问题 :heavy_exclamation_mark:NFA（Not Finance Advice）:heavy_exclamation_mark:"></a>关于现阶段的资产配置问题 <span class="github-emoji"><span>❗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><em><strong>NFA（Not Finance Advice）</strong></em><span class="github-emoji"><span>❗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h2><p>我一直只信仰BTC、ETH、第三最多是你使用的交易所发行的Token（信仰Token）。所以，我也只推荐大家购买BTC、ETH这两种（NFA）。我目前也是自己只配置了这三种资产，我个人认为其他资产的投资理由非常牵强，没有很显著的意义。当然，也有可能有同学通过投资其他代币实现财富自由了，这也不妨碍我现阶段的决定。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>希望未来Crypto能够破除现在的阴霾，实现一种在Satoshi幻想中的属于全人类的货币<span class="github-emoji"><span>🌏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f30f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>❗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> Crypto </tag>
            
            <tag> Binance </tag>
            
            <tag> Ethereum </tag>
            
            <tag> Bitcoin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Github中的博客遇到的恶心问题</title>
      <link href="/2022/12/11/shi-yong-github-yu-dao-de-e-xin-wen-ti/"/>
      <url>/2022/12/11/shi-yong-github-yu-dao-de-e-xin-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="为啥最近突然用上Github了？"><a href="#为啥最近突然用上Github了？" class="headerlink" title="为啥最近突然用上Github了？"></a>为啥最近突然用上Github了？</h2><p>主要是使用Github对我的博客后台系统进行一个管理，目前我的博客系统如下图所示，</p><img src="/2022/12/11/shi-yong-github-yu-dao-de-e-xin-wen-ti/33610ac2732998e0369614d4c5c5e94c5101dfff34fdaa6025dee9c845a60462.png" class="" title="picture 1">  <p>可以看到，如果我需要将博客内容通过Ubuntu部署到Github，我就需要将Windows中编辑好的文件通过虚拟机软件传送至我的虚拟Ubuntu系统中，这一过程需要通过我的记忆对版本进行管理 <span class="github-emoji"><span>😥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f625.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，然而我的记忆里贼差，很容就会忘记 <span class="github-emoji"><span>❌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，所以这不是一个好的方案，那么怎么选取方案呢？ <span class="github-emoji"><span>🤔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>其实，可以通过直接在VScode中使用git管理我们的Blog代码就好了 <span class="github-emoji"><span>✔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>!然后把内容Push到我们的Github的私有仓库里面，再在虚拟机里面pull下来就ok了，这样不仅保证了我们可以在<code>.gitignore</code>文件中确保我们不想上传的信息，还可以保证我们的信息是同步的，那么就暂且得到了我还比较满意的一个解决方案 <span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h2 id="设置过程中踩到的一些雷"><a href="#设置过程中踩到的一些雷" class="headerlink" title="设置过程中踩到的一些雷"></a>设置过程中踩到的一些雷</h2><p>Github最近被墙了，<span class="github-emoji"><span>💢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a2.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>吐了吐了 <span class="github-emoji"><span>🤮</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f92e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，大概率是一些蠢蛋 <span class="github-emoji"><span>🖕</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f595.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>在这个美好的网站上搞了一些什么垃圾玩意儿。话说回来，Github被墙了，但我一直以来，一直觉得有危屁恩就问题不大，但是，没想到使用下面的语句验证Github链接情况的时候，遇到了各种各样的错误 <span class="github-emoji"><span>❌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><pre class=" language-shell"><code class="language-shell">ssh -T git@github.com</code></pre><p>我第一个想法就是我电脑没有办法访问Github，但实际上，我的电脑与Github直接的链接是畅通的 <span class="github-emoji"><span>✔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，出现问题的其实是与Github之间的验证问题。</p><h3 id="Github的ssh-key的设置"><a href="#Github的ssh-key的设置" class="headerlink" title="Github的ssh key的设置"></a>Github的<code>ssh key</code>的设置</h3><p>Github为了安全性，在ssh你的仓库时，需要进行验证操作，以前貌似可以使用用户名和密码进行验证，但是当前这个时间节点下，貌似已经不再可行了… <span class="github-emoji"><span>❌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，更好的方式是采用系统产生一个<code>ssh key</code>，这个key存在Github上，在需要连接的时候，本地提交这个key，Github端再对这个Key进行比对操作，验证登入者的身份 <span class="github-emoji"><span>✔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>。</p><p>在Github上如何设置ssh_key呢？其实很简单，你只需要访问你的账户，点击设置，里面有ssh_key添加的选项，但首先，你需要在本地生成一个ssh_key文件，如果没有这个文件你也是没有办法进行设置的。可以在需要设置的目录下打开命令提示符，一般Windows是<code>C:/Users/[Your_name]/.ssh/</code>、Linux是<code>~/.ssh/</code>这两个文件夹。</p><pre class=" language-shell"><code class="language-shell">ssh_keygen</code></pre><p>生成玩key之后还要配置一个Host文件夹，也是存放在相同的目录下的，具体内容大概是下面这样</p><pre><code>Host github.com    HostName github.com    IdentityFile ~/.ssh/id_rsa</code></pre><p>完成配置之后，再使用下面的语句访问应该就没有问题了。</p><pre class=" language-shell"><code class="language-shell">ssh -T git@github.com</code></pre><p>但是，还是可能会出现问题，理由是Github目前再国内属于被河蟹 <span class="github-emoji"><span>🦀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f980.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>的状态，因此，如果一个人想要访问Github需要合理地设置帆羟 <span class="github-emoji"><span>🌏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f30f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>的操作，可以采用下面的语句对Github的代理进行设置。</p><pre class=" language-shell"><code class="language-shell"># 设置socks的代理(只对Github代理)，192.168.xxx.xxx为你代理的IP地址git config --global http.https://github.com.proxy socks://192.168.xxx.xxx:10808# 设置http的代理(只对Github代理) 通常代理IP地址为主机(Master)的IP地址git config --global http.https://github.com.proxy http://192.168.xxx.xxx:10809# 取消代理git config --global --unset http.proxygit config --global --unset https.proxy# 查看现有代理配置信息git config --global -l</code></pre><p><span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 根据上面的命令进行代理设置就可以实现对Github的代理了<span class="github-emoji"><span>✔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，是不是非常方便呢 :+1:</p><p>基本上来说，我个人设置Github进行操作的坑在上面了，如果有其它坑我想起来的时候再记录一下吧… <span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h3 id="最近又连不上Github了"><a href="#最近又连不上Github了" class="headerlink" title="最近又连不上Github了"></a>最近又连不上Github了</h3><p>最近又连不上Github了，一直提示连接错误，这时候，需要设置一下<code>/etc/hosts</code>文件中的Github的IP地址，首先先使用如下命令获取Github的IP地址</p><pre><code>nslookup github.com 8.8.8.8</code></pre><p>然后使用管道将该表达式的输出部分的Github的IP内容通过管道传给<code>/etc/hosts</code>文件，即重置其中内容，使用如下命令，</p><pre><code>nslookup github.com 8.8.8.8 | awk -F 'Address: ' 'NF&gt;1{print $2}' | xargs -I {} echo {} github.com | sudo tee -a /etc/hosts</code></pre><p>在做这一步之前，需要先将<code>/etc/hosts</code>文件中的关于<code>Github</code>的内容清除，使用如下命令，</p><pre><code>sudo sed -i '/github/d' /etc/hosts</code></pre><p>最后，再清除<code>~/.ssh/</code>文件夹中的<code>known_hosts</code>中的内容，使用如下命令，</p><pre><code>:&gt;~/.ssh/known_hosts;</code></pre><p>最后，将上述所有命令组合成一个可执行脚本<code>initial.sh</code>，需要在每次与<code>Github</code>通信之前执行一遍即可，如下所示。</p><pre><code>:&gt;~/.ssh/known_hosts;sudo sed -i '/github/d' /etc/hostsnslookup github.com 8.8.8.8 | awk -F 'Address: ' 'NF&gt;1{print $2}' | xargs -I {} echo {} github.com | sudo tee -a /etc/hosts</code></pre><p>目前为止，解决了无法与Github连接的问题。</p>]]></content>
      
      
      <categories>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> 问题总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo图片插入问题</title>
      <link href="/2022/12/10/hexo-tu-pian-cha-ru-wen-ti/"/>
      <url>/2022/12/10/hexo-tu-pian-cha-ru-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="这个问题太恶心了-vomiting-face"><a href="#这个问题太恶心了-vomiting-face" class="headerlink" title="这个问题太恶心了 :vomiting_face:"></a>这个问题太恶心了 <span class="github-emoji"><span>🤮</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f92e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h2><p>这个问题找了我一下午，终于在这个链接<code>https://codeantenna.com/a/DBakKFeSq9</code>中找到说明，由于我之前安装的插件时<code>hexo-asset-image</code>，但实际上，这个插件貌似已经失效了，推荐使用这个插件<code>hexo-asset-img</code>，使用这个插件之后，就可以实现图片插入的操作了，根本原因大概是我手贱 <span class="github-emoji"><span>🖕</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f595.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>更新了一下hexo导致的吧 <span class="github-emoji"><span>😥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f625.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><p>卸载<code>hexo-asset-image</code>插件</p><pre class=" language-shell"><code class="language-shell">npm uninstall hexo-asset-image --save</code></pre><p>安装新的<code>hexo-asset-image</code>插件</p><pre class=" language-shell"><code class="language-shell">npm install hexo-asset-img --save</code></pre><p>检查你的根目录下的<code>_config.xml</code>文件中的<code>post_asset_folder</code>是否处于true状态，如下图所示，如果不是，需要修改。</p><img src="/2022/12/10/hexo-tu-pian-cha-ru-wen-ti/740410cd932716d5857071ace647e6a53bb1f87b6c2da0336a44398b7ace7c76.png" class="" title="picture 1">  <h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>快乐的周六搞了一下午，吐了吐了 <span class="github-emoji"><span>🤮</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f92e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客搭建 </tag>
            
            <tag> 问题汇总 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VScode根据输入自动snippet语句</title>
      <link href="/2022/12/09/vscode-gen-ju-shu-ru-zi-dong-snippet-yu-ju/"/>
      <url>/2022/12/09/vscode-gen-ju-shu-ru-zi-dong-snippet-yu-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="为啥突然需要这个功能？"><a href="#为啥突然需要这个功能？" class="headerlink" title="为啥突然需要这个功能？"></a>为啥突然需要这个功能？</h2><p>最近在写markdown的时候，由于markdown需要部署在博客，所以每次都需要写一个头，大概是下面这个样子的<span class="github-emoji"><span>😞</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f61e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><pre><code>---title: 标题名author: 南航古惑仔date: 2022-12-09 21:34:02tags:  - tag_1  - tag_2categories: catmathjax: true---</code></pre><p>每次需要复制增加了本懒人的痛苦，因为我有一个<code>非要用一个自动化的程序去完成一个死板的操作的</code>的强迫症，所以… <span class="github-emoji"><span>🧑🚀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f9d1-1f680.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h2 id="我是如何找到这个功能的"><a href="#我是如何找到这个功能的" class="headerlink" title="我是如何找到这个功能的"></a>我是如何找到这个功能的</h2><p>最近的chatGPT非常的好用，我求助Google，但是不知道是我英文水平有限还是什么，找不到对应的解答，为此，我描述给了chatGPT，chatGPT自动给我回答了 <span class="github-emoji"><span>😲</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f632.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><img src="/2022/12/09/vscode-gen-ju-shu-ru-zi-dong-snippet-yu-ju/91a9a7c5e4e3c3d26db908c9e798c82530fe7ab7c57039e192729b557a0f4d06.png" class="" title="picture 11">  <p>非常有趣，最近一段时间使用了chatGPT之后，感觉非常爽，很多之前的问题都得到了解决。例如，最近对VScode的使用又上升了一个台阶。</p><h2 id="那么如何设置呢？"><a href="#那么如何设置呢？" class="headerlink" title="那么如何设置呢？"></a>那么如何设置呢？</h2><p>这个设置非常简单，当你熟悉之后可以明白很多其他的设置该如何进行设置。我记得三年前我刚开始使用VScode的时候，那时候觉得VScode很帅，黑色的见面配上白色的文字，凸显了极致的极客风格，好像用上了VScode我就变成了黑客一样。哈哈哈，中二一下…当然，那时候用VScode的时候，知道插件的概念，当时下载了很多插件，希望VScode可以替代例如keil、eclipse等编辑器，当时发现插件都会让用户自行设置变量，我当时单纯的以为变量是在控制台中设置的。再加上当时的信息检索能力还比较差，根本不知道这些变量在哪里设置。当然，我今天是借助了chatGPT的能力学习了如何对这些参数的值进行设置。</p><img src="/2022/12/09/vscode-gen-ju-shu-ru-zi-dong-snippet-yu-ju/364f02606aa0ce9e4e0d97e89fb8183eb1734ddf3853c91a7f8324096ffdc53e.png" class="" title="picture 12">  <p>原来，这些参数是通过在settings中进行搜索就可以找到并设置的，哎，没想到这么简单，当时的我心气比较浮躁，对这些细节都没有搞清楚，以至于我一直觉得VScode比较难用，太迷了…<span class="github-emoji"><span>😞</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f61e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>这里我要给chatGPT再一个大大的好评！<span class="github-emoji"><span>👍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>简单来说，设置的话，需要进入settings选项中进行选择，进入选项之后可以直接检索变量名称，之后修改就可以了，当然你可以修改<code>JSON</code>文件，也可以对文本框直接修该，我个人觉得对<code>JSON</code>进行修改时更好的选择。</p><p>修改的时候还可以引入各种变量，一般是这种形式的：<code>${variable}</code>，可以进行对文件命名之类的操作，很不错很方便的<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>]]></content>
      
      
      <categories>
          
          <category> 编程小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vscode </tag>
            
            <tag> 提升效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中类的定义</title>
      <link href="/2022/12/09/python-zhong-lei-de-ding-yi/"/>
      <url>/2022/12/09/python-zhong-lei-de-ding-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="为啥突然做python了？"><a href="#为啥突然做python了？" class="headerlink" title="为啥突然做python了？"></a>为啥突然做python了？</h2><p>最近在b站上关注了一个up叫<strong>文俊de小迷妹</strong>，他是主要做期货量化交易的。我本身一直对量化交易这个领域就非常感兴趣，有一种使用策略进行搏斗的刺激的感觉 <span class="github-emoji"><span>💻</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4bb.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，又有一种极客的帅气的中二感，所以我非常像尝试一下。之前我主要做的程序都是使用java实现的，为什么使用java呢？因为当时学Java的时候感觉Java更加高级，并且很多大公司招聘都要Java工程师，从这里可以看出，我当时学Java是奔着找工作的目的学的。后来之所以没有找工作的需求了，这就是另外的故事了，在此就不说了。总而言之，我的编程语言的背景主要是C、C++、Java这类对类型非常明确的语言占据主导的。但是，量化交易的很多工具包都是适配python的，所以我就非常难受 <span class="github-emoji"><span>😥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f625.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，不过呢，现在有了chatGPT的加持之后，我就发现我上手一门编程语言可以非常快速 <span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>！无论怎么说，我感觉上手python是一件值得且不是那么困难的事情，所以我就开始做了。</p><h2 id="简单感受一下Python的类"><a href="#简单感受一下Python的类" class="headerlink" title="简单感受一下Python的类"></a>简单感受一下Python的类</h2><p>哎，现在chatGPT开始维护了，非常难受，你看看，说是维护之后再开启提供给大家使用… <span class="github-emoji"><span>😥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f625.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><img src="/2022/12/09/python-zhong-lei-de-ding-yi/17040fc60395c6a4d8d4bff3b365ecbdc66c6df68214effe9264395aba9e5d6d.png" class="" title="ChatGPT主页 :frowning_face:">  ]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 面向对象语言 </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>量化交易的首次尝试</title>
      <link href="/2022/12/09/liang-hua-jiao-yi-de-shou-ci-chang-shi/"/>
      <url>/2022/12/09/liang-hua-jiao-yi-de-shou-ci-chang-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>i<br>距离上次更新博客已经过了一年多了，这么长时间不更新博客的主要原因是因为自身的懒惰造成的，最近由于突发奇想，又想把博客捡起来了，所以在这里希望更新一下，那么就先从最近开始做的量化交易框架开始做起吧！</p><h3 id="为什么想到做量化交易？"><a href="#为什么想到做量化交易？" class="headerlink" title="为什么想到做量化交易？"></a>为什么想到做量化交易？</h3><p>因为最近股票一直亏钱…而且做长线实在是不够刺激，想寻求一些刺激的事情做做，让每天的生活充满激情，于是乎想到一种合法刺激多巴胺的方式，就是交易哈哈哈，Anyway，想用机器进行量化的交易的想法已经存在很久了，主要一直由于代码能力的限制，一直无法进行实现。最近本人完成了java的爬虫开发项目之后，加上chatGPT（这里手动狗头）的加持，愈发感觉身体内的一股代码的洪荒之力要喷射而出，刚好用在开发量化交易框架上，显得非常合适。</p><h3 id="目前做到哪一步了？"><a href="#目前做到哪一步了？" class="headerlink" title="目前做到哪一步了？"></a>目前做到哪一步了？</h3><p>说来惭愧，若干天的尝试仅仅实现了一个面向过程的MA5策略的回测，我甚至还不清楚回测的过程是否正确。</p><h3 id="未来有哪些计划？"><a href="#未来有哪些计划？" class="headerlink" title="未来有哪些计划？"></a>未来有哪些计划？</h3><p>本人像构建一个属于自己的回测系统，并且通过简单的策略，便可发现合适的买入信号，这一套回测系统能够以面向对象的模式进行开发，并且附加文档，能够在未来进行维护的时候实现一个便捷的维护方式。更进一步，当开发的内容达到一定规模之后，我想将本人这套量化系统开源在github上，吸引更多的开发者共同修改代码，以达到完善代码功能和满足更多需求的目的。</p><h2 id="本人目前的一些关于框架的想法"><a href="#本人目前的一些关于框架的想法" class="headerlink" title="本人目前的一些关于框架的想法"></a>本人目前的一些关于框架的想法</h2><p>因为本人不是计算机科班出身，可能下面有些想法在计算机专业的同学看来比较蠢，但本人认为初步来看还是合理的，未来可能在实现代码的过程中会有一些不一样的想法。</p><h3 id="问题的分解"><a href="#问题的分解" class="headerlink" title="问题的分解"></a>问题的分解</h3><ol><li>获得股票交易的买入和卖出信号;</li><li>通过某个quote的API对一段时间内的股票走势进行询价;</li><li>通过信号和询价数据对利润进行计算，并对买卖价格、手续费、手数、日期进行记录；</li><li>建立数据对象。</li></ol><h2 id="第一步先从基于包的设计开始"><a href="#第一步先从基于包的设计开始" class="headerlink" title="第一步先从基于包的设计开始"></a>第一步先从基于包的设计开始</h2><p>我的想法是，先不build from scratch，在经过我激烈的思想斗争之后，发现build from scratch一方面太消耗时间，另一方面，可能会存在回测系统并不符合标准，即存在bug的可能性；并且回测系统有可能考虑不完全，无意义地消耗我大量的时间。于是，基于上述分析，我打算先基于一些包进行设计，等到后面有经验之后，在进行回测系统的搭建。</p><h3 id="问题的分解-1"><a href="#问题的分解-1" class="headerlink" title="问题的分解"></a>问题的分解</h3><ol><li>股票数据获取</li><li>计算交易指标</li><li>设计交易策略：择时策略</li><li>设计交易策略：选股策略</li><li>数据回测与优化（Zipline）</li><li>实现实盘交易（EasyTrader）</li></ol><img src="/2022/12/09/liang-hua-jiao-yi-de-shou-ci-chang-shi/7d7309eeba97547dac57f1c0cc45133eb998c0edad2e8406b1c9f31851d109bb.png" class="" title="Python量化交易的基本框架">  <h3 id="股票数据获取"><a href="#股票数据获取" class="headerlink" title="股票数据获取"></a>股票数据获取</h3><p>之前我采用的是baostock的接口获取股票历史数据的，缺点是无法获取实时数据，如果需要历史数据进行回测还是有可行性的。目前，我在互联网上获知的一些接口包括天勤量化（期货接口），BigQuant、JoinQuant（免费近一年）等，可以接下去进行调研，貌似JoinQuant比较popular。</p><p>当然，我觉得到后期也可以自己实现一个数据接口，挂在自己的服务器上，就是不知道数据量的大小是不是非常大，可能需要评估这个的成本，提示：在Github上也有可能存在潜在的股票数据接口。</p><p>付费的股票数据接口有Wind和彭博，提供秒级的行情数据，可以获得最新最精准的交易数据。</p><p>对于基本面分析而言，基本面的数据的一手数据来源是企业的年报，企业的年报的来源主要是通过证券交易所的官网获取：</p><ul><li>上海证券交易所<a href="http://www.sse.com.cn/" target="_blank" rel="noopener">http://www.sse.com.cn/</a></li><li>深圳证券交易所<a href="http://www.szse.cn/" target="_blank" rel="noopener">http://www.szse.cn/</a></li><li>巨潮资讯网<a href="http://www.cninfo.com.cn/new/index" target="_blank" rel="noopener">http://www.cninfo.com.cn/new/index</a></li></ul><p>股票的年报中的最重要的章节就是财务报告，可以自行获取和学习。 </p><h3 id="计算交易指标"><a href="#计算交易指标" class="headerlink" title="计算交易指标"></a>计算交易指标</h3><ul><li>涨跌幅（shift函数）</li><li>计算买入卖出信号（where）</li><li>持仓收益（直接按照公式计算即可）</li><li>累计收益率（cumprod）</li><li>最大回撤（rolling计算最值）</li><li>夏普比率（每单位风险会产生多少超额报酬）</li></ul><p>$$SharpeRatio=\frac{E(R_P)-R_f}{\sigma_P}$$</p><p>其中$E(R_P)$为你的投资组合的预期收益，$R_f$年化无风险利率（比如国债的收益率3%），$\sigma_P$为你的投资组合的收益率的标准差。</p><p>相关的内容可以在如下链接里找到：<a href="https://github.com/Delta-F/DeltaTrader" target="_blank" rel="noopener">https://github.com/Delta-F/DeltaTrader</a></p><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="财务指标查询"><a href="#财务指标查询" class="headerlink" title="财务指标查询"></a>财务指标查询</h3><img src="/2022/12/09/liang-hua-jiao-yi-de-shou-ci-chang-shi/7777765b70ed501d7d2a34816639938a3cba55418eb366f80efac261ff6a2a7d.png" class="" title="财务报表的分类与内涵">  <ul><li>资产负债表 体现企业家底和负债情况</li><li>利润表 公司盈利能力、赚了多少、怎么赚的隐含着对未来利润增长的预期，体现了市场空间、成长能力</li><li>现金流量表 权责发生制与收付实现制，利润表是权责发生制，是当签订合同后，默认我的利润表里马上就有体现；而现金流量表是权责发生制，是当现金到账后才会有体现。</li></ul><h3 id="常用财务指标"><a href="#常用财务指标" class="headerlink" title="常用财务指标"></a>常用财务指标</h3><ul><li>eps（每股收益） 净利润/股本数</li><li>operating_profit 收入-成本</li><li>roe（净资产收益率）归属于母公司两倍的净利润/净资产，相当于公司一定资产下的产出，反映了盈利能力，净资产的使用能力，回报率。</li><li>inc_net_profit_year_on_year（净利润同比增长率）</li></ul><h3 id="如何对企业进行估值"><a href="#如何对企业进行估值" class="headerlink" title="如何对企业进行估值"></a>如何对企业进行估值</h3><img src="/2022/12/09/liang-hua-jiao-yi-de-shou-ci-chang-shi/19f3a8fddd684b32be4b78730a5c994e1459da9d2cdc4603cb42168444891936.png" class="" title="估值方法的分类"> <h4 id="绝对估值法"><a href="#绝对估值法" class="headerlink" title="绝对估值法"></a>绝对估值法</h4><p>计算了企业的内在价值，很难去真正估算股票的价值，并且估值法比较复杂，例如现金流折现模型等。</p><h4 id="相对估值法"><a href="#相对估值法" class="headerlink" title="相对估值法"></a>相对估值法</h4><img src="/2022/12/09/liang-hua-jiao-yi-de-shou-ci-chang-shi/f1c0978851f70824da6c5b18a5709a43b780de1574d3eecbb4e9e4630037e69e.png" class="" title="相对估值法">  <h3 id="夏普比率"><a href="#夏普比率" class="headerlink" title="夏普比率"></a>夏普比率</h3><p>$R_f$国债年化回报$3%$左右，投资回报率的标准差$\sigma_P$</p><p>$$SharpeRatio=\frac{E(R_P)-R_f}{\sigma_P}$$</p><p>表示了投资者额外承受的每一单位的风险所获得的额外收益，所以$Sharp Ratio$越高越好。</p><h3 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h3><h4 id="t-test"><a href="#t-test" class="headerlink" title="t-test"></a>t-test</h4><img src="/2022/12/09/liang-hua-jiao-yi-de-shou-ci-chang-shi/4fa9b83139cffa819ea4a0f5756aeecc7ecea853337e11d766bb119898175dfb.png" class="" title="t-test">  <h2 id="量化交易系统"><a href="#量化交易系统" class="headerlink" title="量化交易系统"></a>量化交易系统</h2><h3 id="基本框图"><a href="#基本框图" class="headerlink" title="基本框图"></a>基本框图</h3><img src="/2022/12/09/liang-hua-jiao-yi-de-shou-ci-chang-shi/75c412bc3b61ee66eda4e70724c813492541d3a4164b68ae98d907ae20c86af6.png" class="" title="量化交易平台的功能模块">  <h3 id="创建自己的股票数据库"><a href="#创建自己的股票数据库" class="headerlink" title="创建自己的股票数据库"></a>创建自己的股票数据库</h3><img src="/2022/12/09/liang-hua-jiao-yi-de-shou-ci-chang-shi/d6f97d0c78a58c3059b594e03b20082140de24b1052da211e5df3d4041e71672.png" class="" title="获取数据的两种方式">  <h3 id="最大回撤"><a href="#最大回撤" class="headerlink" title="最大回撤"></a>最大回撤</h3><img src="/2022/12/09/liang-hua-jiao-yi-de-shou-ci-chang-shi/a3e1335857541aab6311b9456885087acbd6d7837bde8a94639f6ee93ae3455f.png" class="" title="什么是最大回撤"><p>$$<br>MDD=\frac{ThroughValue-Peak Value}{Peak Value}<br>$$</p><p>其中$ThroughValue$指低谷值，$PeakValue$指最大值</p>]]></content>
      
      
      <categories>
          
          <category> 量化交易 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 量化交易 </tag>
            
            <tag> 生活碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复数信号分析技术总结</title>
      <link href="/2021/06/06/fu-shu-xin-hao-fen-xi/"/>
      <url>/2021/06/06/fu-shu-xin-hao-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="动机分析"><a href="#动机分析" class="headerlink" title="动机分析"></a>动机分析</h2><p>在射频收发机中，如果引入本文所述的复数信号分析技术对收发机的模块进行阐释和分析，将会大大减小分析的难度。在这里，我们先简单介绍一下射频收发机的设计以及在射频收发机设计过程中，需要解决的几个问题。</p><h3 id="双边带调制带宽的浪费"><a href="#双边带调制带宽的浪费" class="headerlink" title="双边带调制带宽的浪费"></a>双边带调制带宽的浪费</h3><p>双边带调制系统将原有信号调制后，会将信号的带宽扩展为原先的两倍。这个现象的机理是，基带信号通常是一个低频信号，信号的带宽假设为$0\sim\omega_0$，则信号从低频调制到中频时，如图1所示，</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/1.png" class="" title="零中频双边带信号频谱示意图"><p>由于负边带的存在，信号整体作移动（调制）时，原先带宽为$\omega_0$的信号，带宽将会被扩展到$2\omega_0$。这里就出现了带宽的浪费，原因是在调制后的带宽为$2\omega_0$的信号中，信号的左半边频谱与右半边是完全相同的，为了节约带宽，我们可以将左半边频谱用某种方法去掉，从而达到了节省带宽的目的。</p><h3 id="双边带接收机的设计问题"><a href="#双边带接收机的设计问题" class="headerlink" title="双边带接收机的设计问题"></a>双边带接收机的设计问题</h3><p>双边带接收机接受信号时，如果对信号进行零中频处理，意思就是将载波频率降为0时，信号原先的负频谱的会和信号的正频谱发生混叠，造成信息的丢失，很显然，将接收到的信号直接进行下变频以及检波处理是绝对不可行的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>基于上述两点原因，我们考虑到是不是可以将原信号，也就是将待调制的低频信号的左半边和右半边频谱取出，这样就直接解决了我们双边带系统的问题了。</p><h2 id="射频发射机概述"><a href="#射频发射机概述" class="headerlink" title="射频发射机概述"></a>射频发射机概述</h2><p>一般来讲，射频发射机由振荡器、调制器、功率放大器、带通滤波器组成。调制的方式一般来说有双边带调制以及单边带调制两种典型的发射机结构。单边带调制相对于双边带调制来说，可以节约一半的频谱资源，是更优的调制设计；但是单边带相较于双边带来说，增加了调制系统的复杂程度。</p><h2 id="射频接收机概述"><a href="#射频接收机概述" class="headerlink" title="射频接收机概述"></a>射频接收机概述</h2><p>射频接收机主要是讲接受到的射频信号下变频到可以处理的信号范围，再由DSP进行解调操作。射频接收机在将射频信号下变频时，同时也会将镜像信号变频到同样的频谱位置，造成信息的丢失。镜像信号在实际应用中，有可能是相邻信道上的干扰信号，或者是别的频段的信号，恰巧与需要下混频的射频信号关于载频对称。图2描述了镜像信号和目标信号进行实信号混频时，会在同一个中频上混叠在一起的示意图。</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/2.png" class="" title="信号下变频时镜像信号干扰原理图"><h2 id="镜像信号的消除"><a href="#镜像信号的消除" class="headerlink" title="镜像信号的消除"></a>镜像信号的消除</h2><p>这里存在的问题就是镜像信号和目标信号同时被变频到同一个频率上，导致我们的目标信号与镜像信号混叠，产生信息的丢失。下面介绍几种常见的抑制镜像信号的方法。</p><h3 id="采用普通LC滤波器进行镜像信号的消除"><a href="#采用普通LC滤波器进行镜像信号的消除" class="headerlink" title="采用普通LC滤波器进行镜像信号的消除"></a>采用普通LC滤波器进行镜像信号的消除</h3><p>假设在GSM系统中，在900MHz频点上，需要实现对相邻信道35dB的抑制比，若采用普通LC滤波器对镜像信号进行滤除，黄色的虚线代表了滤波器的传输函数，如图3所示，</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/3.png" class="" title="滤波器抑制镜像信号示意图"><p>如果目标信号比镜像信号的功率小很多的话，就会出现目标信号被镜像信号覆盖的情况吗，为了保证镜像信号幅度小于目标信号，我们需要对镜像信号进行滤波操作，假设滤波器在镜像信号频率处可以将该频点信号抑制35dB；在我们的假设中，镜像信号幅度比目标信号大20dB。这样一来，镜像信号通过滤波器之后，就会比目标信号小15dB，可以满足要求。尽管从理论分析来说，貌似是可行的，但是如果我们从LC电路的可实现性角度来考虑，就不可实现了。</p><h3 id="采用普通LC滤波器的问题"><a href="#采用普通LC滤波器的问题" class="headerlink" title="采用普通LC滤波器的问题"></a>采用普通LC滤波器的问题</h3><p>下面对LC电路的Q值进行分析，首先对滤波器的阻抗进行分析，假设LC滤波器不理想，存在一个等效并联电阻，那么，就会变成一个如图4所示的电路，</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/4.png" class="" title="LC带通滤波器电路"><p>下图中，$R_{epr}$是电感上等效出来的一个并联等效电阻，表示了电感的非理想性，在电路中的$R_s$表示了电压源的内阻。下式表示了$R_{epr}$、$L$、$C$并联组成的阻抗网络的阻抗。</p><p>$$<br>Z_T(s)=\frac{R_{epr}Ls}{R_{epr}LCs^2+Ls+R_{epr}}<br>$$</p><p>从上式中，我们可以取模后平方，得到如下式子，</p><p>$$<br>\left | Z_T(jw)\right |^2=\frac{L^2\omega^2}{(1-LC\omega^2)^2+L^2\omega^2/R^2}<br>$$</p><p>其中，</p><p>$$<br>\frac{L^2\omega^2}{R^2}=2.504\times10^{-10}<br>$$</p><p>那么我们可以获得$Q$的值，</p><p>$$<br>Q=\frac{R}{L\omega}=63200<br>$$</p><p>上述这个Q值用普通的LC滤波器一般来将无法实现。</p><h3 id="采用超外差式接收机对镜像信号进行抑制"><a href="#采用超外差式接收机对镜像信号进行抑制" class="headerlink" title="采用超外差式接收机对镜像信号进行抑制"></a>采用超外差式接收机对镜像信号进行抑制</h3><p>这种超外差接收机采用两次变频的方式，提高了中频的频率，实现了对镜像信号的充分抑制，图5是一个超外差接收机的示意图。可以看到，在接收信号时，信号首先进入了一个频带选择滤波器，将多余的频率分量滤除，之后进入一个低噪放中进行放大，再进入镜像抑制滤波器，将镜像信号滤除。这里由于第一次变频的中频频率比较高，所以用于滤除镜像信号的滤波器比较容易实现。</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/5.png" class="" title="超外差接收机"><p>图6是一个超外差接收机的实例，接收到的信号通过一个881MHz的带通滤波器，将镜像信号滤除，之后转换为一个中频信号，频带宽度为45MHz。由于中频信号的频带宽度大，在这种情形下，LC带通滤波器的制作难度大大降低，但仍需要一个外置的晶体滤波器。之后，用一个44.5MHz的信号瞄准我们的目标信号，进一步降低信号的频率至455kHz，之后采用的滤波器都是陶瓷滤波器。可以看到，这些所谓的陶瓷滤波器、晶体滤波器都是不可以集成的，这就意味着信号要进出芯片多次，每一次进出芯片都要进行阻抗匹配，阻抗匹配的接口一般来说都是$50\Omega$或者$75\Omega$的电阻，这会带来巨大的功率消耗，对于低功耗场景产生不利影响。</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/6.png" class="" title="超外差接收机实例"><h3 id="采用直接变频接收机对镜像信号进行抑制"><a href="#采用直接变频接收机对镜像信号进行抑制" class="headerlink" title="采用直接变频接收机对镜像信号进行抑制"></a>采用直接变频接收机对镜像信号进行抑制</h3><h4 id="哈特利结构接收机模型"><a href="#哈特利结构接收机模型" class="headerlink" title="哈特利结构接收机模型"></a>哈特利结构接收机模型</h4><p>那么，有没有什么办法可以不使用滤波器，还能将镜像信号抵消呢？当然是可以的。在这里我们存在的问题就是变频之后，镜像信号也会被变频到同一个频率上。只要我们用某种方式，不通过滤波器，通过将变频后的镜像信号构造为相反的两个信号，便可以将镜像信号抵消。如果要使用上述将镜像信号构造为相反的两个信号的方法，就需要两路处理单元，分别对信号进行变频后，形成可以相互抵消的两路信号。之前，我们所采用的结构只有一路，采用了只包含cos或者sin分量的本地晶振，不妨假设我们的本地震荡源为$cos(\omega_{LO}t)$、目标信号为$cos(\omega_{c}t)$、镜像信号为$cos(\omega_{m}t)$，其中，$\omega_m&lt;\omega_c$，那么，变频之后的结果如下，</p><p>$$<br>\frac{1}{4}(e^{j\omega_ct}+e^{-j\omega_ct})(e^{j\omega_{LO} t}+e^{-j\omega_{LO} t})=\frac{1}{2}(cos(\omega_c+\omega_{LO})t+cos(\omega_{c}-\omega_{LO})t)<br>$$</p><p>$$<br>\frac{1}{4}(e^{j\omega_mt}+e^{-j\omega_mt})(e^{j\omega_{LO} t}+e^{-j\omega_{LO} t})=\frac{1}{2}(cos(\omega_m+\omega_{LO})t+cos(\omega_{m}-\omega_{LO})t)<br>$$</p><p>在频谱上可以体现为如图7所示的变化，</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/7.png" class="" title="cos分量变频后的镜像和目标信号示意图"><p>可以看到，在cos分量的载波作用下，信号仅仅是在频谱上发生水平移动，并没有在频谱上体现出180°相位的变化。我们需要使用某种方式，构造出在频谱上体现180°相位变化的信号，不妨先看一下sin分量作为本地振荡源的变频结果，</p><p>$$<br>\frac{1}{4j}(e^{j\omega_ct}+e^{-j\omega_ct})(e^{j\omega_{LO} t}-e^{-j\omega_{LO} t})=\frac{1}{2}(sin(\omega_c+\omega_{LO})t-sin(\omega_{c}-\omega_{LO})t)<br>$$</p><p>$$<br>\frac{1}{4j}(e^{j\omega_mt}+e^{-j\omega_mt})(e^{j\omega_{LO} t}-e^{-j\omega_{LO} t})=\frac{1}{2}(sin(\omega_m+\omega_{LO})t+sin(\omega_{LO}-\omega_{m})t)<br>$$</p><p>使用sin震荡源进行变频时，可以看到，镜像信号滞后了$\frac{\pi}{2}$的相位而原信号超前了$\frac{\pi}{2}$的相位。如果我们继续对变频后的信号延迟$\frac{\pi}{2}$的相位的话，则镜像信号就可以产生一个有$\pi$相位差的信号，此时原信号并没有产生任何的相位变化。下面的式子表示了信号再延后$\frac{\pi}{2}$个相位的结果，其中，$\omega_{IF}=\omega_{c}-\omega_{LO}=\omega_{LO}-\omega_{m}$。</p><p>$$<br>\frac{1}{2}((sin(\omega_{LO}+\omega_c)t-\frac{\pi}{2})+sin((\omega_{LO}-\omega_{c})t-\frac{\pi}{2}))=\frac{1}{2}(-cos(\omega_{LO}+\omega_c)t+cos(\omega_{IF})t)<br>$$</p><p>$$<br>\frac{1}{2}(sin((\omega_m+\omega_{LO})t-\frac{\pi}{2})+sin((\omega_{LO}-\omega_{m})t-\frac{\pi}{2})<br>)=\frac{1}{2}(-cos(\omega_m+\omega_{LO})t-cos(\omega_{IF})t)<br>$$</p><p>可以看到，如果我们将本振信号为cos分量变频后的信号与本振信号为sin分量变频且延迟$\frac{\pi}{2}$相位的信号加起来，则镜像信号就可以完全被抵消。上述采用sin分量作为本振信号，且延时$\frac{\pi}{2}$的过程可以用图8中的频谱变化来表示。</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/8.png" class="" title="sin分量变频且延时后的镜像和目标信号示意图"><p>其中，第二幅图中，采用phasor图描述了一个sin信号，处于正频率的分量可以视为在实轴与虚轴组成的平面上逆时针旋转，处于负频率的分量可以视为在实轴与虚轴组成的平面上顺时针旋转。因此，两个分量的信号都可以被认为是在cos信号的基础之上延迟了$\frac{\pi}{2}$的相位。此外，为了绘图便利，在第三幅图中，表述了sin信号与第一幅图中表示的目标信号和镜像信号的乘积，并没有将图形绘制成三维的模型，读者可以自行想象，将第三幅图与第二幅图联系起来，则幅值在$\frac{j}{2}$方向的信号分量可以看作是沿纸面朝外的信号分量，而幅值在$-\frac{j}{2}$方向上的信号可以视为沿纸面向里的信号分量。第四幅图表示将第三幅图表示的信号延迟了$\frac{pi}{2}$的相位之后得到的信号频谱，其中，正频率部分延迟$\frac{pi}{2}$可以表示为将正频率部分在沿虚轴和实轴组成的平面上顺时针旋转90°，而负频率部分延迟$\frac{pi}{2}$可以表示为将负频率部分的分量在沿虚轴和实轴组成的平面上逆时针旋转90°。上述信号处理的模型可以表示为如下的系统框图，这就是有名的哈特利镜像抑制接受结构。<strong>哈特利结构本质上是</strong>在sin为本振信号的一路将目标信号的相位超前90°，镜像信号的相位滞后90°，再之后，将目标信号和镜像信号的相位都滞后90°，这样一来，镜像信号相位滞后180°，而目标信号的相位没有滞后。再将cos分量作为本振信号的变频后的信号与sin分量作为本振信号且延迟的信号相加，镜像信号就能够被抵消，目标信号叠加之后仍然存在。</p><p>图9给出了一个典型的哈特利镜像抑制结构的电路框图，在复信号分析的部分中，会采用更加简洁的分析方法对该电路框图进一步进行分析。</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/9.png" class="" title="哈特利镜像抑制接收结构"><h4 id="Weaver结构接收机模型"><a href="#Weaver结构接收机模型" class="headerlink" title="Weaver结构接收机模型"></a>Weaver结构接收机模型</h4><p>有时候，延时90°的结构在电路中很难实现，于是，Weaver结构的镜像抑制接收机模型被提出。Weaver接收机模型如图10所示，</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/10.png" class="" title="Weaver镜像抑制接收结构"><p>这个模型采用了两个中频的结构，因此，有两组本振信号，分别为$\omega_1$和$\omega_2$。其中第一组本振信号的角色和哈特利结构中的本振信号角色完全相同，都是将一路信号中的目标信号和镜像信号进行频谱搬移操作；而另一路信号中的目标信号相位超前90°，而镜像信号滞后90°。但是，与哈特利结构的接收机不同的是，Weaver结构采用了新的设计来实现了相位的延迟。Weaver结构瞄准一号中频的左侧对信号继续进行变频，目标信号被继续超前90°；同时，镜像信号也被超前90°。由于目标信号已经被超前90°，镜像信号已经被滞后90°，因此，目标信号最终被超前180°，镜像信号保持不变。为了将目标信号取出，只需将cos路的信号与sin路的信号相减即可得到目标信号，消除镜像信号。读者可以根据图11给出的频谱变化图来仔细分析上述过程。</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/11.png" class="" title="Weaver镜像抑制sin路原理频谱示意图"><p>综上所述，<strong>Weaver结构的接收机模型的本质是</strong>，先用第一个本振信号瞄准目标信号和镜像信号中间，目标信号在镜像信号的右侧，即目标信号频率大于镜像信号，这一步的结果导致镜像信号被滞后90°，目标信号被超前90°。紧接着，再用第二个本振信号瞄准第一个中频信号的左侧，进一步变频，这一步的结果是，镜像信号和目标信号都被超前90°。最后，由于目标信号被超前90°两次，因此，目标信号最后被超前180°；镜像信号先是被滞后90°，之后又被超前90°，因此，镜像信号维持不变。将cos支路处理后的信号与sin支路处理后的信号相减，即可得到最后的消除镜像信号的目标信号。</p><h2 id="复数信号分析"><a href="#复数信号分析" class="headerlink" title="复数信号分析"></a>复数信号分析</h2><p>尽管直接变频接收机消除了镜像滤波器可制造性的问题，在电路中去除了滤波器结构，但仍然存在问题。这些问题可以被更加优化的结构解决，但需要先介绍复数信号分析这一有用工具，帮助我们可以理解更加复杂的镜像抑制结构。</p><h3 id="复数信号的基本概念"><a href="#复数信号的基本概念" class="headerlink" title="复数信号的基本概念"></a>复数信号的基本概念</h3><ul><li>在这里，我们给定$I$代表实部信号，给定$Q$代表虚部信号。</li><li>设$I$路信号为$A$，$Q$路信号为$B$，则该复数信号表示为$A+jB$。</li><li>复数信号中的虚数单位符号用$j$表示，代表了复数信号的虚部。</li></ul><h3 id="复数信号的运算法则"><a href="#复数信号的运算法则" class="headerlink" title="复数信号的运算法则"></a>复数信号的运算法则</h3><p>为了方便后期电路的实现，这里给出了复数信号的运算法则和对应的电路结构。</p><h4 id="一、加（减）法法则"><a href="#一、加（减）法法则" class="headerlink" title="一、加（减）法法则"></a>一、加（减）法法则</h4><p>下式表述了复数信号加法遵循的数学规则，</p><p>$$<br>\begin{cases}<br>  Y_I=X_{1_I}+X_{2_I}\<br>  Y_Q=X_{1_Q}+X_{2_Q}<br>\end{cases}<br>$$</p><p>图12表示了复数信号加法的电路框图结构，</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/12.png" class="" title="复数信号加法框图"><p>复数信号加法遵循实部相加，虚部相加的规则，只要将虚部和实部分别相加，最后即可得到结果对应的虚部和实部。</p><h4 id="二、乘（除）法法则"><a href="#二、乘（除）法法则" class="headerlink" title="二、乘（除）法法则"></a>二、乘（除）法法则</h4><p>下式表述了复数信号乘法与除法遵循的数学规则，</p><p>$$<br>\begin{cases}<br>  Y_I=X_{1_I}\cdot X_{2_I}-X_{1_Q}\cdot X_{2_Q}\<br>  Y_Q=X_{1_I}\cdot X_{2_Q}+X_{1_Q}\cdot X_{2_I}<br>\end{cases}<br>$$</p><p>上式表明，复数信号乘法与复数乘法类似，都是交叉项相乘之和为虚部，同类项相乘之和为实部。要特别注意，在实部中，两个虚数同类项相乘之和是负的。</p><p>图13表示了复数信号乘法的电路框图结构，</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/13.png" class="" title="复数信号乘法框图"><h4 id="三、传输函数不变法则"><a href="#三、传输函数不变法则" class="headerlink" title="三、传输函数不变法则"></a>三、传输函数不变法则</h4><p>假设$I$、$Q$两路的传输函数都为$H(\omega)$，其复数信号传输函数也为$H(\omega)$。这一性质可以由线性系统的叠加性推导得到。图14是该性质的系统示意图，</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/14.png" class="" title="传输函数不变法则的系统示意图"><h4 id="四、复数信号滤波"><a href="#四、复数信号滤波" class="headerlink" title="四、复数信号滤波"></a>四、复数信号滤波</h4><p>一般来讲，滤波器的传输函数都是关于Y轴对称的，这里，引入一个全新的概念，通过复数信号分析方法设计的滤波器，可以令其传输函数关于任意位置的纵轴对称。</p><p>首先，先引入一个低通滤波器，$H(\omega)$，该滤波器的传输函数如下，</p><p>$$<br>H(\omega)=\frac{1}{j\omega+\omega_b}<br>$$</p><p>该滤波器的3dB带宽为$\omega_b$，可以绘制出如图15所示的传输函数，</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/15.png" class="" title="低通滤波器传输函数"><p>那么，思考下面的一个问题，如何将滤波器的传输函数向右平移呢？方法很简单，只需要在传输函数上做如下的改动，便可以得到一个新的传输函数，$H_{complex}(\omega)$,</p><p>$$<br>H_{complex}(\omega) = \frac{1}{j(\omega-\omega_0)+\omega_b}<br>$$</p><p>那么，如何在电路上实现这一操作呢？我们可以参考如图16所示的电路结构，</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/16.png" class="" title="低通滤波器传输函数"><p>先看右边的图，根据之前讨论过的传输函数不变法则，对于虚部和实部共同作用的同一个传输函数，等同于对整体进行作用。我们可以将虚部&amp;实部输入信号看做一个整体$X$，那么，右图结构就是一个反馈环路，根据反馈环路的性质，我们可以写出这个电路结构的闭环传输函数，如下</p><p>$$<br>H_{closedloop}(\omega)=\frac{H(\omega)}{1-jR(\omega)H(\omega)}<br>$$</p><p>将我们之前假设的传输函数代入，再假设$R(\omega)=\omega_0$，有，</p><p>$$<br>H_{closedloop}(\omega)=\frac{\frac{1}{j\omega+\omega_b}}{1-j\omega_0\frac{1}{j\omega+\omega_b}}<br>$$</p><p>化简有，</p><p>$$<br>H_{closedloop}(\omega)=\frac{1}{j(\omega-\omega_0)+\omega_b}<br>$$</p><p>上述式子表明，我们获得了一个复数信号滤波器，该滤波器的传输函数不再是关于Y轴中心对称，而是关于$x=\omega_0$中心对称，下图是该滤波器的传输函数，</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/17.png" class="" title="复数信号低通滤波器传输函数"><p>根据上述分析，我们已经构造出了一个复数信号滤波器，通过这个滤波器，我们可以实现很多种类的复数信号处理。</p><h4 id="五、复数信号混频"><a href="#五、复数信号混频" class="headerlink" title="五、复数信号混频"></a>五、复数信号混频</h4><p>复数信号混频定义为两个复数信号相乘，两个复数信号相乘，可以适用本文之前论述的复数信号乘法法则。复数信号混频可以用下式表示，</p><p>$$<br>Y=X\cdot[cos(\omega_{LO}t)+jsin(\omega_{LO}t)]=(X_I+jX_Q)\cdot e^{j\omega_{LO}t}<br>$$</p><p>图18所示的框图描述了复数信号进行混频的电路框图，从框图中可以看到，如果对I路和Q路组成的复数信号进行变频的话，使用该电路结构便可以得到对应的I路和Q路输出。</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/26.png" class="" title="复数信号低通滤波器传输函数"><h4 id="六、复数信号取实部"><a href="#六、复数信号取实部" class="headerlink" title="六、复数信号取实部"></a>六、复数信号取实部</h4><p>对于$I$路和$Q$路组成的复数信号而言，我们可以了解到，$I$路代表了实部，$Q$路代表了复数，因此，如果要取实部的话，只需要取出$I$路上的信号即可。</p><h4 id="七、复数信号取实部（保留正频率部分）"><a href="#七、复数信号取实部（保留正频率部分）" class="headerlink" title="七、复数信号取实部（保留正频率部分）"></a>七、复数信号取实部（保留正频率部分）</h4><p>假设我们有一个复数信号，</p><p>$$<br>X=(A+jB)e^{j\omega t}<br>$$</p><p>该复数信号的实部为，</p><p>$$<br>X_I=Acos(\omega t)-Bcos(\omega t)<br>$$</p><p>亦可表示为下式，</p><p>$$<br>X_{Re}=\frac{A+jB}{2}e^{j\omega t}+\frac{A-jB}{2}e^{-j\omega t}<br>$$</p><p>同理，一个复数信号的虚部为，</p><p>$$<br>X_{Im}=\frac{A+jB}{2j}e^{j\omega t}-\frac{A-jB}{2j}e^{-j\omega t}<br>$$</p><p>可以看到，在上面的式子中，正频率部分的实部相当于虚部乘了一个$j$。因此，这就为我们提取正频率部分实部提供了思路。</p><p>那么如何提取正频率的实部呢？很简单，我们只需要将虚数路也就是$Q$路的信号乘一个90°再与实部信号，也就是$I$路信号，相加；或者除一个90°，再用此信号减去$I$路信号。最后即可得到我们的正频率取实部的信号。这里方案一的框图如图19所示，</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/19.png" class="" title="复数信号取实部（保留正频率部分）方案一"><p>其中A代表了$Q$路信号，B代表了$I$路信号。</p><p>方案二的框图如图20所示，</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/20.png" class="" title="复数信号取实部（保留正频率部分）方案二"><p>上述两个方案要对正频率取实部，都是要在Q路上进行相位的延迟或者超前。上述操作在频谱上表现为，将负频率部分删去，将正频率部分复制到负频率部分，具体表现为下面图21中表示的频谱。</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/21.png" class="" title="复数信号取实部（保留正频率部分）频谱示意图"><h4 id="八、复数信号取实部（保留负频率部分）"><a href="#八、复数信号取实部（保留负频率部分）" class="headerlink" title="八、复数信号取实部（保留负频率部分）"></a>八、复数信号取实部（保留负频率部分）</h4><p>复数信号保留负频率部分取实部的操作也很简单，再来分析下面的表达式，</p><p>$$<br>X_{Re}=\frac{A+jB}{2}e^{j\omega t}+\frac{A-jB}{2}e^{-j\omega t}<br>$$</p><p>$$<br>X_{Im}=\frac{A+jB}{2j}e^{j\omega t}-\frac{A-jB}{2j}e^{-j\omega t}<br>$$</p><p>从上面的式子中可以看到，如果要只取出负频率，只需要乘以一个$-j$，再将虚部$Q$路与实部$I$路相加即可，在电路中，相当于移相$-90°$，再将两路相加，可以由图22中表示的电路框图构造实际电路。</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/27.png" class="" title="复数信号取实部（保留负频率部分）频谱示意图"><h4 id="九、实数信号变复数信号（保留正频率部分）"><a href="#九、实数信号变复数信号（保留正频率部分）" class="headerlink" title="九、实数信号变复数信号（保留正频率部分）"></a>九、实数信号变复数信号（保留正频率部分）</h4><p>对于实数信号变复数（保留正半轴）对应了保留正半轴，将负频率部分删去的操作。为了达成上述目标只需要将原先的实数信号设定为实部，再构造出虚部即可。</p><p>$$<br>X_{Re}=\frac{A+jB}{2}e^{j\omega t}+\frac{A-jB}{2}e^{-j\omega t}<br>$$</p><p>$$<br>X_{Im}=\frac{A+jB}{2j}e^{j\omega t}-\frac{A-jB}{2j}e^{-j\omega t}<br>$$</p><p>由上文所述，实数部分与虚数部分之间的关系可知，只需要除以一个$j$即可由实数部分的到虚数部分，即乘以一个$-j$。在实际电路中，除以j对应了相位滞后90°。</p><p>因此，上述方法描述的电路实现框图可以由图23表示，</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/22.png" class="" title="实数信号变复数（保留正频率部分）电路实现框图"><p>上述方法对应的频谱图如图24所示，</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/23.png" class="" title="实数信号变复数（保留正频率部分）频谱示意图"><p>可以看到，原先的正频率部分被保留了下来，删去了负频率的部分。</p><h4 id="十、实数信号变复数信号（保留负频率部分）"><a href="#十、实数信号变复数信号（保留负频率部分）" class="headerlink" title="十、实数信号变复数信号（保留负频率部分）"></a>十、实数信号变复数信号（保留负频率部分）</h4><p>对于实数信号变复数信号，只保留负频率部分的操作，其实也是非常简单的。因为输入信号是一个实数信号，那么我们只需要将输入信号除以一个$-j$，便可以得到负频率对应的虚部信号。</p><p>$$<br>X_{Re}=\frac{A+jB}{2}e^{j\omega t}+\frac{A-jB}{2}e^{-j\omega t}<br>$$</p><p>$$<br>X_{Im}=\frac{A+jB}{2j}e^{j\omega t}-\frac{A-jB}{2j}e^{-j\omega t}<br>$$</p><p>在实际电路中，除以$-j$对应了相位超前90°。因此，上述方法描述的电路实现框图可以由图23中，将移相网络由-90°更改为90°来表示。</p><h2 id="总结-amp-案例分析"><a href="#总结-amp-案例分析" class="headerlink" title="总结&amp;案例分析"></a>总结&amp;案例分析</h2><p>上文介绍了复数信号分析的基本必备理论基础，可以看到，由于复数信号在实际现实世界中无法实现，因此，我们使用了$I$路代表实部和$Q$路代表虚部来实现复数信号。有了上述基本假设之后，我们便可以在这个基本假设上进行复数运算。我们首先假设在$Q$路上有一个虚拟的$j$，那么根据最基本的复数运算法则，可以演化出包括加法、减法、乘法等在内的基本运算。由这些基本运算，我们可以实现更为高级的信号处理，例如，复数混频、复数滤波等操作。为了保证我们的复数信号最终转换为实数信号，又需要保证实数信号可以转换为复数信号，我们构造出了一个复数转实数的方案以及实数转复数的方案。由于进行上述转换时，不论是实的输入信号，还是复的输入信号，都存在正负频率的信号，这时候，就需要决定是保留正频率还是负频率。在上述问题的启发下，我们又给出了保留正频率或者负频率的实转复以及复转实的方案。根据上述内容，我们可以再来分析几个案例。</p><h3 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h3><p>图25是Hartley结构的复数信号接收机，</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/9.png" class="" title="Hartley结构复数信号接收机"><p>该图给出了一个前文描述过原理的哈特利结构接收机模型。如果利用复数信号分析的方法对该系统进行分析，可以看到，系统先是对信号做了复数信号下的混频，将频谱整体向右平移$\omega_{LO}$的距离，如图26所示，</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/25.png" class="" title="哈特利接收机复数混频频谱示意图"><p>可以看到，频谱被整体向右搬移了$\omega_{LO}$的距离，这样我们要的频谱就落在中频上了，只需要再使用正频率取实部的操作，便可以实现镜像信号的抑制。那么，正频率取实部的如何操作呢？根据前文描述的正频率取实部的操作可知，正频率取实部，只需要将$Q$路信号乘以$j$虚数单位，这时候将$I$路信号和$Q$路信号加起来就可以实现正频率取实部的操作了，对应于电路实现框图就是上面的hartley框图。</p><p>可以看到，利用复数信号分析的方法分析哈特利接收机，过程非常简单，只需要通过复数信号混频、实数信号滤波、复数信号取正频率实部，这三部操作，即可获取最后的结果。与前文所述的实信号频域分析相比，大大简化了分析步骤，可以加深读者对于哈特利接收机的理解。</p><h3 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h3><p>图26是一个Weaver结构的接收机模型，该模型与在本文之前阐释的一个Weaver结构有稍许的不同，这里采用了复数滤波器的架构。</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/28.png" class="" title="Weaver结构接收机（采用复数滤波器）"><p>这种结构提前将处在正频率部分的镜像中频信号滤除，因此，只剩下了处在负频率部分的目标中频信号，再对其进一步进行降频，之后再取实部，便可以获得一个想要的目标信号。这里<strong>进一步进行降频，之后再取实部</strong>的操作是通过滤波器右侧的两路混频器和叠加器实现的。可以按照如下阐述进行理解，可以将两路信号认为是复数信号，对复数信号进行混频的操作，我们在本文先前的部分介绍过，如果混频之后还希望信号的复数信号，则需要四路信号进行混频；而在这里，我们只需要实部，因此，我们只需要将Q路信号丢弃，将产生I路的两个信号加起来即可。按照上述四路配置复数信号混频器，就可以得到我们Weaver框图的电路框图。</p><h3 id="案例三"><a href="#案例三" class="headerlink" title="案例三"></a>案例三</h3><p>下面介绍一种边带调制发射机的结构，这种边带接收机先把输入的实信号一路直接传入$I$路，作为实部，另一路延迟90°也就是除以$j$之后，作为虚部送入$Q$路。上述操作是进行了实信号取正频率变复数的操作。接着，将复数信号送入复数调制器中，调制结束之后将实部取出，便可以得到我们需要的边带调制信号。</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/29.png" class="" title="边带调制发射机"><h3 id="案例四"><a href="#案例四" class="headerlink" title="案例四"></a>案例四</h3><p>这个案例给出了一个输入为复数信号的发射机调制方案，由于输入是一个复数信号，这里我们先将复数信号的实部和虚部分别接入$I$路和$Q$路，之后在进行数字到模拟的转换以及低通滤波器滤除噪声等操作，在频谱上表现为带宽和幅度的变化，接着接入一个复数混频结构，将信号整体向上搬移，再取实部，便可以的到最后调制好的实信号。</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/30.png" class="" title="数字基带正交发射机"><h3 id="案例五"><a href="#案例五" class="headerlink" title="案例五"></a>案例五</h3><p>这个案例给出了一个复数信号接收机的架构，和案例四的复数信号发射机的结构可以凑成一对进行使用。我们可以看到接收进来的信号首先经过一个射频前端进行去噪和放大，接着，接入一个复数混频器，将输入的实数信号认为是实部，产生一个实部和虚部，分别接入$I$路和$Q$路，在频谱上表示为将频谱整体向左移动一个本振频率。接着采用一个复数滤波器，将波形外的噪声滤除，接着接入ADC中进行数字化。</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/31.png" class="" title="数字基带正交接收机"><h3 id="案例六"><a href="#案例六" class="headerlink" title="案例六"></a>案例六</h3><p>该接收机是将目标信号转换为一个低中频信号。首先，先将信号接入一个复数调制器，该实信号经过复数调制器变成一个复数信号，再通过一个复数滤波器，滤除镜频，在经过ADC转换为数字信号，之后再进行复数混频之后变成复数信号，转入DSP进行处理。</p><img src="/2021/06/06/fu-shu-xin-hao-fen-xi/32.png" class="" title="低中频接收机"><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这一套复数分析的方法能够快速帮助读者理解通信射频接收机和发射机的调制策略，以及引入$I$路和$Q$路信号的目的。可以帮助读者理解一些复杂的电路结构，化复杂的频谱分析为简单的复信号分析，可以快速上手一些电路结构，并且使读者对于接收机和发射机的原理机制的理解更加深入。</p>]]></content>
      
      
      <categories>
          
          <category> 学术交流心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信号与系统 </tag>
            
            <tag> 射频收发机 </tag>
            
            <tag> 通信原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Time-Interleaved ADC Fundamentals</title>
      <link href="/2021/05/23/timeinterleavedadc/"/>
      <url>/2021/05/23/timeinterleavedadc/</url>
      
        <content type="html"><![CDATA[<h2 id="时间交织ADC的基本数学原理和校准方法"><a href="#时间交织ADC的基本数学原理和校准方法" class="headerlink" title="时间交织ADC的基本数学原理和校准方法"></a>时间交织ADC的基本数学原理和校准方法</h2><p>本文总结了时间交织ADC的基本数学原理和校准方法。</p><h3 id="时间交织ADC的频域分析"><a href="#时间交织ADC的频域分析" class="headerlink" title="时间交织ADC的频域分析"></a>时间交织ADC的频域分析</h3><p>在时间交织ADC中，将原先单通道的，以$f_s$为采样频率的采样工作，被均匀分配给N个通道交替完成。因此，N个通道交替完成采样频率为$f_s$的采样工作，每个通道上的频率变为原先的$\frac{1}{N}$。</p><img src="/2021/05/23/timeinterleavedadc/1.png" class="" title="时间交织ADC基本架构及时域频域分析示意图"><p>如图所示该时间交织中一共有4个通道，通道1至通道4分别用紫色、红色、蓝色以及绿色表示。根据时域中的移位对应于频域中的移位</p><p>$$<br>y_1(t)=x(t)\Sigma(\delta (t-kT_{ck}))<br>$$</p><p>$$<br>y_2(t)=x(t)\Sigma(\delta (t-kT_{ck}+\frac{T_{ck}}{4}))<br>$$</p><p>$$<br>y_3(t)=x(t)\Sigma(\delta (t-kT_{ck}+\frac{2T_{ck}}{4}))<br>$$</p><p>$$<br>y_4(t)=x(t)\Sigma(\delta (t-kT_{ck}+\frac{3T_{ck}}{4}))<br>$$</p><p>$$<br>Y_1(f)=\frac{1}{T_{ck}}X(f)*\Sigma(\delta (f-kf_{ck}))<br>$$</p><p>$$<br>Y_2(f)=\frac{1}{T_{ck}}X(f)*\Sigma(\delta (f-kf_{ck})e^{-j\pi fT_{ck}/2})<br>$$</p><p>$$<br>Y_3(f)=\frac{1}{T_{ck}}X(f)*\Sigma(\delta (f-kf_{ck})e^{-j\pi fT_{ck}})<br>$$</p><p>$$<br>Y_4(f)=\frac{1}{T_{ck}}X(f)*\Sigma(\delta (f-kf_{ck})e^{-j3\pi fT_{ck}/2})<br>$$</p><p>根据上式可以发现，每一个通道的频谱都是在通道一的基础之上进行一定的相移；而通道一来自于包络函数的傅里叶变换按照采样频率进行周期为采样频率的周期延拓。</p><img src="/2021/05/23/timeinterleavedadc/2.png" class="" title="时间交织ADC基本架构及时域频域分析示意图"><p>考虑离散谱时，即采用离散傅里叶变换（DFT）时，不仅该信号的时域表达式离散化，该信号的频域表达式也离散化，这就会导致该信号的时域表达式周期化，即该信号需要在原有信号基础之上进行若干点的周期延拓。举例来说，如果原信号的离散序列一共有N个值，对该信号做N点DFT，则原信号需要进行以N个样本点为周期的周期延拓。</p><p>$$<br>X(f)=\frac{1}{N}\Sigma x(n)e^{j2\pi nf/N}<br>$$</p><p>上式表述了N点离散傅里叶变化的表达式，注意到，在该表达式中，我们有求累加和之后除以系数N，这是由于傅里叶变换本身的物理意义导致的。傅里叶变换的到的频谱函数$X(f)$得到的频谱表达式的模表示了幅度，而模的平方表示了功率。假如系数$\frac{1}{N}$没有被考虑在表达式中，则会出现一个奇怪的现象，那就是点数越多，离散傅里叶变换得到的表达式的模值就会越大，自然模的平方也就会越大，这和实际的物理意义是相悖的，我们知道，信号的功率不会因为采样点数目的增大而增大。为了解决这个问题，我们在离散傅里叶正变换的等式右边加上一个系数$\frac{1}{N}$，这样就能保证不管采样点数如何改变，得到的信号的功率谱的模值总是不变的。</p><p>但是在时间交织ADC中，假设通道数由单通道变为双通道的ADC，对于整体而言，采样率变为原先的2倍，对于双通道ADC的一个通道而言，相当于在原先单通道的基础之上，在中间插入了一个0值，根据我们前面的论述可知，通道1的功率变为了原先单通道的一半，信号幅度变为原先的0.707倍；因为该ADC有两个通道，所以加起来的总功率仍然保持不变。</p><p>在ADC中，由失配引起的杂散(Spurs)是ADC需要关注的重要的问题，关系到ADC的性能。假设每一个通道的失配的比例是固定的，是一个分布确定的随机变量，假设这个比例的数学期望是0，方差是$\sigma^2$。</p><p>举一个单通道和双通道的失配例子，假设单通道的失配随机变量是$e$，双通道的失配随机变量是$e_1$和$e_2$。为了求得失配的功率，我们可以将每一个变量的失配比例求和之后取数学期望后平方，获得功率。由下面的式子可以知道，单通道ADC的杂散幅度是双通道的ADC杂散幅度的$\sqrt{2}$倍。在这里提醒读者，这里说的双通道特别强调了是<strong>杂散幅度</strong>，而不是总共的杂散功率，总的杂散功率还需要乘以一个通道数。</p><p>$$<br>E(e)^2=E(e^2)=\sigma^2<br>$$</p><p>$$<br>E(\frac{e_1}{2}+\frac{e_2}{2})^2=E((\frac{e_1}{2})^2)+E((\frac{e_2}{2})^2)=\frac{1}{2}\sigma^2<br>$$</p><p>因此，不难看出，不管是单通道还是双通道还是N通道，只要信号包络保持不变，杂散的总功率是保持不变的，但是在每一个通道上的杂散幅度会变小，具体来说，会下降为原先幅度的$1/\sqrt{2}$，也就是下降3dB，而功率保持不变。</p><h3 id="时间交织ADC的频域分析的MATLAB验证"><a href="#时间交织ADC的频域分析的MATLAB验证" class="headerlink" title="时间交织ADC的频域分析的MATLAB验证"></a>时间交织ADC的频域分析的MATLAB验证</h3><p>为了证明上述结论的正确性，这里我们在MATLAB中给四通道和八通道ADC建立了模型，验证了结果的正确性。我们令失配随机变量是一个服从正态分布的随机变量，将这个失配变量叠加在每一个通道上，之后，测量100次在这个随机变量的影响下，八通道ADC的杂散幅度大小与四通道的杂散幅度大小的比值，测定结束之后将该值存储在数组中。将上述步骤反复执行50次，得到了一份概率分布图，可以看到，该均值大概在$1/\sqrt{2}$附近，也是3dB附近，可以验证我们之前的结论：n通道ADC的杂散幅度是2n通道的ADC杂散幅度的$\sqrt{2}$倍。</p><img src="/2021/05/23/timeinterleavedadc/3.png" class="" title="8通道与4通道ADC杂散幅度比值概率分布图"><img src="/2021/05/23/timeinterleavedadc/4.png" class="" title="8通道与4通道ADC杂散幅度比值概率分布图"><p>再来验证是否杂散总功率保持不变，下面给出了按照上文所述流程测量出来的杂散功率比值，我们可以看到，8通道与4通道ADC的杂散功率比值在1.5附近，此比例大概是1.2左右，这里的杂散功率并没有完全相等的原因不甚明确，需要进一步讨论和研究。</p><img src="/2021/05/23/timeinterleavedadc/5.png" class="" title="8通道与4通道ADC杂散功率比值概率分布图"><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>我们可以看到，在时间交织ADC中，在不考虑电路层面的误差仅仅考虑失配的前提下，每增加2倍的通道数量，杂散的幅度就会降低3dB，因此，增加时间交织通道数目可以显著减小杂散的幅度。但是，依据数学计算结果，无论通道数如何增加，杂散的总功率保持不变。</p><h3 id="TI失调失配来源与校准方案"><a href="#TI失调失配来源与校准方案" class="headerlink" title="TI失调失配来源与校准方案"></a>TI失调失配来源与校准方案</h3><p>TI的失调失配主要来源于比较器，失调失配在输出主要体现为一个单音信号或者多音信号，对于每一个通道来说，我们认为失调在某一段时间内是恒定不变的；并且在输入为零时进行校准，这样只需要将输入一段时间内的数据进行累加求平均之后即可得到最后的失调量，具体来讲可以通过下面的系统框图看到。</p><img src="/2021/05/23/timeinterleavedadc/6.png" class="" title="失调失配预测&amp;校准系统框图"><p>该系统框图的传输函数可以表示为如下图所示的表达式，</p><p>$$<br>\frac{V_{out}}{V_{in}}=\frac{A}{1+A}=\frac{1/s}{1+1/s}=\frac{1}{1+s}<br>$$</p><p>从上式中可以看出，该系统表现为一个低通的特性，因此一些较为高频的信号会被滤除，因此只保留了低频的失调量信号。如果每一个通道都可以利用这样的一个系统框图进行失调量的估计的话，则可以获得每一个通道的失调量大小，进而在数字域对其进行补偿。</p><p>或者我们可以直接从Err中获得补偿过后的信号，Err的表达式如下式所示，</p><p>$$<br>\frac{Err}{V_{in}}=\frac{1}{1+A}=\frac{1}{1+1/s}=\frac{s}{1+s}<br>$$</p><p>可以看到，在上式中，在频率为DC处，信号被完全抑制，因此，在这个频率段处，我们可以获得滤除低频DC频段的信号，即一个去掉失调量的信号。上述失调失配预测&amp;校准系统如果应用于一个4通道的校准系统中，则由于混叠造成的影响，在$\frac{fs}{4}$、$\frac{fs}{2}$、$\frac{3fs}{4}$、以及$fs$处会有信号的抑制作用，因此，如果想要降低这一部分抑制作用对系统带来的影响，我们需要将系统的3dB频点压缩到尽量靠近$\frac{fs}{4}$、$\frac{fs}{2}$、$\frac{3fs}{4}$、以及$fs$这几个点的位置，这样，即便输入宽带信号在这几个频点上有一定的能量损失，在整体上来看信号功率的损失仍然不算很大。</p><img src="/2021/05/23/timeinterleavedadc/7.png" class="" title="失调失配预测频谱图"><p>具体来说，上述功能可以通过在积分器上加上一个系数来实现，加上系数$\omega_n$之后的系统框图如下图所示。</p><img src="/2021/05/23/timeinterleavedadc/8.png" class="" title="调整3dB频点后的失调失配预测&amp;校正框图"><p>该Err的表达式变为，</p><p>$$<br>Err=\frac{s}{s+\omega_n}<br>$$</p><p>该$\omega_n$的数值可以调节为一个比较小的数值，这样3dB频点就会非常靠近DC、$\frac{fs}{4}$、$\frac{fs}{2}$、$\frac{3fs}{4}$、以及$fs$。</p><h3 id="TI增益失配来源与校准方案"><a href="#TI增益失配来源与校准方案" class="headerlink" title="TI增益失配来源与校准方案"></a>TI增益失配来源与校准方案</h3><p>TI增益的失配主要来源于传输线上的阻抗不匹配导致的，并且由于传输线上有可能是一个容性和感性的混合阻抗，因此，该阻抗有可能是一个输入信号频率的函数。那么，这种由于阻抗形成的增益失配也有可能是一个输入信号频率的函数，这就意味着如果考虑频率的情况下，系统的增益失配是一个很难校准的量。但一般来讲，这种频率的依赖性是可以通过布局布线进行削弱的，因此，我们在考虑这个问题的时候，只需要考虑一个恒定的增益失配即可。</p><p>在校准增益失配的时候，需要计算出一个增益系数，增益系数由下式表示，</p><p>$$<br>g_k=\frac{1}{N}\Sigma^{N-1}_{i=0}Q_k^2(i)<br>$$</p><p>上式中，$k$表示通道数，例如第$k$个通道，上述式子的实际含义是将每个通道的量化结果进行平方之后取均值。在得到这个增益系数之后，我们可以通过增益系数来校正增益误差，在下式中考虑一个四通道的TI-ADC，则第一个通道认为增益是准确的，其余通道校准到第一个通道的标准增益上。</p><p>$$<br>G_1=G_1<br>$$</p><p>$$<br>G_2=\sqrt{\frac{g_1}{g_2}}G_2<br>$$</p><p>$$<br>G_3=\sqrt{\frac{g_1}{g_3}}G_3<br>$$</p><p>$$<br>G_4=\sqrt{\frac{g_1}{g_4}}G_4<br>$$</p><p>利用上述的四个式子，即可以校准增益。下面的系统框图表示了上述的求增益系数的运算在电路当中实现的方法，可以使用寄存器对输入的信号进行N次寄存之后求和输出，便可以获得增益系数。</p><img src="/2021/05/23/timeinterleavedadc/9.png" class="" title="增益系数求解系统框图"><h3 id="TI时钟失配来源与校准方案"><a href="#TI时钟失配来源与校准方案" class="headerlink" title="TI时钟失配来源与校准方案"></a>TI时钟失配来源与校准方案</h3><p>TI中的时钟失配主要来源于时钟的非理想性，LC振荡器在产生高速时钟时会有一个抖动，这个抖动的$\sigma$在LC振荡器这种电路结构中最好可以做到$50fs$。另一方面，由于不同的信号通路，也会给时钟造成先后的时间差，这种时间差就造成了TI-ADC的多路时钟失配。随着输入信号的频率的增大，这种失配造成的噪声是越来越大的，这是由于频率增大意味着在单位时间内信号的变化就越大，造成的误差也就越大，进一步，噪声也就越大。因此，在高频应用中，这种失配造成的误差是必须要被校准的，否则会对系统的精度造成比较大的影响。</p><p>时钟失配校准的方法比较繁琐，接下来介绍这种基于自相关算法的时钟失配校准方法。假设我们采用了2路交织的ADC结构，这时，校准2路ADC时需要考虑基准的问题，时钟抖动是相对的，需要将某一个通道作为基准，将其他通道校准到以某一个通道为基准的周期上。下图描述了一个两通道的样本校准模型，可以看到1通道的样本将2通道的样本夹在了中间。如果2通道的样本向左移动，则$y_1[k-1]$与$y_2[k-1]$的相关程度会增加，$y_2[k-1]$与$y_1[k]$的相关程度会减小。</p><img src="/2021/05/23/timeinterleavedadc/10.png" class="" title="2路ADC交织样本"><p>根据上述论述，我们可以发现，根据这个相关程度的大小关系，我们可以判断出中间的样本点究竟是偏向左边还是偏向右边。如果要从数学角度来表述上述分析过程，则所谓的相关程度可以表示为，</p><p>$$<br>P_1=x[-(T_{ck}+\Delta T)]x(0)<br>$$</p><p>$$<br>P_2=x(0)x[T_{ck}-\Delta T]<br>$$</p><p>上述两个式子表示了两个乘积，这两个乘积表述了中间样本点离左侧和右侧的样本点的距离远近关系。如果两个样本点之间的距离是恒定的，则两个乘积理应相同。如果将样本点的数量扩展到一定数目，则上述两个乘积则转变为乘积和的平均值，这个量实际上就是一定数量的样本点组成的一段有限长信号的自相关值，则这两个自相关值的差值可以表述为如下所示的式子。</p><p>$$<br>\overline{D_{\Delta t}}=R_x(T_{CK}-\Delta T)-R_x[-(T_{CK}+\Delta T)]<br>$$</p><p>根据自相关函数的特性，自相关函数是一个偶函数，根据偶函数的特性，上述方程可以转换为如下式子，</p><p>$$<br>\overline{D_{\Delta t}}=R_x(T_{CK}-\Delta T)-R_x(T_{CK}+\Delta T)<br>$$</p><p>如果$\Delta T$足够小，则上述方程可以写为如下式子，</p><p>$$<br>\overline{D_{\Delta T}}\approx-2\Delta T\frac{dR_x}{d\tau}|<em>{\tau=T</em>{CK}}<br>$$</p><p>由上述式子我们便可以获取中间样本点的偏离方向，偏离方向获知之后便可以进行校准了。</p><p>获知这个方向之后，我们可以通过设置校准补偿来进行调节，调节可变延时线直到自相关的差值为零为止。这种校准方法是模拟的方法，当然也可以使用数字的方法进行校准，数字方法校准认为在两个样本点之间的信号是一段直线，基于这个原理可以进行全数字的校准。</p>]]></content>
      
      
      <categories>
          
          <category> 组会心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟集成电路设计 </tag>
            
            <tag> Time-Interleaved ADC </tag>
            
            <tag> 数字信号处理 </tag>
            
            <tag> 信号与系统 </tag>
            
            <tag> Data Converters </tag>
            
            <tag> 离散时间傅里叶变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LDO低压稳压线性电源的设计</title>
      <link href="/2021/01/19/ldo/"/>
      <url>/2021/01/19/ldo/</url>
      
        <content type="html"><![CDATA[<h2 id="LDO的基本设计原理"><a href="#LDO的基本设计原理" class="headerlink" title="LDO的基本设计原理"></a>LDO的基本设计原理</h2><img src="/2021/01/19/ldo/1.png" class="" title="LDO的基本结构示意图"><h3 id="内部组成部分"><a href="#内部组成部分" class="headerlink" title="内部组成部分"></a>内部组成部分</h3><ul><li>误差放大器，Error Amplifier</li><li>调整管，文章中又称传输管</li><li>电阻分压网络</li></ul><p>上述几个部分组成了一个负反馈，使得输出节点可以严格跟随$V_{ref}$进行变化。这个$V_{ref}$由带隙基准源组成，这个基准源可以生成一个与$PVT$弱相关的一个电流，使得电流流过一个电阻，便可以生成一个电压。$C_{out}$的作用是把高频噪声短路到地上，而$r_{esr}$的的作用是等效$C_{out}$的等效串联电阻，这个值需要调节以保证LDO环路的稳定性。</p><h2 id="LDO的性能指标"><a href="#LDO的性能指标" class="headerlink" title="LDO的性能指标"></a>LDO的性能指标</h2><ul><li>直流特性</li><li>交流特性</li><li>瞬态特性</li><li>效率</li></ul><h3 id="直流特性"><a href="#直流特性" class="headerlink" title="直流特性"></a>直流特性</h3><ul><li>线性调整率，linear regulation</li><li>负载调整率，load regulation</li><li>温度系数，temperature coefficient</li><li>漏失电压</li></ul><h4 id="线性调整率"><a href="#线性调整率" class="headerlink" title="线性调整率"></a>线性调整率</h4><ul><li><strong>作用</strong>：给定LDO对应于不同静态输入电压以及负载电流条件下的稳压输出能力，表征了LDO的性能。</li><li><strong>定义</strong>：LDO静态输出电压变化随静态输入电压变化之比，具体表示为如下:</li></ul><p>$$<br>\frac{\Delta V_{out}}{\Delta V_{in}}=\frac{1}{A_{err}F}+\frac{1}{F}\frac{\Delta V_{ref}}{\Delta V_{in}}<br>$$</p><ul><li>其中，$A_{err}$为误差放大器的增益，$F$为电阻反馈系数，$\frac{\Delta V_{out}}{\Delta V_{in}}$为电压基准源随静态输入电压的变化率。</li><li><strong>结论</strong>：线性调整率主要取决于误差放大器的直流增益，放大器直流增益$A_{err}$越大，则性能越好。此外，如果基准源相对于输入电压的精度也限制了LDO的性能。</li><li><strong>备注</strong>：该特性一般来说不是特别重要。</li></ul><h4 id="负载率调整"><a href="#负载率调整" class="headerlink" title="负载率调整"></a>负载率调整</h4><ul><li><strong>作用</strong>：与线性调整率一样，给定了LDO对于不同静态输入电压以及负载电流条件下的稳压输出能力，表征了LDO的性能。</li><li><strong>定义</strong>：负载调整率是指LDO静态输出电压变化随负载电流变化之比，它可以表示为：</li></ul><p>$$<br>\frac{\Delta V_{out}}{\Delta I_{L}}=\frac{r_{op}}{1+AF}<br>$$</p><ul><li>其中，$r_{op}$是指传输管的输出阻抗，$AF$是环路的直流增益<code>Loop Gain</code>。</li><li><strong>结论</strong>：$r_{op}$越小，$AF$越大，则LDO的稳压性能越好。</li><li><u><strong>注意</strong></u>：在这里，负载调整率仅仅代表输出电压随负载电流的<strong>直流</strong>变化，并不能完全表征负载电流瞬时变化时的动态特性。</li><li><strong>备注</strong>：负载调整率关系到输出电压的精度，要特别注意这一特性。</li></ul><h4 id="温度系数"><a href="#温度系数" class="headerlink" title="温度系数"></a>温度系数</h4><ul><li><strong>作用</strong>：表征LDO输出电压随温度的漂移。</li><li><strong>定义</strong>：该参数主要受到电压基准源以及误差放大器的失调电压的温度漂移的影响，可以表示为：</li></ul><p>$$<br>TC=\frac{1}{V_{out}}\cdot\frac{\frac{\Delta V_{ref,Temp}+\Delta V_{os,Temp}}{F}}{\Delta Temp}<br>$$</p><ul><li>其中，$\Delta V_{ref,Temp}$以及$\Delta V_{os,Temp}$分别表示电压基准源以及误差放大器失调电压在$\Delta Temp$范围内的变化量。</li><li><strong>备注</strong>：该特性一般在LDO中不是特别重要，需要在带隙基准源（Bandgap Reference）中特别注意。一般带隙基准源会对温度进行补偿，从而使得输出电压相对于温度来说，基本恒定不变。</li></ul><h4 id="漏失电压"><a href="#漏失电压" class="headerlink" title="漏失电压"></a>漏失电压</h4><ul><li><strong>作用</strong>：表征漏失电压$V_{dsat,pt}$决定了最大输出电流以及最小输入电压的值。</li><li><strong>定义</strong>：<strong>漏失电压</strong>、<strong>最大输出电流</strong>以及<strong>最小输入电压</strong>这三个量都取决于调整管的参数。在实际设计中，通常会根据最大输出电流以及漏失电压的要求来确定传输管的尺寸，从而使得在最大输出电流的情况下，</li></ul><p>$$<br>V_{DO}=I_{L,max}r_{ON}=V_{dsat,pt}<br>$$</p><ul><li>其中，最大负载电流时传输管的$V_{dsat}$即为漏失电压。</li><li><strong>备注</strong>：这里所说的漏失电压就是在管子源漏极之间的电压，LDO（Low Dropout）的名字也是由此而来，LDO表示在源漏之间的电压降很小。这个压降越小，则耗费在LDO上的功率就越小。</li></ul><h3 id="交流特性"><a href="#交流特性" class="headerlink" title="交流特性"></a>交流特性</h3><ul><li>电源抑制比（PSRR）</li><li>噪声</li></ul><h4 id="电源抑制比"><a href="#电源抑制比" class="headerlink" title="电源抑制比"></a>电源抑制比</h4><ul><li><strong>作用</strong>：表征LDO抑制电源线上的高频噪声的能力。</li><li><strong>定义</strong>：与<u>传输管的寄生电容</u>有关，并且与<u>环路增益</u>成反比。</li><li><strong>提高电源抑制比的方法</strong>：误差放大器在提高LDO的PSRR方面起到很重要的作用。</li><li><strong>备注</strong>：电源抑制比（PSRR）代表了LDO作为类似电源滤波器角色的能力。一般的LDO的电源抑制比在40dB左右</li></ul><h4 id="噪声"><a href="#噪声" class="headerlink" title="噪声"></a>噪声</h4><ul><li><p><strong>来源</strong>：电压基准源以及误差放大器的噪声。</p></li><li><p><strong>减小噪声的方法</strong>：</p><ul><li>电压基准源产生的噪声<br>可以通过加入RC低通滤波器有效滤除一部分。</li><li>误差放大器产生的噪声<br>可以通过增加静态电流以及加大输入管尺寸等改善。</li></ul></li></ul><h3 id="瞬态特性"><a href="#瞬态特性" class="headerlink" title="瞬态特性"></a>瞬态特性</h3><h4 id="LDO瞬态特性"><a href="#LDO瞬态特性" class="headerlink" title="LDO瞬态特性"></a>LDO瞬态特性</h4><ul><li><strong>作用</strong>：表征其对负载电流以及输入电压的瞬态变化进行稳压的能力。</li><li><strong>定义</strong>：LDO的瞬态特性取决于在大信号下的电路性能，例如，<u>对传输管的栅极寄生电容进行快速充放电的能力</u>以及<u>寄生电容的馈通</u>等。</li></ul><h4 id="负载瞬态变化特性"><a href="#负载瞬态变化特性" class="headerlink" title="负载瞬态变化特性"></a>负载瞬态变化特性</h4><ul><li><strong>作用</strong>：LDO对于快速负载瞬态变化进行稳压的能力。</li><li><strong>定义</strong>：可以用负载电流从0变为最大时，输出端的电压变化幅度。LDO在大负载电流变化下的稳压能力与其闭环单位增益带宽、输出电流变化幅度以及输出电容的大小的因素有关，可以表示为：</li></ul><p>$$<br>\Delta V_{out}=\frac{I_{L,max}\cdot\Delta t}{C_{out}}<br>$$</p><ul><li>其中$\Delta t$表示LDO的响应时间，它与环路的单位增益带宽成反比。</li><li><strong>提高该特性的方法</strong>：提高LDO环路的带宽；提高传输管（调整管）前一级的压摆率（slew rate），即，提高前一级电路对传输管寄生电容的充放电能力。</li></ul><h4 id="纹波抑制比"><a href="#纹波抑制比" class="headerlink" title="纹波抑制比"></a>纹波抑制比</h4><ul><li><strong>作用</strong>：表征LDO对于大幅度输入电压波纹的抑制能力。</li><li><strong>定义</strong>：LDO的输出电压波纹与输入1电压波纹之比。</li><li><strong>补充说明</strong>：在<strong>输入电压比较小</strong>的情况下，这一指标与PSRR（电源抑制比）是近似相等的；当<strong>输入电压变化比较大</strong>的情况下，电路的一些大信号特性会使得纹波抑制比偏离PSRR所预测的值。</li></ul><h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><ul><li><strong>定义</strong>：主要有三个量决定：静态电流、负载电流以及传输管的漏失电压，它可以表示为：</li></ul><p>$$<br>Eff=\frac{输出功率}{输入功率}=\frac{V_{out}I_{L}}{V_{in}(I_{Q}+I_{L})}<br>$$</p><ul><li><strong>补充说明</strong>：当负载电流远大于静态电流时，即</li></ul><p>$$<br>I_{Q}+I_{L}\approx \frac{V_{out}}{V_{in}}=\frac{V_{in}-V_{DO}}{V_{in}}<br>$$</p><h2 id="LDO电路的设计考虑"><a href="#LDO电路的设计考虑" class="headerlink" title="LDO电路的设计考虑"></a>LDO电路的设计考虑</h2><ul><li>环路稳定性</li><li>电源抑制比（PSRR）</li><li>负反馈频率补偿</li><li>其他考虑</li></ul><h3 id="环路稳定性"><a href="#环路稳定性" class="headerlink" title="环路稳定性"></a>环路稳定性</h3><ul><li>分析环路稳定性通常是寻找到环路的开环增益，我们需要把环路打开，这里可以参考拉扎维电子2视频中所讲述的打开环路的正确方法。很显然，作者在这里并没有精确地打开环路，我们可以看到，作者在下图中并没有考虑到负载效应，不过作为近似结果，该结果还是可以接受的。</li></ul><img src="/2021/01/19/ldo/2.png" class="" title="LDO的原理图"><ul><li>这个环路的开环传输函数可以表示为：</li></ul><p>$$<br>L(s)=\frac{L(out)}{L(in)}=\frac{g_{m1}r_{o1}g_{mL}r_{oL}(1+sC_{out}r_{esr})}{(1+sr_{o1}C_1)(1+s(r_{oL}+r_{esr})C_{out})}<br>$$</p><ul><li>下面讨论一下该传输函数的两个极点以及一个零点，他们可以表示为如下式子</li></ul><p>$$<br>p_1=\frac{1}{2\pi C_{out}(r_{oL}+r_{esr})}<br>$$</p><p>$$<br>p_2=\frac{1}{2\pi C_1r_{o1}}<br>$$</p><p>$$<br>z_1=\frac{1}{2\pi C_{out}r_{esr}}<br>$$</p><ul><li>其中，$p_1$是存在于LDO输出端的主极点，$p_2$是误差放大器输出端形成的另一个极点。如果设计$z_1$的值非常接近$p_2$的值时，可以认为单位增益带宽内只存在一个主极点。该反馈系统是稳定的。极点大小可以通过单电容极点估算法进行估算，具体方法为采用一个单独的电容之后再测量电容两侧看出去的电阻大小，再将这个电容的容值与从电容两侧看出去的电阻的阻值相乘，最后就可以得到我们需要的极点大小。</li><li>此外，此处由于电容$C_{out}$上方还有一个串联的电阻，当此电阻的阻值和电容的阻抗相等时，这是就会产生一个零点，根据这种说法，可以写出如下式所示的等式，根据这个等式可以计算出这个零点的位置。</li></ul><p>$$<br>\frac{1}{sC_{out}}+r_{esr}=0<br>$$</p><p>$$<br>s=-\frac{1}{C_{out}r_{esr}}<br>$$</p><h3 id="电源抑制比-1"><a href="#电源抑制比-1" class="headerlink" title="电源抑制比"></a>电源抑制比</h3><p>电源抑制比主要描述了在输出看到的从电源来的噪声的抑制情况。一般来讲，理想的LDO的电源抑制比一般在-40dB左右，如果要提升电源抑制比，需要提高环路的增益。但是，提高低频下的电源抑制比是依靠环路增益，但是高频部分的噪声是利用在输出端的去耦电容实现的，该去耦电容一般在$\mu F$级别，这个大电容可以有效抑制高频下从电源来的噪声。</p><h3 id="负反馈频率补偿"><a href="#负反馈频率补偿" class="headerlink" title="负反馈频率补偿"></a>负反馈频率补偿</h3><p>由于考虑电源抑制比情况在输出端口引入的大电容以及输出负载的阻抗变化的特点，输出节点的容值大小一般是会剧烈变化的，考虑到这一点，我们通常设置输出节点为主极点，以保证在不同负载情况下电路的稳定。设置输出节点为主极点后，我们需要利用电路中其他部分的特点，尽量拉开主极点以及其他非主极点之间的距离，以保证足够的相位裕度。实际电路如图3所示，图3是一个经典的LDO的电路原理图，在该原理图中，由于运算放大器OP1的输出阻抗以及M4传输管的输入容值通常比较大，因此，我们需要采用一个操作将左边的运算放大器$OP1$和右侧的传输管$M4$隔离开来。最简单的方式就是在两级放大器中间插入一级放大器，该放大器可以将一个极点分裂为两个不同的极点，但是两个极点的大小要远远小于第一个极点的大小，在Bode图上，表现为非主极点和主极点之间的距离被拉开了。此外，为了二进一步减小在$M1$漏极看到的阻抗，此处引入了一个电阻$Rc$，并联到VDD，这个电阻的目的是减小该节点看到的阻抗，进一步将改点的极点推向更远的地方。</p><img src="/2021/01/19/ldo/3.png" class="" title="LDO的原理图"><h3 id="其他考虑"><a href="#其他考虑" class="headerlink" title="其他考虑"></a>其他考虑</h3><p>在设计该电路时，可以看到有$OP2$以及$Rd$在电路中还没有进行很好的解释，这里分别解释一下这两个部分起到的作用。在LDO原理图中的上拉电阻Rd的作用是在电路上电的时候给M3、M2、M1组成的支路上提供足够的电流。Cascode类型或者堆叠的管子可能在上电的时候由于不同的管子工作区域转换需要时间，MOS管从反型层形成到进入饱和区的速度比较快，但是MOS管从没有反型层到有反型层这一过程的转换速度比较慢。为了加快MOS管的导通速度，我们通常采用一个小的电流源，给电路提供一个微弱的电流，使管子始终处在导通的状态中，防止管子处在没有反型层的状态。这是一种基于实际使用的调整，在理论设计中，并不需要考虑管子锁死的情况，只有在实际做产品时，为了保证产品的稳定性，才需要考虑这个问题。在LDO原理图中在传输管和第二级放大器之间有一个运算放大器<code>OP2</code>，这个放大器的作用是$V_{ds}$匹配。由于沟道长度调制效应，会造成电流镜复制电流产生误差，有可能出现一边管子进入饱和区，另一边还在线性区的情况。为了消除这个影响，引入一个运算放大器来消除两侧管子的$V_{ds}$的差别，提升电流复制的精确程度。</p>]]></content>
      
      
      <categories>
          
          <category> 模拟集成电路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cadence </tag>
            
            <tag> LDO </tag>
            
            <tag> 模拟集成电路设计 </tag>
            
            <tag> 电源技术 </tag>
            
            <tag> 线性电源技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RHEL虚拟机开启Cadence操作指南</title>
      <link href="/2021/01/09/rhel-xu-ni-ji-kai-qi-cadence-cao-zuo-zhi-nan/"/>
      <url>/2021/01/09/rhel-xu-ni-ji-kai-qi-cadence-cao-zuo-zhi-nan/</url>
      
        <content type="html"><![CDATA[<h2 id="步骤分解"><a href="#步骤分解" class="headerlink" title="步骤分解"></a>步骤分解</h2><ol><li>安装VMware。</li><li>在VMware中打开虚拟机文件。</li><li>开启虚拟机并登陆。</li><li>在控制台中输入命令。</li><li>成功！</li></ol><h2 id="安装VMware"><a href="#安装VMware" class="headerlink" title="安装VMware"></a>安装VMware</h2><ul><li>直接按照网络上的教程以及程序安装包的提示安装即可。</li></ul><h2 id="打开Cadence软件方法"><a href="#打开Cadence软件方法" class="headerlink" title="打开Cadence软件方法"></a>打开Cadence软件方法</h2><ul><li><em><strong>注意</strong></em>：这一步需要虚拟机保存的路径名称（父文件夹）的名字不能为中文，如果是中文，可能会打不开。</li></ul><ol><li>把虚拟机从<code>给大四</code>文件夹中拷贝出来，放置到某个你喜欢的文件夹下，文件夹名称为英文。</li><li>打开VMware，在左上方选择<code>文件</code>，之后选择<code>打开</code>，在弹出的文件寻找框中找到名为<code>Linux6.7-64.vmx</code>的文件。</li><li>等待一会儿，就可以在虚拟机左侧框中找到名为<code>Linux6.7-64</code>的虚拟机，点击打开并运行。</li></ol><p><img src="/image/1.png"></p><ol start="4"><li>等待一会儿，可以看到虚拟机开机界面如上，选择用户<code>cdsmgr</code>，输入密码<code>cadence</code>便可以开机。</li><li>进入桌面之后，可以看到桌面上有若干图标和文件夹，根据你设计工艺的需要选择对应的文件夹。这里只提供了两种工艺库<code>smic18</code>和<code>tsmc40</code>。</li></ol><p><img src="/image/2.png"></p><ol start="6"><li>点开文件夹，这里以<code>smic18</code>为例，点开<code>smic18</code>文件夹之后，我们可以看到里面有若干文件和文件夹，最关键的配置文件是<code>cshrc_2016</code>，这个文件存储了变量信息，我们需要使变量信息生效。右键空白处，点击<code>open in terminal</code>使用如下命令。</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token function">source</span> cshrc_2016</code></pre><p><img src="/image/3.png"></p><ol start="7"><li>最后在使用命令<code>&amp; virtuoso</code>便可以打开cadence软件。打开耗时根据你使用的硬盘种类的不同可能会比较久也可能会很快。</li></ol><ul><li><p><input checked="" disabled="" type="checkbox"> 成功!</p></li><li><p>成功的界面如下。</p></li></ul><p><img src="/image/4.png"></p><h2 id="TroubleShooting"><a href="#TroubleShooting" class="headerlink" title="TroubleShooting"></a>TroubleShooting</h2><ul><li><p>如果你的虚拟机出现无法找到<code>xxx</code>文件之类的提示，请检查虚拟机的路径是否包含英文，将虚拟机文件放置在英文路径下。</p></li><li><p>如果你使用<code>source cshrc_2016</code>命令提示无法找到文件，请检查terminal的文件路径是否正确。如果仍无法找到文件，请在使用<code>source cshrc_2016</code>之前使用如下命令</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /home/cdsmgr/Desktop/smic18</code></pre></li><li><p>如果你遇到cadence无法打开的情况，请多等待一会儿，或者尝试重启虚拟机，或者检查你是否跟随此教程执行了所有命令。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 模拟集成电路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cadence </tag>
            
            <tag> 模拟集成电路 </tag>
            
            <tag> 软件安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet特点及其总结</title>
      <link href="/2020/11/02/servlet/"/>
      <url>/2020/11/02/servlet/</url>
      
        <content type="html"><![CDATA[<h2 id="软件结构发展史"><a href="#软件结构发展史" class="headerlink" title="软件结构发展史"></a>软件结构发展史</h2><ol><li>单机时代-桌面应用，数据保存在本地;</li><li>联机时代(Client-Server模式，C/S结构);</li><li>互联网时代(Browser-Server模式，B/S结构)。</li></ol><h2 id="B-x2F-S模式执行流程"><a href="#B-x2F-S模式执行流程" class="headerlink" title="B/S模式执行流程"></a>B/S模式执行流程</h2><ul><li>通过用户输入的网址，利用DNS服务器，查询到IP地址，将请求发送给web服务器，获取程序。</li></ul><h2 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a>请求与响应</h2><ul><li>从浏览器发出送给服务器的数据包称为”请求(Request)”;</li><li>从服务器返回给浏览器的结果称为”响应(Response)”;</li></ul><h2 id="J2EE"><a href="#J2EE" class="headerlink" title="J2EE"></a>J2EE</h2><ul><li>J2EE(Java 2 platform Enterprise Edition)是指”Java 2企业版”;</li><li>开发BS(Web)应用程序就是J2EE最核心的功能</li><li>J2EE由13个功能模块组成</li></ul><p><img src="/1.png" alt="J2EE功能模块示意图"></p><h2 id="Apache-Tomcat"><a href="#Apache-Tomcat" class="headerlink" title="Apache Tomcat"></a>Apache Tomcat</h2><ul><li>Tomcat是Apache软件基金会旗下一款免费的开源的Web应用服务器程序。</li></ul><p>![Apache Tomcat(2.png)</p><h2 id="J2EE与Tomcat的关系"><a href="#J2EE与Tomcat的关系" class="headerlink" title="J2EE与Tomcat的关系"></a>J2EE与Tomcat的关系</h2><ul><li>J2EE是一组技术规范和指南，具体实现由软件厂商决定；</li><li>Tomcat本质上是J2EE Web(Servlet与JSP)的规范的一种实现；</li><li>J2SE是J2EE运行的基石，运行Tomcat离不开J2SE(JRE&amp;JDK)。</li></ul><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><ul><li>Servlet(Server Applet)服务器小程序，主要功能用于生成动态Web内容。</li></ul><p><img src="/3.png" alt="Tomcat与Servlet的关系"></p><h2 id="标准Java-Web工程结构"><a href="#标准Java-Web工程结构" class="headerlink" title="标准Java Web工程结构"></a>标准Java Web工程结构</h2><p><img src="/4.png" alt="标准Java Web工程结构"></p><h2 id="Servlet开发步骤"><a href="#Servlet开发步骤" class="headerlink" title="Servlet开发步骤"></a>Servlet开发步骤</h2><ol><li>创建Servlet类，继承HttpServlet；</li><li>重写service方法，编写程序代码；</li><li>配置web.xml，绑定URL。</li></ol><h2 id="Servlet的访问方法"><a href="#Servlet的访问方法" class="headerlink" title="Servlet的访问方法"></a>Servlet的访问方法</h2><ul><li><code>http://IP地址:端口/context-path/url-mapping</code></li><li>远程访问使用IP地址，本地访问localhost(127.0.0.1)</li><li>context-path称为“上下文路径”，默认为工程名</li></ul><h2 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h2><ul><li>请求参数是指浏览器通过请求向Tomcat提交的数据</li><li>请求参数通常是用户输入的数据，待Servlet进行处理</li><li>参数名1=值1&amp;参数名2=值2&amp;参数名n=值n…</li></ul><h2 id="Servlet接收请求参数"><a href="#Servlet接收请求参数" class="headerlink" title="Servlet接收请求参数"></a>Servlet接收请求参数</h2><pre class=" language-JAVA"><code class="language-JAVA">request.getParameter()  //接收单个参数request.getParameterValues()  //接收多个同名参数</code></pre><h2 id="Get和Post请求方法"><a href="#Get和Post请求方法" class="headerlink" title="Get和Post请求方法"></a>Get和Post请求方法</h2><ul><li><p>Get方法是将数据通过在URL附加数据显性向服务器发送数据</p><ul><li><code>http://localhost:8080/FirstServlet/sample?name=zhangsan</code></li></ul></li><li><p>Post方式会将数据存放在”请求体”中隐性向服务器发送数据</p><ul><li><code>http://localhost:8080/FirstServlet/sample</code></li><li>请求体：<code>name=zhangsan</code></li></ul></li></ul><pre class=" language-HTML"><code class="language-HTML"><!-- 设置方式 --><form action="/FirstServlet/sample" method="post"><!-- 默认不写method情况下使用Get方法 --><form action="/FirstServlet/sample"></code></pre><h2 id="Get与Post处理方式"><a href="#Get与Post处理方式" class="headerlink" title="Get与Post处理方式"></a>Get与Post处理方式</h2><pre class=" language-JAVA"><code class="language-JAVA">//所有请求，起到了对两种不同处理方式的分发作用public void service(){}//Get请求public void doGet(){}//Post请求public void doPost(){}</code></pre><h2 id="Get和Post应用场景"><a href="#Get和Post应用场景" class="headerlink" title="Get和Post应用场景"></a>Get和Post应用场景</h2><ul><li><p>Get常用于不包含敏感信息的查询功能，百度谷歌查询结果</p><ul><li>例如<code>https://www.baidu.com/s?wd=imooc&amp;rsv_spt=1</code></li></ul></li><li><p>Post方式用于安全性要求较高的功能或者服务器的写操作</p><ul><li>用户登录</li><li>用户注册</li><li>更新公司账目</li></ul></li></ul><h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><ul><li><p>共分为5个阶段</p><ol><li>装载 - <code>web.xml</code></li><li>创建 = 构造函数</li><li>初始化 - init()</li><li>提供服务 - service()</li><li>销毁 - destroy()</li></ol></li></ul><h2 id="使用注解简化配置"><a href="#使用注解简化配置" class="headerlink" title="使用注解简化配置"></a>使用注解简化配置</h2><ul><li>Servlet 3.x字后引入了”注解Annotation”特性</li><li>注解用于简化Web应用程序的配置过程</li><li>Servlet核心注解：<code>@WebServlet</code></li></ul><pre class=" language-JAVA"><code class="language-JAVA">@WebServlet("/anno")public class Annotation extends HttpServlet{  @Override  protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {    resp.getWriter().println("I am annotation servlet!");  }}</code></pre><h2 id="启动自动加载Servlet"><a href="#启动自动加载Servlet" class="headerlink" title="启动自动加载Servlet"></a>启动自动加载Servlet</h2><ul><li>web.xml使用<code>&lt;load-on-startup&gt;</code>设置启动加载；</li><li><code>&lt;load-on-startup&gt;0~9999&lt;/load-on=startup&gt;</code>，执行的时候会按照标签内部的序号从小到大依次执行；</li><li>启动时加载在生产中常用于系统的预处理，将复杂的程序在启动时加载好，在执行过程中不需要进行额外的处理，可以减少使用时候的卡顿；</li><li>需要重写init()函数。</li></ul><pre class=" language-HTML"><code class="language-HTML"><!-- 采用web.xml文件配置启动自动加载 --><servlet>  <servlet-name>create</servlet-name>  <servlet-class>com.imooc.servlet.CreateServlet</servlet-class>  <load-on-startup>0</load-on-startup>  <!-- 0代表最先被加载 --></servlet></code></pre><pre class=" language-JAVA"><code class="language-JAVA">// 采用注解方式实现启动自动加载，注意，一定要设置url才能生效，loadOnStartup的值是加载顺序@WebServlet(urlPatterns="/unused",loadOnStartup=2)public class AnalysisServlet extends HttpServlet{  @Override  public void init() throws ServletException{    System.out.println("正在分析结果");  }}</code></pre><h2 id="HTTP请求的结构"><a href="#HTTP请求的结构" class="headerlink" title="HTTP请求的结构"></a>HTTP请求的结构</h2><ul><li>HTTP请求包含三部分：请求行、请求头、请求体</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络配置与路由详解及其总结</title>
      <link href="/2020/11/02/wang-luo-pei-zhi-yu-lu-you-xiang-jie/"/>
      <url>/2020/11/02/wang-luo-pei-zhi-yu-lu-you-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><pre class=" language-BASH"><code class="language-BASH"># 显示是否响应广播设置cat /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts# 设置是否响应广播echo 0 > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts# 广播pingping -b 255.255.255.255</code></pre><ul><li>广播ping的ttl值可以用来判断系统类型，128为windows，64为linux</li><li>子网掩码不同不一定代表不能通信</li></ul><h2 id="route命令"><a href="#route命令" class="headerlink" title="route命令"></a>route命令</h2><ul><li>路由管理命令</li><li>查看：route -n</li><li>添加：route add</li></ul><pre class=" language-BASH"><code class="language-BASH">route add [-net|-host] target [netmask Nm] [gw Gw] [[dev] If]</code></pre><ul><li>目标：192.168.1.3 网关：172.16.0.1</li></ul><pre class=" language-BASH"><code class="language-BASH">route add -host 193.168.1.3 gw 172.16.0.1 dev eth0</code></pre><ul><li>目标：192.168.0.0 网关 172.16.0.1</li></ul><pre class=" language-BASH"><code class="language-BASH">route add -net 192.168.0.0 netmask 255.255.255.0 gw 172.16.0.1 dev eth0route add -net 192.168.0.0/24 gw 172.16.0.1 dev etho0</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML特点及其总结</title>
      <link href="/2020/11/01/xml/"/>
      <url>/2020/11/01/xml/</url>
      
        <content type="html"><![CDATA[<h2 id="XML介绍与用途"><a href="#XML介绍与用途" class="headerlink" title="XML介绍与用途"></a>XML介绍与用途</h2><h3 id="什么是XML"><a href="#什么是XML" class="headerlink" title="什么是XML"></a>什么是XML</h3><ul><li>XML的全称是E<code>X</code>tensible <code>M</code>arkup <code>L</code>anguage，可扩展标记语言。</li><li>编写XML就是编写标签，与HTML非常类似，扩展名<code>.xml</code>。</li><li>良好的人机可读性。</li></ul><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>employee</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>张三<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>age</span><span class="token punctuation">></span></span>31<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>age</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>height</span><span class="token punctuation">></span></span>178<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>height</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>employee</span><span class="token punctuation">></span></span></code></pre><h3 id="XML与HTML的比较"><a href="#XML与HTML的比较" class="headerlink" title="XML与HTML的比较"></a>XML与HTML的比较</h3><ul><li>XML与HTML非常相似，都是编写标签。</li><li>XML没有预定义标签，HTML存在大量预定义标签。</li><li>XML重在保存和传输数据，HTML用于显示信息。</li></ul><p><img src="/1.png" alt="XML与HTML的比较示意图"></p><h3 id="XML用途"><a href="#XML用途" class="headerlink" title="XML用途"></a>XML用途</h3><ul><li>Java程序的配置描述文件。</li></ul><p><img src="/2.png" alt="Web配置文件示例"></p><ul><li>用于保存程序产生的数据</li></ul><p><img src="/3.png" alt="数据包裹示意图"></p><ul><li>网络间的数据传输</li></ul><p><img src="/4.png" alt="网络数据包裹示意图"></p><h3 id="XML的文档结构"><a href="#XML的文档结构" class="headerlink" title="XML的文档结构"></a>XML的文档结构</h3><ul><li>第一行必须是XML声明；</li><li>有且仅有一个根节点；</li><li>XML标签的书写规则与HTML相同。</li></ul><h3 id="XML声明"><a href="#XML声明" class="headerlink" title="XML声明"></a>XML声明</h3><ul><li>XML声明说明了XML文档的基本信息，包括版本号与字符集，写在XML第一行。</li></ul><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token comment" spellcheck="true">&lt;!-- 版本号常见为1.0/1.1 --></span><span class="token comment" spellcheck="true">&lt;!-- UTF-8字符集，用于支持中文 --></span></code></pre><h3 id="XML语法检查方法"><a href="#XML语法检查方法" class="headerlink" title="XML语法检查方法"></a>XML语法检查方法</h3><ul><li>使用浏览器可以直接检查XML文件，直接把XML文件拖入浏览器就可以了。</li></ul><h2 id="XML的语法规则"><a href="#XML的语法规则" class="headerlink" title="XML的语法规则"></a>XML的语法规则</h2><h3 id="合法的标签名"><a href="#合法的标签名" class="headerlink" title="合法的标签名"></a>合法的标签名</h3><ul><li>标签名要有意义；</li><li>建议标签名使用英文小写字母，单词直接使用”-“进行分割；</li><li>建议多级标签之间不要存在重名的情况。</li></ul><h3 id="适当的注释与缩进"><a href="#适当的注释与缩进" class="headerlink" title="适当的注释与缩进"></a>适当的注释与缩进</h3><ul><li>适当的注释与缩进可以让XML文档更容易阅读</li></ul><h3 id="合理使用属性"><a href="#合理使用属性" class="headerlink" title="合理使用属性"></a>合理使用属性</h3><ul><li>标签属性用于描述标签不可或缺的信息；</li><li>对标签分组或者为标签设置Id时常用属性表示；</li><li>唯一的身份信息一般作为属性表示。</li></ul><p><img src="/5.png" alt="合理的属性使用示例"></p><h3 id="处理特殊字符"><a href="#处理特殊字符" class="headerlink" title="处理特殊字符"></a>处理特殊字符</h3><ul><li><p>标签体中，出现<code>&lt;``&gt;</code>等字符，会破坏文档结构，使文件没有办法被正确解析。</p></li><li><p>解决方案1：使用实体引用；</p></li><li><p>解决方案2：使用CDATA标签。</p><ul><li>CDATA指的是不应由XML解析器解析的文本数据</li><li>从<code>&lt;![CDATA[</code>开始，到<code>]]&gt;</code>结束</li></ul></li></ul><p><img src="/6.png" alt="XML支持的实体引用示意图"></p><h3 id="有序的子元素"><a href="#有序的子元素" class="headerlink" title="有序的子元素"></a>有序的子元素</h3><ul><li>在XML多层嵌套的子元素中，标签前后顺序应该保持一致，这是约定俗成的表达方法，虽然不这样写不会出现错误，但不利于阅读。</li></ul><h2 id="XML语义约束"><a href="#XML语义约束" class="headerlink" title="XML语义约束"></a>XML语义约束</h2><ul><li>XML文档结构正确，但可能不是有效的。</li><li>XML语义约束就是用于规定XML文档中允许出现哪些元素</li><li>XML语义约束有两种定义方式：DTD和XML Schema</li></ul><h3 id="Document-Type-Definition"><a href="#Document-Type-Definition" class="headerlink" title="Document Type Definition"></a>Document Type Definition</h3><ul><li>DTD(Document Type Definition，文档类型定义)是一种简单易用的语义约束方式；</li><li>DTD文件的扩展名为.dtd。</li></ul><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 定义了hr节点下只允许出现1个employee子节点 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ELEMENT</span> <span class="token attr-name">hr(employee)</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- employee节点下必须包含以下四个节点，且按顺序出现 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ELEMENT</span> <span class="token attr-name">employee(name,age,salary,department)</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 设置节点属性值 节点名称 属性名称 值的类型 默认值 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ATTLIST</span> <span class="token attr-name">employee</span> <span class="token attr-name">no</span> <span class="token attr-name">CDATA</span> <span class="token attr-name">""</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 定义name标签体只能是文本，#PCDATA代表文本元素 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ELEMENT</span> <span class="token attr-name">name(#PCDATA)</span><span class="token punctuation">></span></span></code></pre><h4 id="DTD定义结点及节点数量"><a href="#DTD定义结点及节点数量" class="headerlink" title="DTD定义结点及节点数量"></a>DTD定义结点及节点数量</h4><ul><li>利用DTD中的<code>&lt;!ELEMENT&gt;</code>标签，我们可以定义XML文档中允许出现的节点及数量。</li><li>如果某个子节点需要多次重复出现，则需要在子节点后增加相应的描述符。</li></ul><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- hr节点下最少出现1个employee子节点 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ELEMENT</span> <span class="token attr-name">hr(employee+)</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- hr节点下出现0~n个employee子节点 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ELEMENT</span> <span class="token attr-name">hr(employee*)</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- hr节点下最多出现1个employee子节点 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ELEMENT</span> <span class="token attr-name">hr(employee?)</span><span class="token punctuation">></span></span></code></pre><h4 id="XML引用DTD文件"><a href="#XML引用DTD文件" class="headerlink" title="XML引用DTD文件"></a>XML引用DTD文件</h4><ul><li>在XML中使用<code>&lt;!DOCTYPE&gt;</code>标签来引用DTD文件</li></ul><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 书写格式 --></span><span class="token doctype">&lt;!DOCTYPE 根节点 SYSTEM "dtd文件路径"></span><span class="token comment" spellcheck="true">&lt;!-- 示例： --></span><span class="token doctype">&lt;!DOCTYPE hr SYSTEM "hr.dtd"></span></code></pre><h3 id="XML-Schema"><a href="#XML-Schema" class="headerlink" title="XML Schema"></a>XML Schema</h3><ul><li>XML Schema比DTD更复杂，提供了更多的功能；</li><li>XML Schema提供了数据类型、格式限定、数据范围等特性；</li><li>XML Schema是W3C标准。</li></ul><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>schema</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>element</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hr<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--complexType标签含义是复杂节点，包含子节点时必须使用这个标签--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>complexType</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sequence</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>element</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>employee<span class="token punctuation">"</span></span> <span class="token attr-name">minOccurs</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">maxOccurs</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>unbounded<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>complexType</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sequence</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>element</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>string<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>element</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>integer<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>element</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>salary<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>integer<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>element</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>department<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>complexType</span><span class="token punctuation">></span></span>                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sequence</span><span class="token punctuation">></span></span>                                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>element</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dname<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>string<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>element</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>string<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sequence</span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>complexType</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>element</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sequence</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>attribute</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>no<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>string<span class="token punctuation">"</span></span> <span class="token attr-name">use</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>required<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>complexType</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>element</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sequence</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>complexType</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>element</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>schema</span><span class="token punctuation">></span></span></code></pre><h2 id="Java解析XML"><a href="#Java解析XML" class="headerlink" title="Java解析XML"></a>Java解析XML</h2><ul><li>DOM(Document Object Model)定义了访问和操作XML文档的标准方法，DOM把XML文档作为树结构来查看，能够通过DOM树来读写所有元素。</li></ul><h3 id="Dom4j"><a href="#Dom4j" class="headerlink" title="Dom4j"></a>Dom4j</h3><ul><li>Dom4j是一个易用的、开源的库，用于解析XML。它应用于Java平台，具有性能优异、功能强大和极其易使用的特点。</li><li>Dom4j将XML视为<code>Document</code>对象。</li><li>XML标签被Dom4j视为<code>Element</code>对象</li></ul><h2 id="XPath路径表达式"><a href="#XPath路径表达式" class="headerlink" title="XPath路径表达式"></a>XPath路径表达式</h2><ul><li>XPath路径表达式是XML文档中查询数据的语言；</li><li>掌握XPath可以极大得提高在提取数据时的开发效率；</li><li>学习XPath本质就是掌握各种形式表达式的使用技巧。</li></ul><h3 id="Jaxen介绍"><a href="#Jaxen介绍" class="headerlink" title="Jaxen介绍"></a>Jaxen介绍</h3><ul><li>Jaxen是一个Java编写的开源的XPath库。这是适应多种不同那个的对象模型，包括DOM，XOM，dom4j和JDOM。</li><li>Dom4j底层以来Jaxen实现XPath查询</li><li>Jaxen下载地址：jaxen.codehaus.org</li></ul><p><img src="/7.png" alt="XPath基本表达式示意图"></p><p><img src="/8.png" alt="XPath基本表达式案例示意图"></p><p><img src="/9.png" alt="XPath谓语表达式示意图"></p><ul><li>xpath实例代码</li></ul><pre class=" language-java"><code class="language-java">xpt<span class="token punctuation">.</span><span class="token function">xpath</span><span class="token punctuation">(</span><span class="token string">"/hr/employee"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//显示根节点下的所有员工</span>xpt<span class="token punctuation">.</span><span class="token function">xpath</span><span class="token punctuation">(</span><span class="token string">"//employee"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">/</span><span class="token operator">/</span>显示所有员工xpt<span class="token punctuation">.</span><span class="token function">xpath</span><span class="token punctuation">(</span><span class="token string">"//employee[salary&lt;4000]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">/</span><span class="token operator">/</span>显示工资小于<span class="token number">4000</span>的员工xpt<span class="token punctuation">.</span><span class="token function">xpath</span><span class="token punctuation">(</span><span class="token string">"//employee[name='李铁柱']"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">/</span><span class="token operator">/</span>显示姓名为李铁柱的员工xpt<span class="token punctuation">.</span><span class="token function">xpath</span><span class="token punctuation">(</span><span class="token string">"//employee[@no=3310]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">/</span><span class="token operator">/</span>显示工号为<span class="token number">3310</span>的员工xpt<span class="token punctuation">.</span><span class="token function">xpath</span><span class="token punctuation">(</span><span class="token string">"//employee[1]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token operator">/</span><span class="token operator">/</span>显示第一名员工xpt<span class="token punctuation">.</span><span class="token function">xpath</span><span class="token punctuation">(</span><span class="token string">"//employee[last()]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">/</span><span class="token operator">/</span>显示最后的一名员工xpt<span class="token punctuation">.</span><span class="token function">xpath</span><span class="token punctuation">(</span><span class="token string">"//employee[position()&lt;6]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">/</span><span class="token operator">/</span>显示前六名员工xpt<span class="token punctuation">.</span><span class="token function">xpath</span><span class="token punctuation">(</span><span class="token string">"//employee[3] | //employee[8]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">/</span><span class="token operator">/</span>同时显示第<span class="token number">3</span>名和第<span class="token number">8</span>名员工</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> 知识总结 </tag>
            
            <tag> XML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript特点的总结</title>
      <link href="/2020/10/27/javascript/"/>
      <url>/2020/10/27/javascript/</url>
      
        <content type="html"><![CDATA[<h2 id="JS简介"><a href="#JS简介" class="headerlink" title="JS简介"></a>JS简介</h2><ul><li>JS是JavaScript的简称，是一种脚本语言。</li><li>广泛地用于HTML页面中，使页面功能更丰富更完善。</li><li>动态页面：用户与网页之间有直接的信息沟通，会将用户的信息传到后台去。</li><li>静态页面：用户与网页之间没有直接的信息沟通。</li><li>JavaScript是浏览器自带的功能，不需要额外安装</li><li>BOM：浏览器对象模型</li><li>DOM：文档对象模型</li></ul><h2 id="页面使用JS的方法"><a href="#页面使用JS的方法" class="headerlink" title="页面使用JS的方法"></a>页面使用JS的方法</h2><ul><li>使用<code>&lt;script&gt;</code>在HTML页面中插入JavaScript。</li><li>引用外部JS文件</li><li>JS语句每一局代码结束都需要使用分号作为结束符。</li></ul><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- 引入程序内js --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"hello javascript"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 引入程序外js --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src"js1.js"</span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><h2 id="JS中的变量"><a href="#JS中的变量" class="headerlink" title="JS中的变量"></a>JS中的变量</h2><ul><li>与其他程序设计语言相同，是用来临时存储信息，在创建的时候不区分数据类型，但是在赋值的时候是区分数据类型的。</li><li>创建方法</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 创建方法一</span><span class="token keyword">var</span> x<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">var</span> x<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>name<span class="token operator">=</span><span class="token string">"Johnson"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建方法二</span><span class="token keyword">var</span> x<span class="token punctuation">;</span>x<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span></code></pre><ul><li>JS中的变量，区分类型，但没有int之类的关键字。</li></ul><h2 id="JS调试"><a href="#JS调试" class="headerlink" title="JS调试"></a>JS调试</h2><ul><li><p>总共有两种调试方法：</p><ol><li>alert弹框调试</li><li>Console.log控制台输出调试。</li></ol></li><li><p>用于观察变量值的变化规律、是否符合程序设计的目的。</p></li></ul><pre class=" language-js"><code class="language-js"><span class="token function">alert</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><ul><li>是完成某一功能的代码段，可重复执行，方便管理与维护。</li><li>可以先定义后使用也可以先使用后定义，但最好是先定义后使用。</li></ul><pre class=" language-JS"><code class="language-JS">//传统函数定义方法function fun1(){  //代码片段  return ***;}//函数表达式定义方法var fun1=function(x){  return x+1;}</code></pre><h2 id="数据类型与类型转换"><a href="#数据类型与类型转换" class="headerlink" title="数据类型与类型转换"></a>数据类型与类型转换</h2><p><img src="/1.png" alt="数据类型与类型转换1"><br><img src="/2.png" alt="数据类型与类型转换2"></p><ul><li>类型转换 parseInt() parseFloat() Number() Boolean()</li><li>强制类型转换、隐式类型转换</li></ul><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><ul><li>全局变量、局部变量</li><li>在函数内部创建的变量，称为局部变量，其他函数不能使用。</li><li>在函数外部创建的变量，称为全局变量，在函数之间可以共享使用。</li></ul><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><ul><li>用于比较两个值，结果是true或者false</li><li><code>&gt;</code>、<code>&gt;=</code>、<code>!=</code>、<code>&lt;</code>、<code>&lt;=</code></li><li>运算符的优先级</li></ul><p><img src="/3.png" alt="运算符的优先级"></p><h2 id="程序控制语句"><a href="#程序控制语句" class="headerlink" title="程序控制语句"></a>程序控制语句</h2><ul><li>条件判断类的控制语句</li></ul><pre class=" language-JS"><code class="language-JS">var n=10;var str;if(n > 10){  str = "n>10";}else if(n < 10){  str = "n<10";}else{  str = "n=10";}console.log(str);</code></pre><ul><li><code>switch</code>语句</li></ul><pre class=" language-JS"><code class="language-JS">var myscore = 95;var str;var n = myscore/10;switch(myscore){  case 10:    str = "满分";    break;  case 9:    str = "优秀";    break;  case 8:  case 7:    str = "良好";    break;  case 6:    str = "及格";    break;  default:    str = "不及格";    break;}</code></pre><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p><img src="/4.png" alt="内置函数示意图"></p><pre class=" language-JS"><code class="language-JS">str.substr(0,3);  //起始位置，长度str.substring(0,3); //起始位置，结束位置str.length;str.indexOf(1);</code></pre><h3 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h3><h4 id="分割操作"><a href="#分割操作" class="headerlink" title="分割操作"></a>分割操作</h4><pre class=" language-JS"><code class="language-JS">var str="aa,ttt,121,gg,kk,aa,bb";var arr=str.split(","); //把数组以逗号为分界线进行分割，分割后装入数组中console.log(arr[0]);  //打印数组，输出为aa,ttt,121,gg,kk,aa,bb</code></pre><h4 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h4><pre class=" language-JS"><code class="language-JS">str.concat("55","77","00");</code></pre><h4 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a>替换操作</h4><pre class=" language-JS"><code class="language-JS">str.replace("aa","bb"); //将第一个参数代表的内容替换为第二参数代表的内容</code></pre><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><pre class=" language-JS"><code class="language-JS">var d1=new Date();var d2=new Date("1999-5-20 16:54:21");console.log(d2.getDate());console.log(d1.getDate());console.log(d2.getMonth()); //月份是从零开始的，0-11，这是从java1.0中继承过来的。var n=d2.getTime()-d1.getTime();  //返回两个日期之间相差的毫秒数console.log(parseInt(n/(24*3600*1000)));  //输出天数//2020-01-01 15:58 日期格式化function fun_Fmtdate() {    var d1 = new Date();    var y, m, d, h, mi, s;    var time;    y = d1.getFullYear();    m = d1.getMonth();    d = d1.getDate();    h = d1.getHours();    mi = d1.getMinutes();    s = d1.getSeconds();    time = y + "-" + m + "-" + d + " " + h + ":" + mi + ":" + s;    return time;}</code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h3><pre class=" language-JS"><code class="language-JS">// 声明或创建一个不指定长度的数组，又称实例化创建var arrayObj = new Array();// 声明或创建一个数组并指定长度var arrayObj = new Array(5);// 声明或创建一个带有默认值的数组var arrayObj = new Array(2, 4, "a");// 创建一个数组并赋值的简写，又称隐式创建数据var arrayObj = [2, 4, "a"];</code></pre><h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><pre class=" language-JS"><code class="language-JS">console.log(array[0]);// for循环遍历1，这种方式比较方便便捷。for(var i in arrayObj){  console.log(i);}// for循环遍历2var i = 0;var n = arrayObj.length;for(i;i<n;i++){  console.log(arrayObj[i]);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> 知识总结 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>股票思路与操作日记</title>
      <link href="/2020/10/26/gu-piao/"/>
      <url>/2020/10/26/gu-piao/</url>
      
        <content type="html"><![CDATA[<h2 id="2020年"><a href="#2020年" class="headerlink" title="2020年"></a>2020年</h2><h3 id="2020年10月"><a href="#2020年10月" class="headerlink" title="2020年10月"></a>2020年10月</h3><h4 id="2020年10月26日"><a href="#2020年10月26日" class="headerlink" title="2020年10月26日"></a>2020年10月26日</h4><h5 id="交易记录"><a href="#交易记录" class="headerlink" title="交易记录"></a>交易记录</h5><table><thead><tr><th>买卖</th><th>股票名称</th><th>数量</th><th>成本</th><th>卖出价（目标价）</th><th>盈利</th></tr></thead><tbody><tr><td>卖</td><td>海康威视</td><td>200</td><td>40.56</td><td>42.30</td><td>329.34</td></tr><tr><td>买</td><td>中国平安</td><td>100</td><td>82.83</td><td>86</td><td></td></tr></tbody></table><h5 id="行情分析"><a href="#行情分析" class="headerlink" title="行情分析"></a>行情分析</h5><table><thead><tr><th>股票or指数名称</th><th>日线分析</th><th>周线分析</th><th>月线分析</th></tr></thead><tbody><tr><td><strong>中国平安</strong></td><td>多空博弈，多方更强</td><td>可能会去触碰前高</td><td>下个月会出现回调，目标价79</td></tr><tr><td><strong>航天动力</strong></td><td>箱体震荡，目标价10元</td><td>如果这周没有站上20周线，存在下杀风险</td><td>月线风险不大</td></tr><tr><td><strong>海康威视</strong></td><td>BOLL值看空</td><td>BOLL值看空，这周必定是阳线</td><td>BOLL值看空，下个月存在下杀压力</td></tr><tr><td><strong>国泰君安</strong></td><td>超卖</td><td>下降三角形，警惕下跌风险</td><td>BOLL值看空，下个月存在下杀压力</td></tr><tr><td><strong>中矿资源</strong></td><td>受到20日线支撑，下跌减缓，预计在目前价位徘徊</td><td>下降三角形，警惕下跌风险</td><td>BOLL值看空，下个月存在下杀压力</td></tr><tr><td><strong>格力电器</strong></td><td>日线下方存在缺口，日后会回补</td><td>周线会在58元左右波动，趋势不明朗</td><td>紧缩三角形形态，趋势不明朗，但上涨概率大</td></tr><tr><td><strong>光大证券</strong></td><td>日线严重超卖，BOLL值看多</td><td>下降三角形，警惕下跌风险</td><td>BOLL值看空，下跌目标价不明确</td></tr><tr><td><strong>上证指数</strong></td><td>有下跌空间</td><td>紧缩三角形形态，这周不会出现新低</td><td>BOLL值看空，下跌价位不明确</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 股票交易 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 股票 </tag>
            
            <tag> 股票行情 </tag>
            
            <tag> 股票交易 </tag>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS样式特点的总结</title>
      <link href="/2020/10/25/css/"/>
      <url>/2020/10/25/css/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS简介"><a href="#CSS简介" class="headerlink" title="CSS简介"></a>CSS简介</h2><ul><li>CSS：Cascading Style Sheets，层叠样式列表</li><li>对某些对象可以进行分层次地设置。</li></ul><h2 id="CSS的作用"><a href="#CSS的作用" class="headerlink" title="CSS的作用"></a>CSS的作用</h2><ul><li>结构与样式分离的方式，便于后期维护与改版；</li><li>可以用多套样式，使网页有任意样式切换的效果；</li><li>使页面载入得更快、降低服务器的成本。</li></ul><h2 id="CSS语法格式、选择器及分类"><a href="#CSS语法格式、选择器及分类" class="headerlink" title="CSS语法格式、选择器及分类"></a>CSS语法格式、选择器及分类</h2><h3 id="CSS样式文件结构"><a href="#CSS样式文件结构" class="headerlink" title="CSS样式文件结构"></a>CSS样式文件结构</h3><ul><li>样式选择器可以是HTML中的任何一个标签，称为标签选择器，代表的是把该类都进行选中，之后进行格式设置和样式改变。</li></ul><p><img src="/1.png" alt="文件结构示意图"></p><p><img src="/2.png" alt="内部样式表示意图"></p><ul><li>如果CSS样式内容放在html文件内部，则称之为内部样式表，如果放在专门的文件中则称为外部样式表。下面的代码是内部样式表的一个示例代码：</li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 内部样式表 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">        <span class="token comment" spellcheck="true">/* 标签选择器 */</span>            <span class="token selector">p</span><span class="token punctuation">{</span>                <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>                <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">40</span>px<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">async</span> <span class="token attr-name">defer</span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>https://www.imooc.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>慕课网<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>上海大学2019级本科新生数据“大揭秘”,上海大学2019级本科新生数据大揭秘,梯方在线-上海家长都在选择的在线互动小班课,专注小升初中高考升学辅导,一对一在线辅导补习<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><ul><li>作用：用来选择（找到）需要添加样式的位置。</li><li>常用选择器：标签选择器、（归）类选择器</li><li>选择器用法代码示例如下：</li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">        <span class="token comment" spellcheck="true">/* 标签选择器 */</span>            <span class="token selector">p</span><span class="token punctuation">{</span>                <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>                <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">40</span>px<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token selector"><span class="token class">.p1</span></span><span class="token punctuation">{</span>                <span class="token property">font-family</span><span class="token punctuation">:</span> 隶书<span class="token punctuation">;</span>                <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">35</span>px<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">async</span> <span class="token attr-name">defer</span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>https://www.imooc.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>慕课网<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 加入的类选择器 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>p1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>上海大学2019级本科新生数据“大揭秘”,上海大学2019级本科新生数据大揭秘,梯方在线-上海家长都在选择的在线互动小班课,专注小升初中高考升学辅导,一对一在线辅导补习<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 上面这段话用了两种样式，一个是p段落标签指定的样式，另一个是class指定的样式，体现了多层次样式叠加的特点 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h3 id="使用内部样式表实现背景设置"><a href="#使用内部样式表实现背景设置" class="headerlink" title="使用内部样式表实现背景设置"></a>使用内部样式表实现背景设置</h3><p><img src="/3.png" alt="背景样式示意图"></p><p><img src="/4.png" alt="background-position属性列表示意图"></p><ul><li>背景层叠样式的设置示例代码</li></ul><pre class=" language-css"><code class="language-css"><span class="token selector">body</span><span class="token punctuation">{</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> aquamarine<span class="token punctuation">;</span>    <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token url">url("../image/3.png")</span><span class="token punctuation">;</span>    <span class="token property">background-attachment</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>    <span class="token property">background-position</span><span class="token punctuation">:</span> top center<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="使用外部样式表实现设置"><a href="#使用外部样式表实现设置" class="headerlink" title="使用外部样式表实现设置"></a>使用外部样式表实现设置</h3><ul><li>外部样式表：外部样式表是新建一个文档，里面全写CSS，然后再通过link插入到html代码中。</li><li>所用：使网页的表示层和结构层彻底分离</li><li>将背景设置，修改为外部样式表</li><li><strong>注意</strong>：除了link进行外部样式表的连接，还有其他的方法</li><li>引用外部样式表的示例代码</li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>index.css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><h2 id="CSS基础样式"><a href="#CSS基础样式" class="headerlink" title="CSS基础样式"></a>CSS基础样式</h2><h3 id="CSS颜色设置"><a href="#CSS颜色设置" class="headerlink" title="CSS颜色设置"></a>CSS颜色设置</h3><ul><li>颜色的设置有三种方法，第一种是直接用颜色的单词进行设置，第二种是通过16进制代码进行表示，第三种是通过rgb(78,12,23)的形式来表示。</li></ul><h3 id="CSS文本样式"><a href="#CSS文本样式" class="headerlink" title="CSS文本样式"></a>CSS文本样式</h3><p><img src="/5.png" alt="文本样式设置示意图"></p><p><img src="/6.png" alt="文本样式设置示意图"></p><ul><li>示例代码</li></ul><pre class=" language-css"><code class="language-css"><span class="token selector">p </span><span class="token punctuation">{</span>    <span class="token property">color</span><span class="token punctuation">:</span> <span class="token function">rgb</span><span class="token punctuation">(</span><span class="token number">255</span>, <span class="token number">255</span>, <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">direction</span><span class="token punctuation">:</span> rtl<span class="token punctuation">;</span>    <span class="token property">letter-spacing</span><span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token punctuation">;</span>    <span class="token property">line-height</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>    <span class="token property">text-align</span><span class="token punctuation">:</span> justify<span class="token punctuation">;</span>    <span class="token property">text-indent</span><span class="token punctuation">:</span> <span class="token number">2</span>em<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>其中，<code>direction</code>和<code>text-align</code>的区别仅仅是对阿拉伯语（包括阿拉伯数字）有区别，对于其他的语种来说没有区别。对于阿拉伯语（包括阿拉伯数字）来说，<code>direction : rtl</code>会进行逆序输出。另外，<code>1em</code>这个单位代表的是一个字符的宽度。</li></ul><h3 id="CSS字体样式"><a href="#CSS字体样式" class="headerlink" title="CSS字体样式"></a>CSS字体样式</h3><ul><li>字体样式：<code>font-style</code>、<code>font-family</code>等</li><li>作用：定义文本的字体系列、大小、加粗、风格（如斜体）和变形（如大写小写字母）。</li></ul><h2 id="CSS列表样式"><a href="#CSS列表样式" class="headerlink" title="CSS列表样式"></a>CSS列表样式</h2><p><img src="/7.png" alt="CSS列表样式示意图"></p><h2 id="CSS的伪类"><a href="#CSS的伪类" class="headerlink" title="CSS的伪类"></a>CSS的伪类</h2><ul><li><p>通常情况下，超级链接上设置的样式，称为伪类</p></li><li><p>作用：设置超级链接的4中状态</p></li><li><p><strong>注意</strong>：1. 伪类是用在超链接上的下过比较多，但超链接不是伪类。2. 伪类是选择器。</p></li><li><p>伪类用法示例代码</p></li></ul><pre class=" language-css"><code class="language-css"><span class="token selector">a<span class="token pseudo-class">:link</span> </span><span class="token punctuation">{</span>    <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">a<span class="token pseudo-class">:visited</span> </span><span class="token punctuation">{</span>    <span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">a<span class="token pseudo-class">:hover</span> </span><span class="token punctuation">{</span>    <span class="token property">color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>    <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">30</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">a<span class="token pseudo-class">:active</span> </span><span class="token punctuation">{</span>    <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">label<span class="token pseudo-class">:hover</span> </span><span class="token punctuation">{</span>    <span class="token property">color</span><span class="token punctuation">:</span> blueviolet<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="伪类的分类"><a href="#伪类的分类" class="headerlink" title="伪类的分类"></a>伪类的分类</h3><ul><li>状态伪类</li></ul><p><img src="/8.png" alt="伪类选择器属性示意图"></p><ul><li>结构性伪类</li></ul><p><img src="/9.png" alt="结构性伪类示意图"></p><h2 id="子孙选择器以及其他选择器"><a href="#子孙选择器以及其他选择器" class="headerlink" title="子孙选择器以及其他选择器"></a>子孙选择器以及其他选择器</h2><ul><li><code>div</code>段落标记：相当于容器，把代码进行分割</li><li>可以通过div编号进行选择，这种选择器称为子孙选择器。</li></ul><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 子孙选择器 */</span><span class="token selector"><span class="token id">#div1</span> p</span><span class="token punctuation">{</span>    color = red<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 子选择器，只选择直接属于div1的p标签 */</span><span class="token selector"><span class="token id">#div1</span>>p</span><span class="token punctuation">{</span>    color = red<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 相邻兄弟选择器，只找和div1平级的p标签 */</span><span class="token selector"><span class="token id">#div1</span>+p</span><span class="token punctuation">{</span>    color = red<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 属性选择器，只选择class属性是p1的p标签 */</span><span class="token selector"><span class="token id">#div1</span><span class="token attribute">[class="p1"]</span>p</span><span class="token punctuation">{</span>    color = red<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="/10.png" alt="子孙选择器与其他选择器示意图"></p><h2 id="CSS选择器的优先级"><a href="#CSS选择器的优先级" class="headerlink" title="CSS选择器的优先级"></a>CSS选择器的优先级</h2><p><img src="/11.png" alt="CSS选择器优先级示意图"></p><pre class=" language-css"><code class="language-css"><span class="token selector">div</span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.div1</span></span><span class="token punctuation">{</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> yellow!important<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token id">#div2</span></span><span class="token punctuation">{</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="CSS浮动"><a href="#CSS浮动" class="headerlink" title="CSS浮动"></a>CSS浮动</h2><h3 id="DIV样式设置"><a href="#DIV样式设置" class="headerlink" title="DIV样式设置"></a>DIV样式设置</h3><h4 id="DIV设置大小、位置、背景"><a href="#DIV设置大小、位置、背景" class="headerlink" title="DIV设置大小、位置、背景"></a>DIV设置大小、位置、背景</h4><pre class=" language-css"><code class="language-css"><span class="token selector">div</span><span class="token punctuation">{</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>    <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>         //x坐标    <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>        //y坐标    <span class="token property">overflow</span><span class="token punctuation">:</span> scroll<span class="token punctuation">;</span>   //溢出设置    <span class="token property">outline</span><span class="token punctuation">:</span> dashed<span class="token punctuation">;</span>    //边框效果设置    <span class="token property">border-left</span><span class="token punctuation">:</span> solid<span class="token punctuation">;</span> //左边框效果    <span class="token property">border-right</span><span class="token punctuation">:</span> solid<span class="token punctuation">;</span>//右边框效果    <span class="token property">border-top</span><span class="token punctuation">:</span> solid<span class="token punctuation">;</span>  //顶边框效果    <span class="token property">border-bottom</span><span class="token punctuation">:</span> solid<span class="token punctuation">;</span>   //底边框效果<span class="token punctuation">}</span></code></pre><h4 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h4><ul><li>width、height、border、margin(外边距)、padding</li><li>作用：用于页面布局</li><li>实例</li></ul><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/*对象和对象之间的距离*/</span><span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token comment" spellcheck="true">/*上*/</span> <span class="token number">10</span>px<span class="token comment" spellcheck="true">/*右*/</span> <span class="token number">10</span>px<span class="token comment" spellcheck="true">/*下*/</span> <span class="token number">10</span>px<span class="token comment" spellcheck="true">/*左*/</span><span class="token comment" spellcheck="true">/*对象和边框之间的距离*/</span><span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token comment" spellcheck="true">/*上*/</span> <span class="token number">10</span>px<span class="token comment" spellcheck="true">/*右*/</span> <span class="token number">10</span>px<span class="token comment" spellcheck="true">/*下*/</span> <span class="token number">10</span>px<span class="token comment" spellcheck="true">/*左*/</span></code></pre><p><img src="/12.png" alt="盒子模型示意图"></p><h3 id="行级元素和块级元素"><a href="#行级元素和块级元素" class="headerlink" title="行级元素和块级元素"></a>行级元素和块级元素</h3><ul><li>行级元素会分享一行</li><li>块级元素会独占一行</li></ul><h3 id="定位机制"><a href="#定位机制" class="headerlink" title="定位机制"></a>定位机制</h3><ul><li><p>文档流、脱标流（脱离标准文档流、浮动）</p></li><li><p>文档流特点：</p><ol><li>会产生空白折叠现象（在HTML换行的回车显示为一个小空格）；</li><li>高矮不齐，底边对齐</li><li>自动换行，一行写满之后就要换行书写</li></ol></li></ul><h3 id="float属性设置"><a href="#float属性设置" class="headerlink" title="float属性设置"></a>float属性设置</h3><p><img src="/13.png" alt="float属性设置"></p><h2 id="CSS定位"><a href="#CSS定位" class="headerlink" title="CSS定位"></a>CSS定位</h2><h3 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h3><ul><li>相对定位的偏移参考元素是元素本身，不会使元素脱离文档流。元素的初始位置占据的空间会被保留。</li></ul><pre class=" language-css"><code class="language-css"><span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span></code></pre><h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><ul><li>相对于已定位的最近的祖先元素，如果没有已定位的最近的祖先元素，那么它的位置就相对于最初包含块（如body）</li></ul><pre class=" language-css"><code class="language-css"><span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span></code></pre><ul><li>z-index：数值越大，越靠上</li></ul><pre class=" language-css"><code class="language-css"><span class="token property">z-index</span><span class="token punctuation">:</span> <span class="token number">40</span><span class="token punctuation">;</span></code></pre><h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><ul><li>相对于浏览器的位置是不改变的</li></ul><pre class=" language-css"><code class="language-css"><span class="token property">position</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span></code></pre><h3 id="其他定位"><a href="#其他定位" class="headerlink" title="其他定位"></a>其他定位</h3><h2 id="使用中遇到的问题"><a href="#使用中遇到的问题" class="headerlink" title="使用中遇到的问题"></a>使用中遇到的问题</h2><h3 id="overflow问题"><a href="#overflow问题" class="headerlink" title="overflow问题"></a>overflow问题</h3><ul><li>在使用css操作div的时候，经常会遇到例如设定了子div的浮动与高度，但父div的高度并没有被子div撑起来，这时，就需要使用到<code>overflow: hidden</code>的操作来清除浮动。各种情况如下图所示。</li></ul><p><img src="/14.png" alt="overflow问题总结示意图"></p><h3 id="实现水平居中、垂直居中的方法"><a href="#实现水平居中、垂直居中的方法" class="headerlink" title="实现水平居中、垂直居中的方法"></a>实现水平居中、垂直居中的方法</h3><ul><li>经常会遇到需要居中的情况，可以使用如下操作进行居中设置。</li></ul><p><img src="/15.png" alt="居中设置示意图"></p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> CSS样式 </tag>
            
            <tag> 知识总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发HTML特点的总结</title>
      <link href="/2020/10/25/html/"/>
      <url>/2020/10/25/html/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML简介"><a href="#HTML简介" class="headerlink" title="HTML简介"></a>HTML简介</h2><ul><li><p>什么是HTML</p><ul><li>Hyper Text Markup Language</li><li>超文本标记语言</li></ul></li></ul><h2 id="HTML文件结构"><a href="#HTML文件结构" class="headerlink" title="HTML文件结构"></a>HTML文件结构</h2><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>这里是页面的标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    这里是正文部分<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h2 id="HTML常用标签"><a href="#HTML常用标签" class="headerlink" title="HTML常用标签"></a>HTML常用标签</h2><h3 id="字体标签"><a href="#字体标签" class="headerlink" title="字体标签"></a>字体标签</h3><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span><span class="token punctuation">></span></span>....<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span></code></pre><ul><li>作用：规定文本的字体、字体尺寸、字体颜色；</li><li><strong>注意</strong>：在HTML4中，不赞成使用此标签，在HTML5中，不支持使用此标签。</li></ul><h3 id="段落标签"><a href="#段落标签" class="headerlink" title="段落标签"></a>段落标签</h3><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code></pre><ul><li>作用：定义一个段落；</li><li><strong>注意</strong>：段落内根据所在容器的宽度自动换行；浏览器会自动地在段落的前后添加空行；<code>&lt;p&gt;</code>和<code>&lt;br&gt;</code>的区别。</li></ul><h3 id="注释标签"><a href="#注释标签" class="headerlink" title="注释标签"></a>注释标签</h3><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!--..........--></span></code></pre><ul><li>作用：编写程序时，给代码的解释或提示，能提高程序代码的可读性，以便于之后的参考和修改。</li><li><strong>注意</strong>：注释不会在浏览器中进行显示，注释出现的频率非常高</li></ul><h3 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h3><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h?</span><span class="token punctuation">></span></span>.......<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h?</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--?是在1至6之间的一个数字，1-3是常用的标题--></span></code></pre><ul><li>作用：定义标题头的六个不同文字大小，依次显示重要性的递减，也就是权重依次降低。</li><li><strong>注意</strong>：尽量靠近在html中的<code>&lt;body&gt;</code>标签，越近越好，以便让搜索引擎最快地领略主题。h标签主要是给SEO进行优化，SEO是搜索引擎抓取网站信息的一种行为。</li></ul><h3 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h3><pre class=" language-html"><code class="language-html">&lt;img src = "***" /></code></pre><ul><li>作用：在浏览器中显示图片。</li><li>示例</li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>../image/1.png<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>image not found!<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre><ul><li>常用属性：src、alt(如果图片不存在显示的提示信息)、height、width。</li><li><strong>注意</strong>：相对路径与绝对路径的区别。</li></ul><h3 id="超级链接标签"><a href="#超级链接标签" class="headerlink" title="超级链接标签"></a>超级链接标签</h3><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span><span class="token punctuation">></span></span>....<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span></code></pre><ul><li>作用：使用超级链接与网络上的另一个文档相连。</li><li>示例</li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>page2.html<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>打开另一个页面<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://www.imooc.com<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>../image/1.png<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span></code></pre><ul><li><strong>注意</strong>：超级链接可以是一个字，一个词，或者一组词，也可以是一幅图像，您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。</li><li>A标签有一个target属性，这些属性对应的内容如下图所示。</li></ul><p><img src="/1.png" alt="A标签target属性"></p><h3 id="A标签的锚点类型"><a href="#A标签的锚点类型" class="headerlink" title="A标签的锚点类型"></a>A标签的锚点类型</h3><ul><li>锚点标签</li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ziti<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>....<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span></code></pre><ul><li>作用：同一个文档中创建指向该锚（位置）的连接</li><li>示例</li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>目录<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#duanluo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>段落标签<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>page1.html#ziti<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>字体标签<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span></code></pre><ul><li><strong>注意</strong>：锚点必须先定义，再使用。</li></ul><h3 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h3><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!--无序列表--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>.....<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--有序列表--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>.....<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">></span></span></code></pre><ul><li>作用：此列项目使用粗体圆点（典型的小黑圆圈）进行标记</li><li>示例</li></ul><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!--无序列表--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>我的文件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>我的图片<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--有序列表--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>我的文件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>我的图片<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">></span></span></code></pre><ul><li><strong>注意</strong>：列表项内部可以使用段落、换行符、图片、连接以及其他列表等</li></ul><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><h3 id="表格的绘制"><a href="#表格的绘制" class="headerlink" title="表格的绘制"></a>表格的绘制</h3><ul><li><p>表格制作需要用到的标签</p><ol><li><code>table</code>：表格开始和结尾</li><li><code>tr</code>：行开始和结尾</li><li><code>td</code>：单元格开始和结尾</li><li><code>border</code>：是否显示表格边框</li><li><code>width</code>：表格或单元格的宽度</li></ol></li></ul><p><img src="/2.png" alt="table、tr、td三个标签所描述的对象的示意图"></p><ul><li>作用：用于表格、行、列、宽度、边框的制作</li></ul><h3 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h3><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!--合并列--></span>colspan<span class="token comment" spellcheck="true">&lt;!--合并行--></span>rowspan</code></pre><ul><li>作用：用于将表格内的某些行、列进行合并。</li><li>实例代码：利用单元格制作一张课程表</li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>这里是页面的标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>50%<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>星期<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>一<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>二<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>三<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>四<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>五<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>第一节<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>数学<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>英语<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>物理<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">colspan</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token attr-name">rowspan</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>化学<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>第二节<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>政治<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>体育<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">rowspan</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>音乐<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>第三节<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">rowspan</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>语文<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>地理<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>劳技<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>数学<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>第四节<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>数学<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>物理<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>化学<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>英语<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span>  <span class="token attr-name">colspan</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>6<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>午休<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>第五节<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>数学<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>物理<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>物理<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>音乐<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">rowspan</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>体育<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>第六节<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>体育<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>体育<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>体育<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>体育<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h3 id="表格的其他属性"><a href="#表格的其他属性" class="headerlink" title="表格的其他属性"></a>表格的其他属性</h3><ul><li>其他一些会用到的表格标签示意图如下图所示。</li></ul><p><img src="/3.png" alt="表格的其他属性标签示意图"></p><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!--action传入后台的位置，method传入后台信息的方式--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span></code></pre><ul><li>作用：用于收集用户信息，进行人机交互操作</li><li>包含元素：文本框、单选按钮、列表框、图片框、复选框等这些元素，统称为“控件”</li><li>控件的常用属性如下图所示</li></ul><p><img src="/4.png" alt="控件的常用属性示意图"></p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> 知识总结 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射机制特点的总结</title>
      <link href="/2020/10/24/java-de-fan-she-ji-zhi/"/>
      <url>/2020/10/24/java-de-fan-she-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="反射的概述"><a href="#反射的概述" class="headerlink" title="反射的概述"></a>反射的概述</h2><h3 id="什么是Java反射机制"><a href="#什么是Java反射机制" class="headerlink" title="什么是Java反射机制"></a>什么是Java反射机制</h3><ul><li>Java反射机制是在<strong>运行状态</strong>中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。</li></ul><p><img src="/1.png" alt="Java反射机制示意图"></p><h3 id="Java反射机制的作用"><a href="#Java反射机制的作用" class="headerlink" title="Java反射机制的作用"></a>Java反射机制的作用</h3><ul><li>是用来编写一些通用性较高的代码或者框架的时候使用。</li></ul><h2 id="反射的API"><a href="#反射的API" class="headerlink" title="反射的API"></a>反射的API</h2><h3 id="反射常用对象的概述"><a href="#反射常用对象的概述" class="headerlink" title="反射常用对象的概述"></a>反射常用对象的概述</h3><ul><li><p>Class</p><ul><li>Class类的实例表示正在运行的Java应用程序中的类和接口。</li></ul></li><li><p>Constructor</p><ul><li>关于类的单个构造方法的信息以及对它的访问权限。</li></ul></li><li><p>Field</p><ul><li>Field提供了有关类或者接口的单个字段的信息，以及对它的动态访问的权限。</li></ul></li><li><p>Method</p><ul><li>Method提供了关于类或者接口上单独某个方法的信息。</li></ul></li></ul><p><img src="/2.png" alt="Java反射常用对象介绍图解"></p><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><ul><li>Java中java.lang.Class类用于表示一个类的字节码(.class)文件</li><li>如何得到某个class文件对应的Class对象</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//已知类和对象的情况下</span>类名<span class="token punctuation">.</span><span class="token keyword">class</span>对象<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//Object类提供</span><span class="token comment" spellcheck="true">//未知类和对象的情况下</span>Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"包名.类名"</span><span class="token punctuation">)</span></code></pre><ul><li>Class类代表了某个类的字节码，并提供了加载字节码的方法：forName(“包名.类名”)，forName方法用于加载类字节码到内存中，并封装成一个Class对象。如下代码是常用的一种反射示例代码。</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1. 通过类名.class</span>Class <span class="token class-name">class1</span> <span class="token operator">=</span> Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2. 通过对象.getClass()的方式</span>Person person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Class <span class="token class-name">class2</span> <span class="token operator">=</span> person<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//3. Class.forName() 这是更常用的方式</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"io.github.zbw0520.reflect.test.Person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="Constructor类"><a href="#Constructor类" class="headerlink" title="Constructor类"></a>Constructor类</h3><ul><li><p>Constructor类的实例对象代表类的一个构造方法</p></li><li><p>得到某个类所有的构造方法</p><pre class=" language-java"><code class="language-java">Constructor<span class="token punctuation">[</span><span class="token punctuation">]</span> constructors <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.lang.String"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getConstructors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>得到指定的构造方法并调用</p></li></ul><pre class=" language-java"><code class="language-java">Constructor Constructor <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.lang.String"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String str <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>Constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>Class类的newInstance()方法用来调用类的默认构造方法</li></ul><pre class=" language-java"><code class="language-java">String obj <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.lang.String"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>下面为Constructor类使用的具体实例代码</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token comment" spellcheck="true">/*** 获得无参数构造方法*/</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">demo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    Class <span class="token class-name">class1</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"io.github.zbw0520.reflect.test.Person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Constructor c <span class="token operator">=</span> class1<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Person person <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span>c<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//相当于Person person = new Person();</span>    person<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Test</span><span class="token comment" spellcheck="true">/*** 获得有参数的构造方法*/</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">demo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    Class <span class="token class-name">class1</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"io.github.zbw0520.reflect.test.Person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Constructor c <span class="token operator">=</span> class1<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Person person <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span>c<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">,</span><span class="token string">"男"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"  "</span><span class="token operator">+</span>person<span class="token punctuation">.</span><span class="token function">getGender</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="Field类"><a href="#Field类" class="headerlink" title="Field类"></a>Field类</h3><ul><li><p>Field类代表了某个类中的一个成员变量，并提供动态的访问权限</p></li><li><p>Field对象的获得</p><ul><li><p>得到所有的成员变量</p><pre class=" language-java"><code class="language-java">Field<span class="token punctuation">[</span><span class="token punctuation">]</span> fields <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取所有public属性（包括父类继承）</span>Field<span class="token punctuation">[</span><span class="token punctuation">]</span> fields <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//取得所有申明的属性</span></code></pre></li><li><p>得到指定的成员变量</p><pre class=" language-java"><code class="language-java">Field name <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getField</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//传入属性名称</span>Field name <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//经常使用这个函数，无论是私有还是公有都可以通过这个函数访问</span></code></pre></li></ul></li><li><p>设置Field变量是否可以访问</p><pre class=" language-java"><code class="language-java">field<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token keyword">boolean</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//设置私有属性的访问权限是否为真</span></code></pre></li><li><p>Field变量值的读取</p><pre class=" language-java"><code class="language-java">field<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//读取数据</span>field<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//设置数据</span></code></pre></li><li><p>Field类使用代码示例</p></li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token comment" spellcheck="true">/**    * 测试公有属性    */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">demo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//获得Class</span>    Class <span class="token class-name">class1</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"io.github.zbw0520.reflect.test.Person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获得属性</span>    Field name <span class="token operator">=</span> class1<span class="token punctuation">.</span><span class="token function">getField</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//操作属性</span>    Person p <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span>class1<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    name<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span><span class="token string">"小王"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Test</span><span class="token comment" spellcheck="true">/**    * 测试私有属性    */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">demo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//获得Class</span>    Class <span class="token class-name">class1</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"io.github.zbw0520.reflect.test.Person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获得私有属性</span>    Field f <span class="token operator">=</span> class1<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"gender"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//操作属性</span>    Person p <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span>class1<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//私有属性需要设置可访问权限</span>    f<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    f<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span><span class="token string">"女"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="Method类"><a href="#Method类" class="headerlink" title="Method类"></a>Method类</h3><ul><li><p>Method类代表某个类中的一个成员方法</p></li><li><p>Method对象的获得</p><ul><li><p>获得所有方法</p><pre class=" language-java"><code class="language-java"><span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span>getMethods</code></pre></li><li><p>获得指定的方法</p><pre class=" language-java"><code class="language-java"><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>parameterTypes<span class="token punctuation">)</span><span class="token function">getMethod</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>parameterTypes<span class="token punctuation">)</span></code></pre></li></ul></li><li><p>通过反射执行方法</p></li></ul><pre class=" language-java"><code class="language-java"><span class="token function">invoke</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span></code></pre><ul><li>Method类使用代码示例</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token comment" spellcheck="true">/**    * 测试公有方法    */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">demo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    Class <span class="token class-name">class1</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"io.github.zbw0520.reflect.test.Person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//实例化</span>    Person p <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span>class1<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获得公有方法</span>    Method mt <span class="token operator">=</span> class1<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"eat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//执行该方法</span>    mt<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Test</span><span class="token comment" spellcheck="true">/**    * 测试私有方法    */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">demo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    Class <span class="token class-name">class1</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"io.github.zbw0520.reflect.test.Person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//实例化</span>    Person p <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span>class1<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获得私有方法</span>    Method mt <span class="token operator">=</span> class1<span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"run"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//指定可访问性为真</span>    mt<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//执行方法</span>    mt<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Test</span><span class="token comment" spellcheck="true">/**    * 测试带参私有方法    */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">demo3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    Class <span class="token class-name">class1</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"io.github.zbw0520.reflect.test.Person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//实例化</span>    Person p <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span>class1<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获得私有方法</span>    Method mt <span class="token operator">=</span> class1<span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"greet"</span><span class="token punctuation">,</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//指定可访问性为真</span>    mt<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//执行方法</span>    mt<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span><span class="token string">"小明"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
            <tag> Java </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC特点的总结</title>
      <link href="/2020/10/23/jdbc/"/>
      <url>/2020/10/23/jdbc/</url>
      
        <content type="html"><![CDATA[<h2 id="JDBC概述"><a href="#JDBC概述" class="headerlink" title="JDBC概述"></a>JDBC概述</h2><ul><li>JDBC的全称为：Java DataBase Connectivity(Java数据库连接)；</li><li>早期没有JDBC的时候与各种数据库进行交互的模式；</li><li>现在有了JDBC之后与各种数据库进行交互的模式，Java程序员就不需要了解每一个数据库的工作模式，只需要了解JDBC接口的使用方法就可以了。</li></ul><p><img src="/1.png" alt="早期没有JDBC的时候与各种数据库进行交互的模式"><br><img src="/2.png" alt="现在有了JDBC之后与各种数据库进行交互的新模式"></p><h2 id="JDBC入门"><a href="#JDBC入门" class="headerlink" title="JDBC入门"></a>JDBC入门</h2><ul><li>搭建开发环境；</li><li>编写程序，在程序中加载数据库驱动；</li><li>建立连接；</li><li>创建用于向数据库发送SQL的Statement对象；</li><li>从代表结果集的ResultSet中取出数据；</li><li>断开与数据库的连接，并释放相关资源。</li></ul><h2 id="JDBC的API详解"><a href="#JDBC的API详解" class="headerlink" title="JDBC的API详解"></a>JDBC的API详解</h2><h3 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h3><ul><li><p>驱动管理类;</p></li><li><p>主要作用:</p><ol><li><p>注册驱动</p><pre class=" language-java"><code class="language-java">DriverManager<span class="token punctuation">.</span><span class="token function">registerDriver</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Driver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//会导致驱动注册两次</span><span class="token comment" spellcheck="true">//在源代码中已经有静态代码块注册一次驱动了</span><span class="token comment" spellcheck="true">//实际注册驱动方式，这是实际开发使用的代码，</span><span class="token comment" spellcheck="true">//这个代码的意思是加载一个叫com.mysql.jdbc.Driver的类，</span><span class="token comment" spellcheck="true">//在加载类之后，静态代码块就被执行一次了</span>Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>获得连接</p><pre class=" language-java"><code class="language-java">Connection conn <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>String url<span class="token punctuation">,</span>String username<span class="token punctuation">,</span>String password<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//url写法: jdbc:mysql://localhost:3306/jdbc?serverTimezone=GMT</span>    <span class="token comment" spellcheck="true">//jdbc: 协议</span>    <span class="token comment" spellcheck="true">//mysql: jdbc的子协议</span>    <span class="token comment" spellcheck="true">//localhost: 主机名</span>    <span class="token comment" spellcheck="true">//3306: 端口号</span>    <span class="token comment" spellcheck="true">//jdbc: 数据库名</span>    <span class="token comment" spellcheck="true">//serverTimezone=GMT: 时区设置</span><span class="token comment" spellcheck="true">//如果连接的是本机的数据库，url简写: jdbc:mysql:///jdbc?serverTimezone=GMT</span></code></pre></li></ol></li></ul><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><ul><li><p>连接对象;</p></li><li><p>主要作用:</p><ol><li><p>创建执行SQL语句的对象</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//下面三个方法产生的对象都可以用来执行SQL语句</span>Statement <span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">//用来执行SQL语句，会有SQL注入的漏洞存在</span>PreparedStatment <span class="token function">prepareStatement</span><span class="token punctuation">(</span>String sql<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//预编译SQL语句，解决了SQL注入的漏洞</span>CallableStatement <span class="token function">prepareCall</span><span class="token punctuation">(</span>String sql<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//执行SQL中的存储过程</span></code></pre></li><li><p>进行事物的管理</p><pre class=" language-java"><code class="language-java"><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> autoCommit<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//设置事务是否自动提交</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                            <span class="token comment" spellcheck="true">//事务提交</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                          <span class="token comment" spellcheck="true">//事务回滚</span></code></pre></li></ol></li></ul><h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h3><ul><li><p>执行SQL;</p></li><li><p>主要作用:</p><ol><li><p>执行SQL语句</p><pre class=" language-java"><code class="language-java"><span class="token keyword">boolean</span> <span class="token function">execute</span><span class="token punctuation">(</span>String sql<span class="token punctuation">)</span>         <span class="token comment" spellcheck="true">//执行SQL</span><span class="token comment" spellcheck="true">//执行SELECT语句返回true，否则返回false</span>ResultSet <span class="token function">executeQuery</span><span class="token punctuation">(</span>String sql<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//只能执行SQL中的SELECT语句</span><span class="token comment" spellcheck="true">//返回查询的结果</span><span class="token keyword">int</span> <span class="token function">executeUpate</span><span class="token punctuation">(</span>String sql<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//执行SQL中的insert/update/delete语句</span><span class="token comment" spellcheck="true">//返回一个影响的行数</span></code></pre></li><li><p>执行批处理操作</p><pre class=" language-java"><code class="language-java"><span class="token function">addBatch</span><span class="token punctuation">(</span>String sql<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//将操作添加到批处理中</span><span class="token function">executeBatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">//执行批处理</span><span class="token function">clearBatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//清空批处理</span></code></pre></li></ol></li></ul><h3 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h3><ul><li><p>结果集：查询(SELECT)语句所查询到的结果的封装;</p></li><li><p>主要作用:</p><ol><li><p>结果集获取到查询的结果</p><pre class=" language-java"><code class="language-java"><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//用来判断是否有下一行记录，如果有指向下一行</span><span class="token comment" spellcheck="true">//针对不同类型的数据可以使用getXXX()的方法来获取数据</span><span class="token comment" spellcheck="true">//通用获取数据的方法</span><span class="token function">getObject</span><span class="token punctuation">(</span>String columnLabel<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//参数是传入字符串类型值，表示字段名称</span></code></pre></li></ol></li></ul><h2 id="JDBC的资源释放"><a href="#JDBC的资源释放" class="headerlink" title="JDBC的资源释放"></a>JDBC的资源释放</h2><ul><li>JDBC程序运行完之后，一定要记得释放程序在运行过程中，创建的那些与数据库进行交互的对象，这些对象通常是<code>ResultSet</code>, <code>Statement</code>和<code>Connection</code>对象</li><li><code>Connection</code>往往是有限的，如果没有释放掉<code>Connection</code>，那么被人有可能无法连接到数据库。<code>Connection</code>对象是非常稀有的资源，用完之后必须马上释放，如果<code>Connection</code>不能及时、正确地关闭，极易导致系统宕机。<code>Connection</code>使用的原则是尽量晚创建，尽量早释放。</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//一种比较好的释放资源的办法，需要将这一段放在finally代码块中</span><span class="token keyword">if</span><span class="token punctuation">(</span>stmt <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        stmt<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> throwables<span class="token punctuation">)</span> <span class="token punctuation">{</span>        throwables<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    stmt <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这么写可以让垃圾回收机制更早地回收con对象</span><span class="token punctuation">}</span></code></pre><h2 id="JDBC的CRUD操作"><a href="#JDBC的CRUD操作" class="headerlink" title="JDBC的CRUD操作"></a>JDBC的CRUD操作</h2><h3 id="向数据库中保存记录"><a href="#向数据库中保存记录" class="headerlink" title="向数据库中保存记录"></a>向数据库中保存记录</h3><pre class=" language-java"><code class="language-java">Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.cj.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//注册驱动</span>conn <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql:///jdbctest?serverTimezone=GMT"</span><span class="token punctuation">,</span><span class="token string">"root"</span><span class="token punctuation">,</span><span class="token string">"vbe200"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">/</span><span class="token operator">/</span>创建连接stmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//创建Statement</span>String sql <span class="token operator">=</span> <span class="token string">"insert into user values (null,'zhbw','123','张三')"</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//保存记录</span><span class="token keyword">int</span> i <span class="token operator">=</span> stmt<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//执行保存操作</span><span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"保存成功！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//获取结果</span><span class="token punctuation">}</span></code></pre><h3 id="修改数据库中的记录"><a href="#修改数据库中的记录" class="headerlink" title="修改数据库中的记录"></a>修改数据库中的记录</h3><pre class=" language-java"><code class="language-java">Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.cj.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>conn <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql:///jdbctest?serverTimezone=GMT"</span><span class="token punctuation">,</span> <span class="token string">"root"</span><span class="token punctuation">,</span> <span class="token string">"vbe200"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String sql <span class="token operator">=</span> <span class="token string">"update user set username = 'qqq',password='456',name='赵六' where uid=4"</span><span class="token punctuation">;</span><span class="token keyword">int</span> i <span class="token operator">=</span> stmt<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"修改成功！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="删除数据库中的记录"><a href="#删除数据库中的记录" class="headerlink" title="删除数据库中的记录"></a>删除数据库中的记录</h3><pre class=" language-java"><code class="language-java">Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.cj.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>conn <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql:///jdbctest?serverTimezone=GMT"</span><span class="token punctuation">,</span> <span class="token string">"root"</span><span class="token punctuation">,</span> <span class="token string">"vbe200"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String sql <span class="token operator">=</span> <span class="token string">"delete from user where uid=4"</span><span class="token punctuation">;</span><span class="token keyword">int</span> i <span class="token operator">=</span> stmt<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"删除成功！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="查询数据库中的记录"><a href="#查询数据库中的记录" class="headerlink" title="查询数据库中的记录"></a>查询数据库中的记录</h3><ol><li><p>查询所有记录</p><pre class=" language-java"><code class="language-java">Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.cj.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>conn <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql:///jdbctest?serverTimezone=GMT"</span><span class="token punctuation">,</span><span class="token string">"root"</span><span class="token punctuation">,</span><span class="token string">"vbe200"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String sql <span class="token operator">=</span> <span class="token string">"select * from user"</span><span class="token punctuation">;</span>rs <span class="token operator">=</span> stmt<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> uid <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"uid"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String username <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String password <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String name<span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>uid<span class="token operator">+</span><span class="token string">"  "</span><span class="token operator">+</span>username<span class="token operator">+</span><span class="token string">"  "</span><span class="token operator">+</span>password<span class="token operator">+</span><span class="token string">"  "</span><span class="token operator">+</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>查询某一条特定的记录</p><pre class=" language-java"><code class="language-java">Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.cj.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>conn <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql:///jdbctest?serverTimezone=GMT"</span><span class="token punctuation">,</span> <span class="token string">"root"</span><span class="token punctuation">,</span> <span class="token string">"vbe200"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String sql <span class="token operator">=</span> <span class="token string">"select * from user where uid=2"</span><span class="token punctuation">;</span>rs <span class="token operator">=</span> stmt<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> uid <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"uid"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String username <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String password <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String name <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>uid <span class="token operator">+</span> <span class="token string">"  "</span> <span class="token operator">+</span> username <span class="token operator">+</span> <span class="token string">"  "</span> <span class="token operator">+</span> password <span class="token operator">+</span> <span class="token string">"  "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h2 id="JDBC工具类的抽取"><a href="#JDBC工具类的抽取" class="headerlink" title="JDBC工具类的抽取"></a>JDBC工具类的抽取</h2><ul><li>由于很多代码都是重复的，所以为了简化JDBC开发，将一些重复的代码进行提取，创建一个工具类。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> io<span class="token punctuation">.</span>github<span class="token punctuation">.</span>zbw0520<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>utils<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * JDBC的工具类 * * @author zhbw */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JDBCUtils</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//静态常量</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String driverClass<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String url<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String username<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String password<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//静态代码块</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        driverClass <span class="token operator">=</span> <span class="token string">"com.mysql.cj.jdbc.Driver"</span><span class="token punctuation">;</span>        url <span class="token operator">=</span> <span class="token string">"jdbc:mysql:///jdbctest?serverTimezone=GMT"</span><span class="token punctuation">;</span>        username <span class="token operator">=</span> <span class="token string">"root"</span><span class="token punctuation">;</span>        password <span class="token operator">=</span> <span class="token string">"vbe200"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 注册驱动的方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">loadDriver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>        Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>driverClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 获得连接的方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Connection <span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token function">loadDriver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span>username<span class="token punctuation">,</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 资源的释放     * 做增删改的方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span>Statement stmt<span class="token punctuation">,</span>Connection conn<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>stmt <span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                stmt<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> throwables<span class="token punctuation">)</span> <span class="token punctuation">{</span>                throwables<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            stmt <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>conn <span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> throwables<span class="token punctuation">)</span> <span class="token punctuation">{</span>                throwables<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            conn <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 资源的释放     * 做查询操作的方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span>Statement stmt<span class="token punctuation">,</span> Connection conn<span class="token punctuation">,</span> ResultSet rs<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>stmt <span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                stmt<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> throwables<span class="token punctuation">)</span> <span class="token punctuation">{</span>                throwables<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            stmt <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>conn <span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> throwables<span class="token punctuation">)</span> <span class="token punctuation">{</span>                throwables<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            conn <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>rs <span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                rs<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> throwables<span class="token punctuation">)</span> <span class="token punctuation">{</span>                throwables<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            rs <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>使用工具类的保存记录的实例代码</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Statement stmt <span class="token operator">=</span> null<span class="token punctuation">;</span>    Connection connection <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        connection <span class="token operator">=</span> JDBCUtils<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stmt <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String sql <span class="token operator">=</span> <span class="token string">"insert into user value(null,'qwq','123456','老王')"</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> stmt<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"保存成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>        JDBCUtils<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span>stmt<span class="token punctuation">,</span>connection<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li><strong>注意</strong>，在之前的工具类文件中，我们将参数保存在源代码中，每一次需要修改参数的时候都需要修改源代码，这是不合理的，我们应该将参数放在源代码之外的一个文件中。我们选择将参数放在<code>jdbc.properties</code>这样一个属性文件中，文件中的键值对语法如下。</li></ul><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">driverClass</span> <span class="token punctuation">=</span> <span class="token attr-value">com.mysql.cj.jdbc.Driver</span><span class="token attr-name">url</span> <span class="token punctuation">=</span> <span class="token attr-value">jdbc:mysql:///jdbctest?serverTimezone=GMT</span><span class="token attr-name">username</span> <span class="token punctuation">=</span> <span class="token attr-value">root</span><span class="token attr-name">password</span> <span class="token punctuation">=</span> <span class="token attr-value">vbe200</span></code></pre><ul><li>这时候需要修改工具类源代码来实现读取属性文件中的参数值，我们可以使用如下代码实现这一操作。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//加载属性文件并解析</span>    Properties prop <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如何获得属性文件的输入流？</span>    <span class="token comment" spellcheck="true">//通常情况下采用类的加载器的方式进行获取:</span>    <span class="token comment" spellcheck="true">//通常不采用FileInputStream("src/jbdc.properties")，因为web应用没法适配</span>    InputStream in <span class="token operator">=</span> JDBCUtils<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"jdbc.properties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        prop<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    driverClass <span class="token operator">=</span> prop<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"driverClass"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    url <span class="token operator">=</span> prop<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"url"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    username <span class="token operator">=</span> prop<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    password <span class="token operator">=</span> prop<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="JDBC的SQL注入漏洞"><a href="#JDBC的SQL注入漏洞" class="headerlink" title="JDBC的SQL注入漏洞"></a>JDBC的SQL注入漏洞</h2><ul><li><p>只需要知道用户名，不需要知道密码就可以对数据库进行修改，这成为SQL注入漏洞。</p></li><li><p>产生原因：在输入用户名的时候输入了SQL的关键字，使其不能正常解析用户名和密码。</p></li><li><p>解决方案：不能使用Statement对象，必须要使用PreparedStatement类的对象，这种对象会把可以通过调用Connection.PreparedStatment(sql)的方法获得，相对于Statement对象而言：</p><ol><li><p>PreparedStatment可以避免SQL注入问题；</p></li><li><p>Statement会使数据库频繁编译SQL，可能造成数据库缓冲区溢出。PreparedStatement可以对SQL进行预编译，从而提高数据库的执行效率；</p></li><li><p>并且PreparedStatement对于SQL中的参数，允许使用占位符(<code>?</code>)的形式进行替换，简化SQL语句的编写。如下代码是一个使用PreparedStatement类对象的示例代码，下面这个代码块就可以解决漏洞问题。</p><pre class=" language-java"><code class="language-java">String username <span class="token operator">=</span> <span class="token string">"zhbw"</span><span class="token punctuation">;</span>String password <span class="token operator">=</span> <span class="token string">"vbe200"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//编写SQL:</span>String sql <span class="token operator">=</span> <span class="token string">"select * from user where username = ? and password = ?"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//预处理SQL:</span>pstmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置参数:</span>pstmt<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span>pstmt<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">.</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行SQL语句，因为已经进行预处理了，所以在这里就不需要传入语句参数了</span>pstmt<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol></li></ul><h2 id="JDBC中的PreparedStatement"><a href="#JDBC中的PreparedStatement" class="headerlink" title="JDBC中的PreparedStatement"></a>JDBC中的PreparedStatement</h2><h2 id="数据库连接池C3P0"><a href="#数据库连接池C3P0" class="headerlink" title="数据库连接池C3P0"></a>数据库连接池C3P0</h2><ul><li>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库。C3P0是常用的开源连接池</li></ul><h3 id="手动设置连接池"><a href="#手动设置连接池" class="headerlink" title="手动设置连接池"></a>手动设置连接池</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//连接池需要引入两个jar包：</span><span class="token comment" spellcheck="true">//c3p0-0.9.5.5.jar、mchange-commons-java-0.2.12.jar</span><span class="token comment" spellcheck="true">//创建连接池：</span>ComboPooledDataSource dataSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置连接池相关参数：</span>dataSource<span class="token punctuation">.</span><span class="token function">setDriverClass</span><span class="token punctuation">(</span><span class="token string">"com.mysql.cj.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dataSource<span class="token punctuation">.</span><span class="token function">setJdbcUrl</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql:///jdbctest?serverTimezone=GMT"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dataSource<span class="token punctuation">.</span><span class="token function">setUser</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dataSource<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"vbe200"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dataSource<span class="token punctuation">.</span><span class="token function">setMaxPoolSize</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dataSource<span class="token punctuation">.</span><span class="token function">setInitialPoolSize</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获得连接：</span>conn <span class="token operator">=</span> dataSource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//编写SQL：</span>String sql <span class="token operator">=</span> <span class="token string">"select * from user"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//预编译SQL</span>pstmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>rs <span class="token operator">=</span> pstmt<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="使用文件设置连接池"><a href="#使用文件设置连接池" class="headerlink" title="使用文件设置连接池"></a>使用文件设置连接池</h3><ul><li>可以使用XML文件来设置连接池，进一步简化代码的复杂程度。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
            <tag> JDBC </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 连接池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库特点的总结</title>
      <link href="/2020/10/21/mysql-shu-ju-ku/"/>
      <url>/2020/10/21/mysql-shu-ju-ku/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是数据库"><a href="#什么是数据库" class="headerlink" title="什么是数据库"></a>什么是数据库</h2><ul><li><p>数据库（Database）是按照数据结构来组织、储存和管理数据的仓库。</p></li><li><p>常见数据库</p><ul><li>Oracle</li><li>DB2</li><li>SQL Server</li><li>Postgre SQL</li><li>MySQL</li></ul></li></ul><h2 id="数据库相关术语"><a href="#数据库相关术语" class="headerlink" title="数据库相关术语"></a>数据库相关术语</h2><ul><li><p>数据库系统（Database System）DBS</p><ul><li>数据库(Database)</li><li>数据库管理系统(Database Management System)DBMS</li><li>应用开发工具</li><li>管理员及工具</li></ul></li><li><p>SQL语言：结构化查询语言</p><ul><li>DDL：数据定义语言（创建数据结构）</li><li>DML：数据操作语言（增删改数据）</li><li>DQL：数据查询语言（查数据）</li><li>DCL：数据控制语言（控制用户访问权限）</li></ul></li></ul><h2 id="MySQL相关操作"><a href="#MySQL相关操作" class="headerlink" title="MySQL相关操作"></a>MySQL相关操作</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ul><li>my.cnf是配置文件，在Windows上时my.ini</li></ul><h3 id="登录-x2F-退出MySQL"><a href="#登录-x2F-退出MySQL" class="headerlink" title="登录/退出MySQL"></a>登录/退出MySQL</h3><ul><li>登录方法</li></ul><pre class=" language-bash"><code class="language-bash">mysql -uroot -pmysql -uroot -p<span class="token punctuation">[</span>密码<span class="token punctuation">]</span></code></pre><ul><li>退出</li></ul><pre class=" language-mysql"><code class="language-mysql">exitquit</code></pre><ul><li>查看版本</li></ul><pre class=" language-bash"><code class="language-bash">mysql -uroot -p --version</code></pre><ul><li>登录的同时打开指定数据库</li></ul><pre class=" language-bash"><code class="language-bash">mysql -uroot -p -D <span class="token punctuation">[</span>数据库名称<span class="token punctuation">]</span></code></pre><ul><li><p>登录信息中需要掌握的内容</p><ul><li>命令行结束符默认使用<code>;</code>或<code>\g</code>来结束；</li><li><code>help [关键字]</code>来查询帮助；</li><li><code>\c</code>可以取消当前命令的执行。</li></ul></li></ul><h3 id="常用SQL语句"><a href="#常用SQL语句" class="headerlink" title="常用SQL语句"></a>常用SQL语句</h3><pre class=" language-mysql"><code class="language-mysql">SELECT USER()       #得到登陆的用户SELECT VERSION()    #得到MySQL的版本信息SELECT NOW()        #得到当前的日期时间SELECT DATABASE()   #得到当前打开的数据库</code></pre><h3 id="SQL语句语法规范"><a href="#SQL语句语法规范" class="headerlink" title="SQL语句语法规范"></a>SQL语句语法规范</h3><ul><li>常用MySQL的关键字需要大写，库名、表名、字段名称等使用小写</li><li>SQL支持折行操作，拆分的时候不能把完整的单词拆开</li><li>数据库名称、表名称、字段名称不要使用MySQL的保留字，如果必须使用，需要使用反引号将其括起来</li></ul><h2 id="数据库相关操作"><a href="#数据库相关操作" class="headerlink" title="数据库相关操作"></a>数据库相关操作</h2><pre class=" language-mysql"><code class="language-mysql">CREATE (DATABASE|SCHEMA) db_name; #注意，数据库名称最好有意义，名称不要包含特殊字符或者MySQL关键字。SHOW (DATABASES|SCHEMAS);CREATE DATABASE [IF NOT EXISTS] db_name;SHOW WARNINGS; #查看警告CREATE DATABASE [IF NOT EXISTS] db_name DEFAULT CHARACTER SET [=] charset; #创建数据库的时候指定编码方式ALTER DATABASE db_name DEFAULT CHARACTER SET [=] charset; #修改指定数据库的编码方式。USE db_name; #打开指定数据库SELECT (DATABASE|SCHEMA); #得到当前打开的数据库DROP DATABASE db_name; #删除数据库DROP DATABASE [IF EXISTS] db_name; #如果数据库存在则删除</code></pre><h2 id="数据表相关操作"><a href="#数据表相关操作" class="headerlink" title="数据表相关操作"></a>数据表相关操作</h2><h3 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h3><ul><li>数据表是数据库最重要的组成部分之一，数据保存在数据表中;</li><li>数据表由行(row)和列(column)来组成;</li><li>每个数据表中至少要有一列，行可以有零行或若干行;</li><li>表名要求唯一，不要包含特殊字符，最好含义明确。</li></ul><h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><pre class=" language-mysql"><code class="language-mysql">CREATE TABLE [IF NOT EXISTS] tbl_name(  字段名称 字段类型 [完整性约束条件],  字段名称 字段类型 [完整性约束条件],  ...)ENGINE=存储引擎 CHARSET=编码方式;unsigned  #无符号，没有负数，从零开始zerofill #零填充，当显示长度不够时可以使用前补0的效果填充至指定长度NOT NULL #非空约束，也就是插入值的时候这个字段必须要给值DEFAULT #默认值，如果插入记录的时候没有给字段赋值，则使用默认值PRIMARY KEY #主键，标志记录的唯一性，即值不能重复，而且一个表只能有一个主键，如果一个字段是主键，则自动禁止为空UNIQUE KEY #唯一性，表示不能重复，一个表中可以有多个字段是唯一索引，但是NULL值除外AUTO_INCREMENT #自动增长，只能用于数值列，而且配合索引FOREIGN KEY # 外键约束</code></pre><h3 id="查看当前数据库下已有的数据表"><a href="#查看当前数据库下已有的数据表" class="headerlink" title="查看当前数据库下已有的数据表"></a>查看当前数据库下已有的数据表</h3><pre class=" language-mysql"><code class="language-mysql">SHOW TABLES;SHOW [FULL] TABLES [{FROM|IN} db_name] [LIKE 'pattern'|WHERE expr];</code></pre><h3 id="查看指定数据表的详细信息"><a href="#查看指定数据表的详细信息" class="headerlink" title="查看指定数据表的详细信息"></a>查看指定数据表的详细信息</h3><pre class=" language-mysql"><code class="language-mysql">SHOW CREATE TABLE tbl_name;</code></pre><h3 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h3><pre class=" language-mysql"><code class="language-mysql">DESC tbl_name;DESCRIBE tbl_name;SHOW COLUMNS FROM tbl_name;</code></pre><h3 id="删除指定的数据表"><a href="#删除指定的数据表" class="headerlink" title="删除指定的数据表"></a>删除指定的数据表</h3><pre class=" language-mysql"><code class="language-mysql">DROP TABLE [IF EXISTS] tbl_name;</code></pre><h3 id="表结构相关操作"><a href="#表结构相关操作" class="headerlink" title="表结构相关操作"></a>表结构相关操作</h3><pre class=" language-mysql"><code class="language-mysql">ALTER TABLE tbl_name ADD 字段名称 字段属性 [完整性约束条件] [FIRST|AFTER 字段名称] --添加字段ALTER TABLE tbl_name DROP 字段名称 --删除字段-- 一条语句完成多项操作ALTER TABLE user1ADD age TINYINT UNSIGNED NOT NULL DEFAULT 18,ADD addr VARCHAR(100) NOT NULL DEFAULT 'Beijing'-- 添加默认值ALTER TABLE tble_nameALTER 字段名称 SET DEFAULT 默认值-- 删除默认值ALTER TABLE tble_nameALTER 字段名称 DROP DEFAULT-- 添加主键ALTER TABLE tble_nameADD PRIMARY KEY(字段名称)-- 删除主键ALTER TABLE tbl_nameDROP PRIMARY KEY;-- 添加唯一ALTER TABLE tbl_nameADD UNIQUE KEY|INDEX index_name (字段名称)-- 删除唯一ALTER TABLE tble_nameDROP INDEX index_name;-- 修改字段类型、字段属性ALTER TABLE tbl_nameMODIFY 字段名称 字段类型 [字段属性] [FIRST|AFTER 字段名称]-- 修改字段名称、字段类型、字段属性ALTER TABLE tbl_nameCHANGE 原字段名称 新字段名称 字段类型 字段属性[FIRST|AFTER 字段名称]-- 修改数据表名称(两种方法)ALTER TABLE tbl_name RENAME [TO|AS] new tbl_name;RENAME TABLE tbl_name TO new_tbl_name;</code></pre><h2 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h2><h3 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h3><ul><li>整数型</li><li>浮点数</li><li>定点数</li></ul><p><img src="/int.png" alt="整数型数据类型信息示意图"></p><p><img src="/float.png" alt="浮点数和定点数数据类型信息示意图"></p><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><ul><li>CHAR效率高于VARCHAR, CHAR相当于拿空间换时间, VARCHAR拿时间换空间；</li><li>CHAR默认存储数据的时候，后面会用空格填充到指定长度；而在检索的时候会去掉后面的空格；VARCHAR在保存的时候不进行填充，尾部的空格会留下；</li><li>TEXT列不能有默认值，检索的时候不存在大小写转换。</li></ul><p><img src="/char.png" alt="字符串数据类型信息示意图"></p><h3 id="日期时间类型"><a href="#日期时间类型" class="headerlink" title="日期时间类型"></a>日期时间类型</h3><p><img src="/date.png" alt="日期时间数据类型信息示意图"></p><h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><h3 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h3><ul><li><p>在MySQL5.5之前一直使用的默认存储引擎是MyISAM存储引擎；</p></li><li><p>会在磁盘中产生三个文件：</p><ul><li>.frm，表结构文件</li><li>.MYD，数据文件</li><li>.MYI，索引文件</li></ul></li><li><p>可以在建表的时候指定数据文件和索引文件的存储位置，只有MyISAM表支持：</p><ul><li>DATA DIRECTORY [=] 数据保存的绝对路径</li><li>INDEX DIRECTORY [=] 索引文件保存的绝对路径</li></ul></li><li><p>MyISAM最大支持的数据量：2的64次方条记录；</p></li><li><p>每个表最多可以建立64个索引</p></li><li><p>如果是复合索引，每个复合索引最多包含16个列，索引值最大是1000B</p></li><li><p>MyISAM引擎的存储格式</p><ul><li><p>定长(FIXED 静态)</p><ul><li>是指字段中不包含像VARCHAR/TEXT/BLOB</li><li>静态表的查询速度很快</li></ul></li><li><p>动态(DYNAMIC)</p><ul><li>字段中包含了VARCHAR/TEXT/BLOB</li></ul></li><li><p>压缩(COMPRESSED)</p><ul><li>通过myisampack创建</li></ul></li></ul></li></ul><h3 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h3><ul><li><p>设计遵循ACID模型，支持事务，具有从服务崩溃中恢复的能力，能够最大限度地保护用户的数据；</p><ul><li>原子性(Atomicity)</li><li>一致性(Consistency)</li><li>隔离性(Isolation)</li><li>持久性(Durability)</li></ul></li><li><p>支持行级锁，好处是可以提升用户高并发时的读写性能；</p></li><li><p>支持外键，保证数据的一致性和完整性；</p></li><li><p>InnoDB有自己的独立缓冲池，常用的数据和索引都在缓存中；</p></li><li><p>对于INSERT、UPDATE、DELETE操作，InnoDB会使用一种change buffering的机制来自动优化，还可以提供一致性的读，并且还能够缓存变更的数据，减少磁盘I/O，提高性能；</p></li><li><p>创建InnoDB表之后产生两个文件：</p><ul><li>.frm，表结构文件</li><li>.ibd，数据和索引存储在表空间中</li></ul></li><li><p>使用InnoDB的表时，都需要创建主键，最好是配合上AUTO_INCREMENT，也可以把经常查询的列作为主键。</p></li></ul><h2 id="MySQL数据操作"><a href="#MySQL数据操作" class="headerlink" title="MySQL数据操作"></a>MySQL数据操作</h2><h3 id="添加记录"><a href="#添加记录" class="headerlink" title="添加记录"></a>添加记录</h3><pre class=" language-mysql"><code class="language-mysql">INSERT [INTO] tbl_name[(col_name,...)] {VALUE|VALUES}-- [(col_name,...)] 表示字段-- 不指定字段名称INSERT tbl_name VALUE(value...)-- 列出指定字段INSERT tbl_name(字段名称,...) VALUES(值,...)-- 一次添加多条记录INSERT  tbl_name[(字段名称,...)] VALUES(值,...),(值,...);INSERT tbl_name SET 字段名称=值,...;INSERT tbl_name[(字段名称...)] SELECT 字段名称,... FROM tbl_name [WHERE];</code></pre><h3 id="修改记录"><a href="#修改记录" class="headerlink" title="修改记录"></a>修改记录</h3><pre class=" language-mysql"><code class="language-mysql">UPDATE tbl_name SET 字段名称=值，字段名称=值 [WHERE 条件]--如果不加条件，整个表中的记录都会被更新</code></pre><h3 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h3><pre class=" language-mysql"><code class="language-mysql">DELETE FROM tbl_name [WHERE 条件]-- 如果不添加条件，表中所有记录都会被删除-- DELETE清空数据表的时候不会重置AUTO_INCREMENT的值，可以通过ALTER语句将其重置-- 重置AUTO_INCREMENT值的方法ALTER TABLE tbl_name AUTO_INCREMENT=1;-- 一步解决上述两个问题TRUNCATE [TABLE] tbl_name;-- 清空表中所有记录-- 会重置AUTO_INCREMENT的值</code></pre><h3 id="查询记录"><a href="#查询记录" class="headerlink" title="查询记录"></a>查询记录</h3><pre class=" language-mysql"><code class="language-mysql">SELECT select_expr,... FROM tbl_name[WHERE 条件][GROUP BY {col_name|position} HAVING 二次筛选][ORDER BY {col_name|position|expr}[ASC|DESC]][LIMIT 限制结果集的显示条数]-- 查询表中的所有记录，*代表所有字段SELECT * FROM tbl_name;-- 库名.表名的形式来选择字段SELECT 字段名称,... FROM db_name.tbl_name;-- 给字段起别名SELECT 字段名称 [AS] 别名名称,... FROM db_name.tbl_name;-- 给数据表起别名SELECT 字段名称,... FROM tbl_name [AS] 别名;-- 表名.字段名称SELECT tbl_name.col_name,... FROM tbl_name;-- WHERE条件，会筛选出符合条件的记录-- 比较运算符> >= = <= != <=>-- 利用<=>来检测NULL值SELECT id,username,age,userDesc FROM user1WHERE userDesc<=>NULL;-- 检测NULL值SELECT id,username,age,userDesc FROM user1where userDesc IS [NOT] NULL;-- <=>与=的区别 <=>可以检测NULL值-- 指定范围 [NOT]BETWEEN...AND...SELECT id,username,age,sex FROM user1where age BETWEEN 18 AND 30;-- 指定集合 [NOT]IN(...)SELECT id,username,age FROM user1WHERE id IN(1,3,5,7,9);-- 逻辑运算符 AND ORSELECT id,username,age,sex FROM user1WHERE sex='男' AND age>=20;-- 模糊查询 [NOT] LIKESELECT id,username,age,sex FROM user1WHERE username LIKE 'king'-- 通配符 %任意长度的字符串 _任意一个字符SELECT id,username,age,sex FROM user1WHERE username LIKE '%三%'-- 分组操作 GROUP BY 把值相同的放到一个组中，最终查询出的结果只会显示组中一条数据SELECT id,username,age,sex FROM user1GROUP BY sex;-- 分组操作配合GROUP_CONCAT()字段查看组中成员的信息SELECT GROUP-CONCAT(username),age,sex,addr FROM user1GROUP BY sex;-- 分组操作配合聚合函数使用COUNT() #统计记录总数，如果写的是COUNT(字段名称)，字段中的值为NULL，不统计进来，写COUNT(*)全部统计SUM()   #求和MAX()   #求最大值MIN()   #求最小值AVG()   #求平均值-- 配合WITH ROLLUP关键字使用，会在记录末尾添加一条记录，是上面所有记录的综合SELECT GROUP_CONCAT(usrname) AS usersDetail,COUNT(*) AS totalUsersFROM user1GROUP BY sexWITH ROLLUP;-- HAVING子句对分组结果进行二次筛选SELECT GROUP_CONCAT(usrname) AS usersDetail,COUNT(*) AS totalUsersFROM user1GROUP BY sexHAVING COUNT(*)>=3-- ORDER BY 排序ORDER BY 字段名称 ASC|DESCSELECT id,username,ageFROM user1ORDER BY age ASC;ORDER BY RAND();    #随机显示记录-- LIMIT 限制结果集显示条数LIMIT 值  #显示结果集的前几条记录LIMIT offset, row_count  #从offset开始显示几条记录</code></pre><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>– 多表联查的上限是3个表，超过三个表的时候，查询的效率是很低的。</p><h4 id="笛卡尔积形式"><a href="#笛卡尔积形式" class="headerlink" title="笛卡尔积形式"></a>笛卡尔积形式</h4><ul><li>全部循环连接一遍</li></ul><h4 id="内连接形式"><a href="#内连接形式" class="headerlink" title="内连接形式"></a>内连接形式</h4><ul><li>查询两个表中符合连接条件的记录</li></ul><pre class=" language-mysql"><code class="language-mysql">SELECT 字段名称,... FROM tbl_name1INNER JOIN tbl_name2ON 连接条件------------SELECT emp.id,emp.username,emp.age,dep.depNameFROM empINNER JOIN depON emp.depId=dep.id</code></pre><h4 id="外连接形式"><a href="#外连接形式" class="headerlink" title="外连接形式"></a>外连接形式</h4><ul><li><p>左外连接</p><ul><li>先显示左表中的全部记录，再去右表中查询符合条件的记录，不符合的以NULL值代替</li></ul></li></ul><pre class=" language-mysql"><code class="language-mysql">SELECT 字段名称,... FROM tbl_name1OUTER LEFT JOIN tbl_name2ON 条件</code></pre><ul><li><p>右外连接</p><ul><li>先显示右表中的全部记录，再去左表中查询符合条件的记录，不符合的以NULL值代替</li></ul></li></ul><pre class=" language-mysql"><code class="language-mysql">SELECT 字段名称,... FROM tbl_name1OUTER RIGHT JOIN tbl_name2ON 条件</code></pre><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><ul><li>注意：只有InnoDB的存储引擎支持外键</li></ul><h4 id="创建外键"><a href="#创建外键" class="headerlink" title="创建外键"></a>创建外键</h4><ul><li><p>建表时指定外键</p><ul><li><p>子表的外键字段和主表的主键字段类型要相似；如果是数值型要求一致，并且无符号也要一致；如果是字符型，要求类型一致，长度也要相同；</p></li><li><p>如果外键字段没有创建索引，MySQL会自动帮我们添加索引；</p></li><li><p>子表的外键关联的必须是父表的主键。</p></li><li><p>外键约束的参照操作</p><ol><li>CASCADE 从父表删除或更新，子表也跟着删除或者更新，级联对的操作</li><li>SET NULL 从父表删除或者更新记录，并且设置子表的外键列为null才可以。</li><li>NO ACTION|RESTRICT 默认操作</li></ol></li></ul></li></ul><pre class=" language-mysql"><code class="language-mysql">[CONSTRAINT 外键名称] FOREIGN KEY(字段名称) REFERENCES 主表(字段名称)</code></pre><ul><li><p>动态添加删除外键</p><ul><li>动态添加外键时表中的数据一定要是合法的，没有脏值，否则外键没法创建成功。</li></ul></li></ul><pre class=" language-mysql"><code class="language-mysql">--添加外键ALTER TABLE tbl_name[CONSTRAINT 外键名称] ADD FOREIGN KEY(外键字段) REFERENCES 主表(主键字段)--删除外键ALTER TABLE newsDROP FOREIGN KEY cateId_fk_newsCate;</code></pre><h3 id="特殊形式的查询"><a href="#特殊形式的查询" class="headerlink" title="特殊形式的查询"></a>特殊形式的查询</h3><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><h5 id="内层语句查询的结果可以作为外层语句查询的条件"><a href="#内层语句查询的结果可以作为外层语句查询的条件" class="headerlink" title="内层语句查询的结果可以作为外层语句查询的条件"></a>内层语句查询的结果可以作为外层语句查询的条件</h5><pre class=" language-mysql"><code class="language-mysql">SELECT 字段名称 FROM tbl_name WHERE col_name=(SELECT col_name FROM tbl_name)</code></pre><h5 id="由in引发的子查询"><a href="#由in引发的子查询" class="headerlink" title="由in引发的子查询"></a>由in引发的子查询</h5><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM empWHERE depId IN (SELECT id FROM dep);</code></pre><h5 id="由比较运算符引出的子查询"><a href="#由比较运算符引出的子查询" class="headerlink" title="由比较运算符引出的子查询"></a>由比较运算符引出的子查询</h5><pre class=" language-mysql"><code class="language-mysql">SELECT id,username,score FROM studWHERE score>=(SELECT score FROM level WHERE id=1);SELECT id,username,score FROM studWHERE score<=(SELECT score FROM level WHERE id=3);</code></pre><h5 id="由EXISTS引发的子查询"><a href="#由EXISTS引发的子查询" class="headerlink" title="由EXISTS引发的子查询"></a>由EXISTS引发的子查询</h5><pre class=" language-mysql"><code class="language-mysql">--只有exists后面的语句为真才会执行前面的语句SELECT * FROM empWHERE EXISTS(SELECT depName FROM dep WHERE id=10)</code></pre><h5 id="ANY-SOME-ALL子查询"><a href="#ANY-SOME-ALL子查询" class="headerlink" title="ANY SOME ALL子查询"></a>ANY SOME ALL子查询</h5><p><img src="/1.png" alt="ANY SOME ALL子查询示意图"></p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM stuWHERE score>=ANY(SELECT score FROM level);SELECT * FROM stuWHERE score>=SOME(SELECT score FROM level);SELECT * FROM stuWHERE score>=ALL(SELECT score FROM level);</code></pre><h5 id="INSERT…SELECT子查询"><a href="#INSERT…SELECT子查询" class="headerlink" title="INSERT…SELECT子查询"></a>INSERT…SELECT子查询</h5><pre class=" language-mysql"><code class="language-mysql">INSERT user1(username)SELECT username FROM user;INSERT user2 SET username=(SELECT username FROM stu WHERE id=9)-- 去掉字段的重复值SELECT DISTINCT(username) FROM user2;</code></pre><h5 id="CREATE…SELECT子查询"><a href="#CREATE…SELECT子查询" class="headerlink" title="CREATE…SELECT子查询"></a>CREATE…SELECT子查询</h5><pre class=" language-mysql"><code class="language-mysql">CREATE TABLE user1(  id INT UNSIGNED AUTO_INCREMENT KEY,  username VARCHAR(20))SELECT id,username FROM emp;</code></pre><h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4><h5 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h5><ul><li>会去掉两个表中重复的值</li></ul><pre class=" language-mysql"><code class="language-mysql">SELECT 字段名称,... FROM tbl_name1UNIONSELECT 字段名称,... FROM tbl_name2UNION...</code></pre><h5 id="UNION-ALL"><a href="#UNION-ALL" class="headerlink" title="UNION ALL"></a>UNION ALL</h5><ul><li>进行简单的合并，并不会去掉重复值</li></ul><pre class=" language-mysql"><code class="language-mysql">SELECT 字段名称,... FROM tbl_name1UNION ALLSELECT 字段名称,... FROM tbl_name2UNION ALL...</code></pre><h4 id="自身连接查询"><a href="#自身连接查询" class="headerlink" title="自身连接查询"></a>自身连接查询</h4><ul><li>无限级分类的实现形式，有点类似于链表，可以以链的形式寻找父分类。</li></ul><pre class=" language-mysql"><code class="language-mysql">SELECT s.id,s.cateName AS sCateName,p.cateName AS pCateNameFROM cate AS sLEFT JOIN cate AS pON s.pId=p.id;</code></pre><h2 id="MySQL常用函数"><a href="#MySQL常用函数" class="headerlink" title="MySQL常用函数"></a>MySQL常用函数</h2><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><p><img src="/%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0.png" alt="数学函数简介"></p><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><pre class=" language-mysql"><code class="language-mysql">-- CHAR_LENGTH():得到字符串的字符数SELECT CHAR_LENGTH('ABC');-- LENGTH():返回字符串的长度，与上面的函数的区别在于对中文的识别SELECT LENGTH('ABC')-- CONCAT(s1,s2,...):将字符串合并为一个字符串SELECT CONCAT('A','B','C');-- CONCAT_WS(x,s1,s2,s3,...):以指定分隔符拼接字符串SELECT CONCAT_WS('-','A','B','C');-- 将字符串转换为大写或者小写 UPPER()|UCASE() LOWER()|LCASE()select upper('hello king'),ucase('hello imooc'),lower('HELLO ADMIN'),LCASE('HELLO EVERYBODY');-- 字符串的翻转REVERSE()SELECT REVERSE('ABC');-- LEFT()|RIGHT():返回字符串的前几个字符或者后几个字符SELECT LEFT('HELLO',2),RIGHT('HELLO',2);--LPAD()|RPAD():用字符串填充到指定长度SELECT LPAD('abc',10,'?');-- 去掉字符串两端的空格TRIM()|LTRIM()|RTRIM()SELECT TRIM(' ABC '),LTRIM(' ABC '),RTRIM(' ABC ');-- REPEAT(S,n):重复指定的字符串SELECT REPEAT('HELLO',3);-- REPLACE(s1,s2,s3):字符串的替换，在s1中找到s2用s3来替换SELECT REPLACE('HELLO KING','KING','QUEEN');-- SUBSTRING(s1,n1,n2):字符串的截取，把s1字符串从n1处开始截取n2位SELECT SUBSTRING('abcdef',1,3);-- STRCMP(s1,s2):比较字符串的ASCII码值SELECT STRCMP('A','C');</code></pre><h3 id="日期时间函数"><a href="#日期时间函数" class="headerlink" title="日期时间函数"></a>日期时间函数</h3><pre class=" language-mysql"><code class="language-mysql">-- 返回当前时间SELECT CURTIME(),CURRENT_TIME();-- 返回当前的日期时间SELECT NOW(),CURRENT_TIMESTAMP(),SYSDATE();-- 返回日期中的月份和月份的名称SELECT MONTH('2017-02-19');SELECT MONTH(CURDATE()),MONTHNAME(CURDATE());-- 返回星期SELECT DAYNAME(NOW());-- 返回一周内的第几天SELECT DAYOFWEEK(NOW());-- 返回一年中的信息SELECT WEEK(NOW());SELECT YEAR(NOW());SELECT DAY(NOW());SELECT HOUR(NOW());SELECT MINUTE(NOW());SELECT SECOND(NOW());-- 计算两个日期之间相差的天数SELECT DATEDIFF('2017-03-01','2017-09-30');</code></pre><p><img src="/%E6%98%9F%E6%9C%9F%E5%9B%BE.png" alt="星期与一周内的第几天的对应关系图"></p><h3 id="其他常用函数"><a href="#其他常用函数" class="headerlink" title="其他常用函数"></a>其他常用函数</h3><pre class=" language-mysql"><code class="language-mysql">-- 得到版本信息、连接数以及数据库名SELECT VERSION(),CONNECTION_ID(),DATABASE();-- 得到当前登录的用户SELECT USER(),CURRENT_USER(),SYSTEM_USER(),SESSION_USER();-- 返回上一步产生的自增长IDSELECT LAST_INSERT_ID();-- 使用加密算法，返回加密字符串SELECT MD5('KING');SELECT PASSWORD('king'); #默认加密算法</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中输入输出流特点的总结</title>
      <link href="/2020/10/19/java-shu-ru-shu-chu-liu/"/>
      <url>/2020/10/19/java-shu-ru-shu-chu-liu/</url>
      
        <content type="html"><![CDATA[<h2 id="Java的输入输出流"><a href="#Java的输入输出流" class="headerlink" title="Java的输入输出流"></a>Java的输入输出流</h2><ul><li>流：一连串流动的字符，以先进先出的形式发送和接收信息。</li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>文件输入</td><td>读</td></tr><tr><td>文件输出</td><td>写</td></tr></tbody></table><h2 id="File类的使用"><a href="#File类的使用" class="headerlink" title="File类的使用"></a>File类的使用</h2><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><ul><li>文件可认为是相关记录或放在一起的数据的集合</li><li>在Java中，使用<code>java.io.File</code>类对文件进行操作。</li></ul><h3 id="创建File类实例的三种方式"><a href="#创建File类实例的三种方式" class="headerlink" title="创建File类实例的三种方式"></a>创建File类实例的三种方式</h3><ul><li>可以把主目录与子目录分开作为参数进行实例化，下面是三种方式的实例代码。</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//方式1，直接把绝对路径作为构造函数参数来构建实例</span>File file1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"c:\\imooc\\io\\score.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//方式2，把父路径和子路径分开作为两个参数来构建实例</span>File file1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"c:\\imooc"</span><span class="token punctuation">,</span><span class="token string">"io\\score.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//方式3，分两次构建实例</span>File file<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"c:\\imooc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>File file1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span><span class="token string">"io\\score.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><ul><li>字节输入流<code>InputStream</code></li><li>字节输出流<code>OutputStream</code></li></ul><h3 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流"></a>字节输入流</h3><p><img src="/1.png" alt="字节输入流结构示意图"></p><h4 id="文件输入流FileInputStream"><a href="#文件输入流FileInputStream" class="headerlink" title="文件输入流FileInputStream"></a>文件输入流FileInputStream</h4><ul><li>从文件系统中的某一个文件中获得输入字节；</li><li>用于读取诸如图像数据之类的原始字节流</li></ul><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>public int read()</code></td><td>从束流中读取一个数据字节</td></tr><tr><td><code>public int read(byte[] b)</code></td><td>从输入流中将最多b.length个字节的数据读入一个byte数组中</td></tr><tr><td><code>public int read(byte[] b, int off, int len)</code></td><td>从输入流中将最多len个字节的数据读入byte数组中</td></tr><tr><td><code>public void close()</code></td><td>关闭此文件中输入流并释放与此流有关的所有系统资源</td></tr></tbody></table><ul><li>如果返回值为-1，则表示已经到达文件末尾</li><li>读完文件之后需要使用<code>close()</code>方法来释放资源</li></ul><h4 id="缓冲输入流BufferedInputStream"><a href="#缓冲输入流BufferedInputStream" class="headerlink" title="缓冲输入流BufferedInputStream"></a>缓冲输入流BufferedInputStream</h4><ul><li>提高读写速度</li><li>需要与文件输入输出流结合，把输入流的子类当成构造函数参数输入。</li></ul><h3 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h3><p><img src="/2.png" alt="字节输出流结构示意图"></p><h4 id="缓冲输入流BufferedOutputStream"><a href="#缓冲输入流BufferedOutputStream" class="headerlink" title="缓冲输入流BufferedOutputStream"></a>缓冲输入流BufferedOutputStream</h4><ul><li>提高读写速度</li><li>需要与文件输入输出流结合，把输出流的子类当成构造函数参数输入。</li></ul><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><ul><li>适用于发送和接收字符的情况使用</li></ul><h3 id="字符输入流"><a href="#字符输入流" class="headerlink" title="字符输入流"></a>字符输入流</h3><p><img src="/3.png" alt="字符输入流结构示意图"></p><h3 id="字符输出流"><a href="#字符输出流" class="headerlink" title="字符输出流"></a>字符输出流</h3><p><img src="/4.png" alt="字符输出流结构示意图"></p><h3 id="字节字符转换流"><a href="#字节字符转换流" class="headerlink" title="字节字符转换流"></a>字节字符转换流</h3><ul><li><code>InputStreamReader()</code></li><li><code>OutputStreamReader()</code></li><li>可以把二进制字节流与字符流互相转化</li></ul><h2 id="对象的序列化和反序列化"><a href="#对象的序列化和反序列化" class="headerlink" title="对象的序列化和反序列化"></a>对象的序列化和反序列化</h2><h3 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h3><ul><li><p>步骤：</p><ol><li>创建一个类，继承<code>Serializable</code>接口；</li><li>创建对象；</li><li>将对象写入文件；</li><li>从文件读取对象信息。</li></ol></li><li><p>对象输入流<code>ObjectInputStream</code></p></li><li><p>对象输出流<code>ObjectOutputStream</code></p></li><li><p>序列化：把Java对象转换为字节序列的过程；</p></li><li><p>反序列化：把字节序列恢复为Java对象的过程。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
            <tag> Java </tag>
            
            <tag> 输入流 </tag>
            
            <tag> 输出流 </tag>
            
            <tag> 文件操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo的Matery主题博客部署问题与解决方案汇总</title>
      <link href="/2020/10/19/hexo-bo-ke-bu-shu/"/>
      <url>/2020/10/19/hexo-bo-ke-bu-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="版本问题"><a href="#版本问题" class="headerlink" title="版本问题"></a>版本问题</h2><ul><li>以下是我目前使用的各软件版本。这个版本可以实现目前已经探索到的所有的功能，推荐使用以下版本。</li></ul><pre class=" language-bash"><code class="language-bash">hexo: 4.2.0hexo-cli: 4.2.0os: Linux 5.4.0-48-generic linux x64node: 14.12.0v8: 8.4.371.19-node.16uv: 1.39.0zlib: 1.2.11brotli: 1.0.9ares: 1.16.0modules: 83nghttp2: 1.41.0napi: 7llhttp: 2.1.2openssl: 1.1.1gcldr: 37.0icu: 67.1tz: 2020aunicode: 13.0</code></pre><h2 id="npm包管理器问题"><a href="#npm包管理器问题" class="headerlink" title="npm包管理器问题"></a>npm包管理器问题</h2><ul><li>该包管理器的源默认是在国外，如果你是在中国大陆的话，推荐使用阿里的源，这个源可以大大增加下载速度，提升效率。执行下面的命令可以自动换源。</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">npm</span> config <span class="token keyword">set</span> -g registry https://registry.npm.taobao.org</code></pre><h2 id="Node-js版本问题"><a href="#Node-js版本问题" class="headerlink" title="Node.js版本问题"></a>Node.js版本问题</h2><ul><li>Node.js的最低版本限制与Hexo版本的对应关系</li></ul><table><thead><tr><th>Hexo版本</th><th>最低兼容Node.js版本</th></tr></thead><tbody><tr><td>5.0+</td><td>10.13.0</td></tr><tr><td>4.1 - 4.2</td><td>8.10</td></tr><tr><td>4.0</td><td>8.6</td></tr><tr><td>3.3 - 3.9</td><td>6.9</td></tr><tr><td>3.2 - 3.3</td><td>0.12</td></tr><tr><td>3.0 - 3.1</td><td>0.10 or iojs</td></tr><tr><td>0.0.1 - 2.8</td><td>0.10</td></tr></tbody></table><h2 id="变换Hexo版本问题"><a href="#变换Hexo版本问题" class="headerlink" title="变换Hexo版本问题"></a>变换Hexo版本问题</h2><ul><li>Hexo版本可以很容易地变换，通过以下命令就可以进行变换，<strong>注意</strong>，Hexo可供下载的版本可以在其对应的github上的releases板块查询到，不能将Hexo改到没有的版本上去，这样脚本会报错。</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> i hexo@4.2.0    <span class="token comment" spellcheck="true">#将版本更换为4.2.0</span><span class="token function">npm</span> i hexo@5.1.1    <span class="token comment" spellcheck="true">#将版本更换为5.1.1</span></code></pre><h2 id="关于Hexo不能在CodeBlock里面正确显示curly-bracket的问题"><a href="#关于Hexo不能在CodeBlock里面正确显示curly-bracket的问题" class="headerlink" title="关于Hexo不能在CodeBlock里面正确显示curly bracket的问题"></a>关于Hexo不能在CodeBlock里面正确显示curly bracket的问题</h2><ul><li>这个问题跟Hexo的版本有关，如果你是安装的<code>5.0.0</code>及以上的版本，会遇到这个问题，解决方案就是把你的hexo版本降低到<code>4.x.x</code>。这就可以非常完美地解决这个问题。但是，也不可以无限降低，我本人在尝试的时候发现当版本降低到<code>4.1.1</code>及以下时，Hexo就不能正常工作了，不清楚这是什么问题。推荐的版本是<code>4.2.0</code>和<code>4.2.1</code>。</li></ul><h2 id="关于博客在本地可以显示，但挂载到Github上的时候就无法访问的问题"><a href="#关于博客在本地可以显示，但挂载到Github上的时候就无法访问的问题" class="headerlink" title="关于博客在本地可以显示，但挂载到Github上的时候就无法访问的问题"></a>关于博客在本地可以显示，但挂载到Github上的时候就无法访问的问题</h2><ul><li>这个问题的原因很大可能是因为你的DNS服务商的问题，有的DNS服务商会故意屏蔽部分域名，你可以试一下改变DNS服务商，在这里推荐的服务商是阿里或者腾讯。</li></ul><h2 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h2>]]></content>
      
      
      <categories>
          
          <category> 博客部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Matery </tag>
            
            <tag> 博客 </tag>
            
            <tag> Q&amp;A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中多线程特点的总结</title>
      <link href="/2020/10/19/java-duo-xian-cheng/"/>
      <url>/2020/10/19/java-duo-xian-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h2><ul><li>进程是指可执行程序并存放在计算机存储器的一个指令序列，它是一个动态执行的过程；</li><li>线程是比进程还要小的运行单位，一个进程包含多个线程；</li><li>线程可以看作一个子程序；</li><li>线程调度的先后次序是随机的。</li></ul><h2 id="线程的创建（两种方法）"><a href="#线程的创建（两种方法）" class="headerlink" title="线程的创建（两种方法）"></a>线程的创建（两种方法）</h2><ul><li>创建一个<code>Thread</code>类，或者一个<code>Thread</code>子类的对象；</li><li>创建一个实现<code>Runnable</code>接口的类的对象。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//方法一，通过创建Thread子类的对象创建进程</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//方法二，通过Runnable接口类传入Thread类构造函数，构造Thread对象，此方法更为常用，更适合需要继承另一个父类的情况</span></code></pre><h2 id="Thread类中的常用方法"><a href="#Thread类中的常用方法" class="headerlink" title="Thread类中的常用方法"></a><code>Thread</code>类中的常用方法</h2><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td><code>public void run()</code></td><td>线程相关的代码写在该方法中，一般需要重写</td></tr><tr><td><code>public void start()</code></td><td>启动线程的方法</td></tr><tr><td><code>public static void sleep(long m)</code></td><td>线程休眠m毫秒的方法</td></tr><tr><td><code>public void join()</code></td><td>优先执行调用<code>join()</code>方法的线程，抢占资源</td></tr></tbody></table><h2 id="创建一个实现Runnable接口的类的对象"><a href="#创建一个实现Runnable接口的类的对象" class="headerlink" title="创建一个实现Runnable接口的类的对象"></a>创建一个实现<code>Runnable</code>接口的类的对象</h2><ul><li><p>只有一个方法<code>run();</code>；</p></li><li><p><code>Runnable</code>是Java中用以实现线程的接口；</p></li><li><p>任何实现线程功能的类都必须实现该接口；</p></li><li><p>使用<code>Runnable</code>接口创建线程的原因</p><ol><li>Java不支持多继承，如果继承<code>Thread</code>类的同时还需要继承别的类就没法实现了，因此通过接口的形式实现继承；</li><li>不打算重写<code>Thread</code>类的其他方法。</li></ol></li><li><p><code>Runnable</code>接口实现类的创建和使用示例代码如下：</p></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        PrintRunnable td <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread td1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>td<span class="token punctuation">)</span><span class="token punctuation">;</span>        td1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrintRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token operator">+</span><span class="token string">"线程正在执行！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>使用<code>Runnable</code>接口实现类的时候需要先实例化接口实现类的对象，再去实例化一个<code>Thread</code>类的对象来运行实现类定义的线程。</li></ul><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><ul><li>新建状态（New）</li><li>可运行状态（Runnable）（就绪状态）</li><li>正在运行状态（Running）</li><li>阻塞（Blocked）</li><li>终止（Dead）</li></ul><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p><img src="/1.png" alt="线程的生命周期示意图"></p><h2 id="sleep方法应用"><a href="#sleep方法应用" class="headerlink" title="sleep方法应用"></a>sleep方法应用</h2><ul><li><code>Thread</code>类的方法；</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">long</span> millis<span class="token punctuation">)</span></code></pre><ul><li>作用：在指定的毫秒数内让正在执行的线程休眠（暂停执行）；</li><li>参数为休眠的时间，单位是毫秒。</li></ul><h2 id="join方法应用"><a href="#join方法应用" class="headerlink" title="join方法应用"></a>join方法应用</h2><ul><li><code>Thread</code>类的方法；</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li>作用：等待调用该方法的线程结束后才能执行；</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token keyword">long</span> millis<span class="token punctuation">)</span></code></pre><ul><li>作用：等待该线程终止的最长时间为millis毫秒；</li><li>抢占CPU使用权，迫使其他线程放弃CPU使用权。</li></ul><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><ul><li><p>Java为线程类提供了10个优先级；</p></li><li><p>优先级可以用整数1-10表示，超过范围会抛出异常；</p></li><li><p>主线程默认优先级5；</p></li><li><p>数字越大，表示优先级越高；</p></li><li><p>优先级常量：</p><ul><li>MAX_PRIORITY：线程的最高优先级10；</li><li>MIN_PRIORITY：线程的最低优先级1；</li><li>NORM_PRIORITY：线程的默认优先级5（与主线程相同）。</li></ul></li><li><p>优先级相关的方法：</p></li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>public int getPriority()</code></td><td>获取线程优先级的方法</td></tr><tr><td><code>public void setPriority(int newPriority)</code></td><td>设置线程优先级的方法</td></tr></tbody></table><h2 id="多线程运行问题"><a href="#多线程运行问题" class="headerlink" title="多线程运行问题"></a>多线程运行问题</h2><ul><li>各个线程是通过竞争CPU时间而获得运行机会的；</li><li>各线程什么时候得到CPU时间，占用多久，是不可预测的；</li><li>一个正在运行着的线程在什么地方被暂停是不确定的。</li></ul><h2 id="线程同步问题"><a href="#线程同步问题" class="headerlink" title="线程同步问题"></a>线程同步问题</h2><ul><li><p>以取款为例，说明为什么要引入线程同步这个概念</p><ol><li>为了保证在存款或取款的时候，不允许其他线程对账户余额进行操作；</li><li>需要将<code>Bank</code>对象进行锁定；</li><li>使用关键字<code>synchronized</code>实现，可以确保共享对象在同一个时刻只能被一个线程访问，进一步保证执行完整性。</li></ol></li><li><p><code>synchronized</code>关键字用在</p><ul><li>成员方法</li><li>静态方法</li><li>语句块</li></ul></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">saveAccount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//成员方法</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">saveAccount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//静态方法</span><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">//语句块，obj指的是需要被锁定的对象，{...}是指作用语句块，即作用范围</span></code></pre><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><ul><li>wait()方法：中断方法的执行，使线程等待；</li><li>notify()方法：唤醒处于等待的某个线程，使其结束等待；</li><li>notifyAll()方法：唤醒所有处于等待的线程，使它们结束等待；</li><li>以生产者消费者的例子可以很好地说明通信需求的原因。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 进程 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中集合的总结</title>
      <link href="/2020/10/18/java-ji-he/"/>
      <url>/2020/10/18/java-ji-he/</url>
      
        <content type="html"><![CDATA[<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul><li>Java中的集合是工具类，可以存储任意数量的共同属性的数据。</li><li>数组只能用于存储固定长度数据的场景，而集合可以存储任意长度的数据</li></ul><h2 id="集合的应用场景"><a href="#集合的应用场景" class="headerlink" title="集合的应用场景"></a>集合的应用场景</h2><ul><li>无法预测存储数据的数量</li><li>同时存储具有一对一关系的数据</li><li>需要进行数据的增删</li><li>数据重复问题</li></ul><h2 id="集合的体系架构"><a href="#集合的体系架构" class="headerlink" title="集合的体系架构"></a>集合的体系架构</h2><ul><li><code>Collection</code>存储类的对象，例如，学生类的信息；<code>Map</code>主要是以键值对的形式存储信息，例如商品和商品的价格。</li><li><code>List</code>、<code>Queue</code>、<code>Set</code>是三个子接口。<code>List</code>、<code>Queue</code>是有序和允许重复的；<code>Set</code>是无序的且不可重复的。</li><li><code>ArrayList</code>、<code>LinkedList</code>、<code>HashSet</code>是三个实现类，实现了三个对应的接口。</li><li><code>Map</code>的主要实现类是<code>HashMap</code>。</li></ul><p><img src="/1.png" alt="集合框架的体系结构示意图"></p><h2 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a><code>List</code>(列表)</h2><ul><li><code>List</code>是元素有序并且可以重复的集合，称为序列；</li><li><code>List</code>可以精确地控制每一个元素的插入位置，或删除某个位置的元素；</li><li><code>List</code>的两个主要实现类是<code>ArrayList</code>和<code>LinkedList</code></li></ul><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a><code>ArrayList</code></h2><ul><li><code>ArrayList</code>底层是由数组实现的；</li><li>元素有序且可以重复；</li><li>动态增长，以满足应用程序的需求；</li><li>在列表尾部插入或删除数据非常有效；</li><li>更适合查找和更新元素；</li><li><code>ArrayList</code>中的元素可以为<code>null</code>。</li></ul><h2 id="关于接口引用指向实现类对象的说明"><a href="#关于接口引用指向实现类对象的说明" class="headerlink" title="关于接口引用指向实现类对象的说明"></a>关于接口引用指向实现类对象的说明</h2><ul><li>这实际上是一种多态的思想。<strong>多态的定义</strong>：指的是允许不同类的对象对同一个消息做出响应，即同一个消息可以根据发送对象的不同而采取多种不同的行为方式。（发送消息就是函数调用）；</li><li><code>List list</code>是在栈区开辟一个空间放<code>list</code>的引用，并没有创建对象所以不知道真正的对象是<code>ArrayList</code>还是<code>LinkedList</code>。当<code>list = new ArrayList();</code>的时候就创建了ArrayList对象，并且把开始创建的<code>list</code>引用指向这个对象。需要强调，<code>ArrayList</code>和<code>LinkedList</code>都是<code>List</code>的实现类；</li><li>那么为什么一般都使用<code>List list = new ArrayList();</code>而不用<code>ArrayList list = new ArrayList();</code>呢？因为<code>List</code>这个接口有多个实现类，如<code>LinkedList</code>或者<code>Vector</code>等等，现在你用的是<code>ArrayList</code>实现类，有可能之后需求更改需要使用其他的实现类了。如果使用的是前一种方法，那么只需要改变一开始的引用赋值的那一行代码就可以了，其他使用到<code>list</code>对象的代码根本不需要改动。假设如果你一开始就是用了第二种方法，尤其是你还是用了<code>ArrayList</code>这个实现类特有的方法，那么就需要更改非常多的代码，对程序的重构是没有好处的。因此，一般没有特别需求的情况下，使用<code>List list = new ArrayList();</code>是比较方便程序代码的重构的，这就是所谓的面向接口编程的好处。<strong>注意</strong>：如果采用了<code>List list = new ArrayList();</code>的方法创建实例对象，那么<code>ArrayList</code>这个实现类自己特有的方法是不可以被访问到的；</li><li>接口的灵活性就在于“规定了一个类必须做什么，而不管你如何做”。我们可以定义一个接口类型的实例，当引用调用方法时，它会根据实际引用的类的实例来判断具体调用哪个方法，这和超类对象引用访问子类对象的机制是类似的。</li></ul><h2 id="Set-amp-HashSet"><a href="#Set-amp-HashSet" class="headerlink" title="Set&amp;HashSet"></a><code>Set</code>&amp;<code>HashSet</code></h2><ul><li>元素无序且不可以重复的集合，被称为集；</li><li><code>HashSet</code>是<code>Set</code>的一个重要实现类，称为哈希集；</li><li><code>HashSet</code>中的元素无序且不可以重复；</li><li><code>HashSet</code>只允许一个<code>null</code>元素；</li><li>具有良好的存取和查找性能。</li></ul><h2 id="Iterator（迭代器）"><a href="#Iterator（迭代器）" class="headerlink" title="Iterator（迭代器）"></a><code>Iterator</code>（迭代器）</h2><ul><li><code>Iterator</code>接口可以以统一的方式对各种集合元素进行遍历；</li><li><code>hasNext()</code>方法检测集合中是否还有下一个元素；</li><li><code>next()</code>方法返回集合中的下一个元素。</li><li><strong>集合在进行遍历的时候是不允许进行元素的添加和删除的，如果要添加和删除需要在迭代循环的时候删除元素之后退出循环。</strong></li><li>使用迭代器遍历元素的示例代码如下：</li></ul><pre class=" language-java"><code class="language-java">Iterator it<span class="token operator">=</span> set<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//判断是否还有下一个元素</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//it.next()代表了下一个元素</span><span class="token punctuation">}</span></code></pre><h2 id="hashCode-与equal-方法的重写"><a href="#hashCode-与equal-方法的重写" class="headerlink" title="hashCode()与equal()方法的重写"></a><code>hashCode()</code>与<code>equal()</code>方法的重写</h2><ul><li>重写这两个方法主要用在<code>Hash</code>相关的集合中，主要定义hash码的产生方式以及如何判定对象是否相等，重写这个方法可以定制Set的判定相等模式。</li><li>以下代码为上述两个方法重写的示例，在IDEAJ中可以通过自动插入方式自动编写这两个方法。</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//判断对象是否相等，相等则返回true，不用继续比较属性了</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">==</span>o<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//判断obj是否是Cat类的对象</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>Cat<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Cat cat<span class="token operator">=</span><span class="token punctuation">(</span>Cat<span class="token punctuation">)</span>o<span class="token punctuation">;</span>        <span class="token keyword">return</span> cat<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token operator">&amp;&amp;</span>cat<span class="token punctuation">.</span><span class="token function">getMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token operator">&amp;&amp;</span>cat<span class="token punctuation">.</span><span class="token function">getSpecies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSpecies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Objects<span class="token punctuation">.</span><span class="token function">hash</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> month<span class="token punctuation">,</span> species<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="泛型的概念"><a href="#泛型的概念" class="headerlink" title="泛型的概念"></a>泛型的概念</h2><ul><li>JavaSE 5.0之后引入的概念；</li><li>利用对<code>Object</code>类型的引用实现参数类型的任意化，任意化的缺点就是要做显式的类型转换，这对于后期维护代码和修改代码来说带来了比较大的工作量。并且制定类型还会产生运行时错误，这是我们不希望看到的。使用泛型，就可以独立于特定数据类型来一次性定义算法，然后把算法应用于各种数据类型，而不需要做额外的工作。因此Java中定义了泛型的概念。</li><li>Java中泛型的概念和C++中模板的区别：C++为每一种数据类型都构建了底层代码，而Java只构建了一份代码，当需要另一种类型时，Java会重新构建代码。所以C++模板的代码体积比较大，但是由于代码已经全部构建好了，因此C++的执行速度更快。</li><li>泛型的写法</li></ul><pre class=" language-java"><code class="language-java">Set<span class="token operator">&lt;</span>Cat<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>Cat<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Iterator<span class="token operator">&lt;</span>Cat<span class="token operator">></span> it <span class="token operator">=</span> set<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a><code>Map</code></h2><ul><li><code>Map</code>中的数据是以键值对（key-value）的形式存储的；</li><li>key-value是以<code>Entry</code>类型的对象实例存在的，<code>Entry</code>是接口类；</li><li>可以通过<code>key</code>值快速查找<code>value</code>；</li><li>一个映射不能包含重复的键</li><li>每个键最多只能映射到一个值</li></ul><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a><code>HashMap</code></h2><ul><li>基于哈希表的<code>Map</code>接口的实现；</li><li>允许使用<code>null</code>值和<code>null</code>键，一个<code>Map</code>中只能有一个<code>null</code>键；</li><li><code>key</code>值不允许重复；</li><li>HashMap中的Entry对象是无序排列的。</li></ul><h2 id="增强型for循环的使用"><a href="#增强型for循环的使用" class="headerlink" title="增强型for循环的使用"></a>增强型for循环的使用</h2><ul><li>我们也可以用增强型for循环来代替迭代器去遍历集合。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span>String str<span class="token operator">:</span>set<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"你好"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"已经找到的对应的字符串"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
            <tag> List </tag>
            
            <tag> Set </tag>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中String类型和StringBuilder类型的总结</title>
      <link href="/2020/10/18/javastring-lei-xing/"/>
      <url>/2020/10/18/javastring-lei-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="String类的常用方法"><a href="#String类的常用方法" class="headerlink" title="String类的常用方法"></a>String类的常用方法</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>int length()</td><td>返回当前字符串长度</td></tr><tr><td>int indexOf(int ch)</td><td>查找字符在该字符串中第一次出现的位置</td></tr><tr><td>int indexOf(String str)</td><td>查找str字符串在该字符串中第一次出现的位置</td></tr><tr><td>int lastIndexOf(int ch)</td><td>查找ch字符在该字符串中最后一次出现的位置</td></tr><tr><td>int lastIndexOf(String str)</td><td>查找str字符串在该字符串中最后一次出现的位置</td></tr><tr><td>String subString(int beginIndex)</td><td>获取从beginIndex位置开始到结束的子字符串</td></tr><tr><td>String subString(int beginIndex, int endIndex)</td><td>获取从beginIndex位置开始到endIndex位置的子字符串</td></tr><tr><td>String trim()</td><td>返回去除了前后空格的字符串</td></tr><tr><td>boolean equals(Object obj)</td><td>将该字符串与指定对象比较，返回true或false</td></tr><tr><td>String toLowerCase()</td><td>将字符串转换为小写</td></tr><tr><td>String toUpperCase()</td><td>将字符串转换为大写</td></tr><tr><td>char charAt(int index)</td><td>获取字符串中指定位置的字符</td></tr><tr><td>String[] split(String regex,int limit)</td><td>将字符串分割为子字符串，返回字符串数组</td></tr><tr><td>byte[] getBytes()</td><td>将该字符串转换为byte数组</td></tr></tbody></table><h2 id="利用String创建新对象时，常量池的作用"><a href="#利用String创建新对象时，常量池的作用" class="headerlink" title="利用String创建新对象时，常量池的作用"></a>利用String创建新对象时，常量池的作用</h2><p><img src="/1.png" alt="创建对象时常量池、堆、栈的不同的作用示意图"></p><ul><li>内存中，对象的引用是存在栈中，对象存储在常量池和堆中，常量池中的对象和堆中的对象的地址空间是完全不一样的。</li></ul><h2 id="String类型的不可变性"><a href="#String类型的不可变性" class="headerlink" title="String类型的不可变性"></a>String类型的不可变性</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//String的不可变性：只有通过赋值，字符串才会发生改变</span>    <span class="token comment" spellcheck="true">//String对象一旦被创建，则不能修改，是不可变的</span>    <span class="token comment" spellcheck="true">//所谓的修改其实是创建了新的对象，所指向的内存空间不变</span>    String s1 <span class="token operator">=</span> <span class="token string">"imooc"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//在常量池中生成一个imooc对象，在栈中会有一个引用指向imooc对象</span>    s1 <span class="token operator">=</span> <span class="token string">"hello,"</span> <span class="token operator">+</span> s1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//在常量池中又生成了新的hello imooc对象，把s1的引用指向新的hello imooc对象，原先的imooc引用被废除掉了.</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"s1="</span> <span class="token operator">+</span> s1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>通过赋值操作对s1引用的值进行了改变，s1不再指向imooc所在的内存空间，而是指向了”hello,imooc”；</li><li><strong>注意</strong>，在做字符串连接处理得时候并没有改变引用的方向，只是在指向引用的时候改变了引用指向的对象；</li><li>以上操作都是在常量池中完成的。</li></ul><p><img src="/2.png" alt="修改String类型常量池对象时，内存中发生的操作示意图"></p><h2 id="字符串StringBuilder"><a href="#字符串StringBuilder" class="headerlink" title="字符串StringBuilder"></a>字符串<code>StringBuilder</code></h2><ul><li><strong><code>String</code>和<code>StringBuilder</code>的区别</strong>：String具有不可变性，而<code>StringBuilder</code>不具备；</li><li><strong>建议</strong>：当频繁操作字符串时，使用<code>StringBuilder</code>。使用<code>String</code>类，频繁操作字符串时，会产生很多的中间变量与常量池垃圾，因此要采用<code>StringBuilder</code>类；</li><li><code>StringBuilder</code>和<code>StringBuffer</code>两者基本相似，StringBuffer是线程安全的，<code>StringBuilder</code>则没有，所以<code>StringBuilder</code>性能略高。一般都是单线程程序，所以一般都是用<code>StringBuilder</code>。</li><li><code>StringBuilder</code>不会创建新的对象，因此可以大大提升性能。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
            <tag> Java </tag>
            
            <tag> String </tag>
            
            <tag> StringBuilder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研英语大作文整理</title>
      <link href="/2020/10/18/zuo-wen-ju-shi-yu-ci-hui/"/>
      <url>/2020/10/18/zuo-wen-ju-shi-yu-ci-hui/</url>
      
        <content type="html"><![CDATA[<h2 id="考研大作文常用词汇"><a href="#考研大作文常用词汇" class="headerlink" title="考研大作文常用词汇"></a>考研大作文常用词汇</h2><ol><li><p>上升动词类</p><ul><li>increase, go up, rise up, grow up, jump up, surge, shoot up, keep an upward tendency.</li></ul></li><li><p>下降动词类</p><ul><li>decrease, go down, decline, fall down, drop, sink, dip, keep a downward tendency</li></ul></li><li><p>波动动词类</p><ul><li>fluctuate</li></ul></li><li><p>持平动词类</p><ul><li>remain the same, stabilize, remain stable, remain constant</li></ul></li><li><p>修饰动词的副词</p><ul><li>slightly轻微地，slowly缓慢地，gradually逐渐地，steadily稳定地，rapidly迅速地，moderately温和地，轻微地，significantly明显地，sharply明显地，dramatically急剧地，drastically急剧地</li></ul></li><li><p>上升名词类</p><ul><li>increase, rise, growth, jump, surge</li></ul></li><li><p>下降名词类</p><ul><li>decrease, decline, fall, reduction, drop</li></ul></li><li><p>波动名词类</p><ul><li>fluctuation</li></ul></li><li><p>修饰名词的形容词</p><ul><li>slight, slow, gradual, steady, rapid, moderate, significant, sharp, dramatic, drastic</li></ul></li></ol><h2 id="极值类词汇和表达"><a href="#极值类词汇和表达" class="headerlink" title="极值类词汇和表达"></a>极值类词汇和表达</h2><ol><li><p>最高点</p><ul><li>reach/increase the peak</li><li>reach/increase the top</li><li>reach/increase the highest point</li></ul></li><li><p>最低点</p><ul><li>(reach/drop to) the bottom</li><li>(reach/drop to) the lowest point</li></ul></li><li><p>占得最多</p><ul><li>(occupy/make up/take up/account for) the largest (proportion/number/percentage) of…</li></ul></li><li><p>占得最少</p><ul><li>(occupy/make up/take up/account for) the smallest (proportion/number/percentage) of…</li></ul></li></ol><h2 id="倍数的表达方式"><a href="#倍数的表达方式" class="headerlink" title="倍数的表达方式"></a>倍数的表达方式</h2><ul><li>Increase/decrease three times增长/减少了三倍</li></ul><h2 id="开头段转述题目常用句型"><a href="#开头段转述题目常用句型" class="headerlink" title="开头段转述题目常用句型"></a>开头段转述题目常用句型</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>The line graph describes/ illustrates/ demonstrates/ summarizes/ outlines/ shows…</td><td>后面跟名词或者从句 开头段或者主体段引出数据或者趋势常用句型</td></tr><tr><td>According to/ As shown in/ As can be seen from…</td><td>后面跟图表的类型</td></tr><tr><td>It can be seen from…</td><td>后面跟图表的类型…</td></tr><tr><td>It is manifest from…</td><td>后面跟图表的类型…</td></tr><tr><td>the bar chart illustrates that…</td><td>该柱状图展示了…</td></tr><tr><td>the graph provides some interesting data regarding…</td><td>该图为我们提供了有关…有趣数据。</td></tr><tr><td>the diagram shows (that)…</td><td>该图向我们展示了…</td></tr><tr><td>the pie graph depicts (that)….</td><td>该饼图揭示了…</td></tr><tr><td>this is a cure graph which describes the trend of…</td><td>这个曲线图描述了…的趋势。</td></tr><tr><td>the figures/statistics show (that)…</td><td>数据(字)表明…</td></tr><tr><td>the data/statistics/figures lead us to the conclusion that…</td><td>这些数据资料令我们得出结论…</td></tr><tr><td>as is shown/demonstrated/exhibited in the diagram/graph/chart/table…</td><td>如图所示…</td></tr><tr><td>as can be seen from the diagram,great changes have taken place in…</td><td>从图中可以看出，…发生了巨大变化</td></tr><tr><td>from the table/chart/diagram/figure,we can see clearly that…or it is clear/apparent from the chart that…</td><td>从图表我们可以很清楚(明显)看到…</td></tr><tr><td>this table shows the changing proportion of a &amp;b from…to…</td><td>该表格描述了…年到…年间a与b的比例关系。</td></tr><tr><td>the graph,presented in a pie chart, shows the general trend in…</td><td>该图以圆形图形式描述了…总的趋势。</td></tr><tr><td>this is a column chart showing…</td><td>这是个柱型图，描述了…</td></tr><tr><td>as can be seen from the graph,the two curves show the flutuation of…</td><td>如图所示，两条曲线描述了…的波动情况</td></tr><tr><td>over the period from…to…the…remained level.</td><td>在…至…期间，…基本不变。</td></tr><tr><td>in the 3 years spanning from 1995 through 1998…</td><td>1995年至1998三年里…</td></tr><tr><td>from then on/from this time onwards…</td><td>从那时起…</td></tr><tr><td>the number of…remained steady/stable from (month/year) to (month/year)</td><td>…月(年)至…月(年)…的数量基本不变。</td></tr><tr><td>the percentage of…stayed the same between…and…</td><td>…至…期间…的比率维持不变。</td></tr><tr><td>the figures peaked at…in(month/year)</td><td>…的数目在…月(年)达到顶点</td></tr><tr><td>there is not a great deal of difference between…and…</td><td>…与…的区别不大。</td></tr><tr><td>the graphs show a threefold increase in the number of…</td><td>该图表表明…的数目增长了三倍。</td></tr><tr><td>the situation reached a peak(a high point at) of[%].</td><td>…的情况(局势)到达顶(高)点，为…百分点。</td></tr><tr><td>the figures reached (the bottom/a low point/hit a trough).</td><td>数字(情况)达到底部(低谷)。</td></tr><tr><td>the difference between a and b lies in…</td><td>a与b之间的差别在于…</td></tr><tr><td>…(year)witnessed/saw a sharp rise in…</td><td>…年…急剧上升。</td></tr></tbody></table><h2 id="总体写作思路"><a href="#总体写作思路" class="headerlink" title="总体写作思路"></a>总体写作思路</h2><ol><li><p>读图</p><ul><li>选出特征最大的<strong>信息点</strong>。一般来说一到两个点就足够了。最大的<strong>信息点</strong>就是这幅图想要表达的内容。一般来说，只需要关注<strong>极值点</strong>、<strong>最大增幅</strong>、<strong>最大份额</strong>。鉴于考研英语二字数要求150字，篇幅很短，绝大多数情况下只需要提取<em>一个特征最多大的信息点</em>展开就可以了。</li></ul><table><thead><tr><th>真题</th><th>最大信息点</th></tr></thead><tbody><tr><td>2010年 发达国家和发展中国家手机用户数量变化</td><td>发展中国家手机用户增长迅猛</td></tr><tr><td>2011年 国内部分轿车品牌市场份额变化</td><td>国产车份额增长迅猛</td></tr><tr><td>2012年 某公司员工工作满意度调查</td><td>四十来岁的员工对工作最不满意，五十来岁的员工对工作最满意</td></tr><tr><td>2013年 某高校学生兼职情况</td><td>大四学生做过兼职的比例最大</td></tr><tr><td>2014年 中国城乡人口变化</td><td>城镇人口迅猛增长</td></tr><tr><td>2015年 某市居民春节花销比例</td><td>礼物花销占比最大</td></tr><tr><td>2016年 某高校学生旅游目的调查</td><td>绝大部分大学生旅游是为了欣赏风景和释放压力</td></tr><tr><td>2017年 我国博物馆数量和参观人数</td><td>博物馆数量和博物馆游客都增长迅猛</td></tr><tr><td>2018年 某市消费者选择餐厅时的关注因素</td><td>消费者最关心餐厅特色</td></tr><tr><td>2019年 某高校毕业生手机阅读目的调查</td><td>大部分学生用手机阅读是为了学习知识</td></tr></tbody></table></li><li><p>确定文章立意</p><ul><li>即<strong>确定核心段的写作任务</strong>，可以考虑原因论证、结果论证、举例论证(this is because…/this means that…/for example…)。</li><li>在考试中<strong>结果论证和举例论证都是不合适的</strong>。就图表而言，根据图表走向能判断结果为结果论证，这一任务在英语二大作文里应该在第三段写，不可本末倒置；而之所以不用举例论证原因是，任何图标都是具象的，它们本身就是具体事例。非常推荐使用原因论证，要去找图表给出的现象的原因。</li></ul><table><thead><tr><th>真题</th><th>核心段任务</th></tr></thead><tbody><tr><td>2010年 发达国家和发展中国家手机用户数量变化</td><td>为什么发展中国家手机用户增长迅猛</td></tr><tr><td>2011年 国内部分轿车品牌市场份额变化</td><td>为什么国产车份额增长迅猛</td></tr><tr><td>2012年 某公司员工工作满意度调查</td><td>为什么四十来岁的员工对工作最不满意，五十来岁的员工对工作最满意</td></tr><tr><td>2013年 某高校学生兼职情况</td><td>为什么大四学生做过兼职的比例最大</td></tr><tr><td>2014年 中国城乡人口变化</td><td>为什么城镇人口迅猛增长</td></tr><tr><td>2015年 某市居民春节花销比例</td><td>为什么礼物花销占比最大</td></tr><tr><td>2016年 某高校学生旅游目的调查</td><td>为什么绝大部分大学生旅游是为了欣赏风景和释放压力</td></tr><tr><td>2017年 我国博物馆数量和参观人数</td><td>为什么博物馆数量和博物馆游客都增长迅猛</td></tr><tr><td>2018年 某市消费者选择餐厅时的关注因素</td><td>为什么消费者最关心餐厅特色</td></tr><tr><td>2019年 某高校毕业生手机阅读目的调查</td><td>为什么大部分学生用手机阅读是为了学习知识</td></tr></tbody></table></li><li><p>寻找论证角度</p><ul><li>思考如何展开，从哪些角度切入。大多数英语二作文都是从社会和经济角度切入的(with the development of our society and economy)，阅卷老师很容易审美疲劳，可以从一些新颖的角度切入：<strong>消费升级类</strong>、<strong>个人发展类</strong>、<strong>社会变迁类</strong>。</li></ul></li><li><p>找原因进行论证</p><ul><li>先找主观原因，人做出某一个选择，发出某一个动作，花成本做某件事，都是因为一些需求。比如说我们使用手机，是因为我们有沟通的需求，有娱乐的需求；大学生兼职，是因为有获得实际工作经验的需求，有学习新东西的需求；我们去博物馆，是因为我们有求知的需求，有开阔眼界的需求；请客送礼，是因为有拉近关系的需求；向城市迁徙，是因为有对更好的公共资源的需求，等等。于是，<strong>所有的原因都可以统一到具体的人的需求之中来。</strong></li><li>关于需求，可以引入很系统的<strong>马斯洛需求层次理论</strong>。图表的主题的发展，图表所示的现象满足了人的什么需求？这是第一个切入角度。我们看向人类的马斯洛需求层次理论，如图。<br><br><br><br><br></li></ul> <table>     <tbody><tr>         <td colspan="5">马斯洛需求层次理论</td>     </tr>     <tr>         <td>第一层次<br>生理上的需求</td>         <td>第二层次<br>安全上的需求</td>         <td>第三层次<br>情感和归属的需求</td>         <td>第四层次<br>尊重的需求</td>         <td>第五层次<br>自我实现的需求</td>     </tr>     <tr>         <td>呼吸、水、食物、睡眠、生理平衡、分泌</td>         <td>人身安全、健康保障、资源所有性、财产所有性、道德保障、道德健全、工作职位保障、家庭安全</td>         <td>友情、爱情、性亲密、情感需求、归属感、内心的充实</td>         <td>外部尊重、内部尊重、对他人尊重、被他人尊重</td>         <td>创造力、自觉性、问题解决能力、公正度、接受现实能力、成就、积极心态</td>     </tr> </tbody></table><ul><li>这张表怎么用？这张表给我们提供了许多思考角度，即考研的主题（手机，汽车，礼物，旅游，兼职）满足了人的什么需求？在这张表的基础上，扩充形成一张语料库表，部分展示如下。这张基于马斯洛需求的语料库表格能为我们提供大量的言之有理的论点。</li></ul> <table>     <tbody><tr>         <td colspan="2">基于马斯洛需求层次的作文素材语料库</td>     </tr>     <tr>         <td>第三层次情感和归属的需求</td>         <td>（48）emotional need 情感需求<br>         （49）sense of identity/ belongings 归属感<br>         （50）communicate with other efficiently 高效与他人交流<br>         （51）face to face communication 面对面交流<br>         （52）go on well with others 拥有良好的人际关系<br>         （53）be popular with peers 在同龄人中很受欢迎<br>         （54）get high quality friendships 获得高质量的友谊<br>         （55）enhance our social acceptability 提高我们的社会接受度<br>         （56）encourage cohesion and social bonding 促进社会凝聚力<br>         （57）can be a powerful force for connectedness and nurturing a sense of belonging 能够成为彼此联系和培养归属感的强大力量<br>         （58）The individuals spend more time and energy giving their parents to others are going to be happier.<br>         那些花更多时间把礼物赠予给他人的人会更快乐。<br>         （59）make employees feel appreciated, respected and valued on a personal and professional level.<br>         是员工在个人和专业层面上收到赞赏，尊重和重视<br>         （60）be generous and authentic in recognizing the achievements of others 慷慨而真诚地认可他人的成就。<br>         offer praise without caveats and sarcasm 不加警告和嘲讽地基于赞美<br>         （61）work side by side with other brilliant people 与其他优秀人才并肩工作<br>         （62）transcend your self-focus 超越你的自我中心<br>         build your reputation as both reliable and trustworthy 建立你可靠和值得信赖的声誉<br>         （62）spur not only creativity and collaboration but also analytic precision and productivity 不仅激发出创造和合作，还有分析精准度与生产力<br>         （63）share victories and accomplishments with someone close 与亲近的人分享胜利和成就<br>         （64）promote healty work-life balance 促进健康的工作和生活平衡</td>     </tr> </tbody></table><ul><li>在写作的时候，拿到任意话题，按图索骥写第一个论点。以手机用户增长那一年真题的第一个论点为例：</li><li>思考过程为：为什么发展中国家手机用户数量增长如此迅猛？→ 因为他们有某些方面的需求而手机能够满足他们的需求→ 他们有哪些方面的需求？→ 在基于马斯洛需求的语料库表格中去找→ 高效与他人沟通的需求，与他人保持联系的需求等 → 造句→第一个论点完成了</li><li>In the first place, as for individuals, it is a strong desire rooted in their nature to communicate with others efficiently; correspondingly, owning a mobile phone enables them to keep in touch with their friends easily.</li><li>这里就是从语料库中挑选出的第三层次第50条“communicate with others efficiently 高效与他人沟通”和第52条“keep/ stay in touch with others 与他人保持联系”作为素材进行写作的。</li><li>前文讲解了主体，那么相应的，图表给出的现象也都与具体的客体息息相关。这里的客体不是哲学意义上的客体，而是简单地指发出的动作的接受者或者承受者。举个例子，人使用手机，主体是人，那么接受人的使用的就是客体——手机。</li><li>2010年真题，手机用户增长，手机的使用者是人，客体是手机。2011年真题，轿车品牌市场份额变化，消费者是人，客体是汽车。2012年真题，某公司员工工作满意度调查，描述的是最不满意的人，客体是工作。2013年真题，某高校学生兼职情况，描述的是高校学生，客体是兼职工作（part-time jobs）。</li><li>既然能从主体找主观原因，也能从客体找客观原因。比如，为什么手机用户越来越多，从主观来讲因为人有使用手机的主观需求，越来越多的人会使用手机；从客观来讲是因为手机厂商的发展提供了越来越多的各种便宜手机，能满足消费者的需求。</li><li>下面从客观角度找原因：汽车市场份额变化是因为国产汽车厂商越来越壮大，能满足消费者的需求。公司让40来岁的中年员工不满意是因为公司要求的工作任务多，压力大。农村人口迁移到城市是因为城市中有各种更好的社会资源。春节期间市民买礼物花销最大是因为礼物行业发展能为居民提供琳琅满目的礼品。大学生热衷于旅游是因为旅游业发展迅速，能满足大学生的需求。</li><li>从以上的罗列可以看出，高效的思考角度是在找客体原因的时候<strong>上推一个层级</strong>，从单个的物品/产品上推到<strong>整个行业的发展</strong>。这样第二个论点就能固定下来，句式也可以固定下来。</li><li>In the second place, the cellphone industry has been expanding significantly in recent years, thus providing people with a wide variety of products at a reasonable price.</li><li>也就是说，核心段写两个论点，从个人上推到整个行业。</li><li>关于作文的语言和语义之间的关系，讨巧的策略其实是言繁意简，不需要很多新颖的ideas和thoughts，相反，非常简单的意思就足够了，但是语言句式可以足够复杂和多变，以展现自己的语言能力。表达很多复杂的意思，一是增加了思考难度，很费时间，第二是对语言的要求更高一些。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 考研英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
            <tag> 考研英语 </tag>
            
            <tag> 作文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java包装类知识总结</title>
      <link href="/2020/10/17/java-bao-zhuang-lei/"/>
      <url>/2020/10/17/java-bao-zhuang-lei/</url>
      
        <content type="html"><![CDATA[<h2 id="几个常用的包装类"><a href="#几个常用的包装类" class="headerlink" title="几个常用的包装类"></a>几个常用的包装类</h2><ul><li>存在<code>java.lang</code>的包中<table><thead><tr><th>基本数据类型</th><th>对应的包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table></li></ul><h2 id="常量池的概念"><a href="#常量池的概念" class="headerlink" title="常量池的概念"></a>常量池的概念</h2><p><img src="/1.png" alt="整型常量池的工作原理图，简单来说就是常量池保存着系统已经创建好的对象，Java之所以要这样设置，是为了进一步优化效率。如果输入的数据命中常量池中已经创建好的对象，那么系统就不需要进行新建对象的操作了，否则，系统就需要新建一个对象。"></p><ul><li>除了<code>Float</code>和<code>Double</code>两种包装类，其他的基本数据类型对应的包装类均可以利用数据常量池的概念。</li></ul><table><thead><tr><th>基本数据类型</th><th>对应的包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td><del>float</del></td><td><del>Float</del></td></tr><tr><td><del>double</del></td><td><del>Double</del></td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h2 id="包装类的装箱和拆箱"><a href="#包装类的装箱和拆箱" class="headerlink" title="包装类的装箱和拆箱"></a>包装类的装箱和拆箱</h2><p><img src="/2.png" alt="包装类的装箱和拆箱示意图"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
            <tag> Java </tag>
            
            <tag> 包装类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日语学习例句</title>
      <link href="/2020/10/17/ri-yu-xue-xi-li-ju/"/>
      <url>/2020/10/17/ri-yu-xue-xi-li-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="50音あ行"><a href="#50音あ行" class="headerlink" title="50音あ行"></a>50音あ行</h2><h2 id="50音か行"><a href="#50音か行" class="headerlink" title="50音か行"></a>50音か行</h2><h2 id="50音さ行"><a href="#50音さ行" class="headerlink" title="50音さ行"></a>50音さ行</h2><p>うみ(mi)わ(wa) あおあお、そ(so)ら(ra)も(mo) あおあお。天也蓝蓝，海也蓝蓝。</p><p>あきこのこい、けいこのこい。あきこ的恋爱，けいこ的恋爱。</p><p>かささして(te)、さあ　いこう。撑开伞我们走吧。</p><p>さけ（酒）酒、すいか西瓜、せかい（世界）世界、アイスice。</p><p>しお（盐）、すし（寿司）、せき（座位）、あさ（早上）。</p><p>くさい　あし 臭的脚。</p><p>おおきい　すいか 大西瓜。</p><p>おいしい　すし　美味的寿司。</p><table><thead><tr><th>日文</th><th>中文</th><th>日文</th><th>中文</th></tr></thead><tbody><tr><td>かき</td><td>柿子</td><td>すいか</td><td>西瓜</td></tr><tr><td>きく</td><td>菊花</td><td>おかし</td><td>糕点</td></tr><tr><td>さけ</td><td>酒</td><td>すし</td><td>寿司</td></tr><tr><td>しお</td><td>盐</td><td>こい</td><td>鲤鱼</td></tr></tbody></table><h2 id="50音た行"><a href="#50音た行" class="headerlink" title="50音た行"></a>50音た行</h2><table><thead><tr><th>日文</th><th>中文</th><th>日文</th><th>中文</th></tr></thead><tbody><tr><td>たこ</td><td>章鱼</td><td>つき</td><td>月亮</td></tr><tr><td>あつい</td><td>热</td><td>レタス</td><td>生菜</td></tr><tr><td>いち</td><td>一</td><td>ちかてつ</td><td>地铁</td></tr><tr><td>テキスト</td><td>text</td><td>しち</td><td>七</td></tr></tbody></table><p>あたたかい　て　温暖的手</p><p>たいこの　たつじん　太鼓达人</p><h2 id="50音な行"><a href="#50音な行" class="headerlink" title="50音な行"></a>50音な行</h2><table><thead><tr><th>日文</th><th>中文</th><th>日文</th><th>中文</th></tr></thead><tbody><tr><td>なな</td><td>七</td><td>ナイフ</td><td>刀</td></tr><tr><td>テニス</td><td>tennis</td><td>にく</td><td>肉</td></tr><tr><td>いぬ</td><td>小狗</td><td>ねこ</td><td>猫</td></tr><tr><td>いのち</td><td>命</td><td>ぬの</td><td>布</td></tr></tbody></table><p>たかい　ネクタイ　贵的领带</p><p>おいしい　うに 好吃的海胆</p><h2 id="50音は行"><a href="#50音は行" class="headerlink" title="50音は行"></a>50音は行</h2><table><thead><tr><th>日文</th><th>中文</th><th>日文</th><th>中文</th></tr></thead><tbody><tr><td>はち</td><td>八</td><td>へや</td><td>房间</td></tr><tr><td>ほし</td><td>星星</td><td>はこ</td><td>盒子</td></tr><tr><td>ふね</td><td>船</td><td>ほね</td><td>骨</td></tr><tr><td>ひと</td><td>人</td><td>ひふ</td><td>皮肤</td></tr></tbody></table><p>ふうふう　ふいた　呼呼地吹</p><p>うつくしい はな　美丽的花</p><h2 id="50音毎日ま行"><a href="#50音毎日ま行" class="headerlink" title="50音毎日ま行"></a>50音毎日ま行</h2><p>なま　むぎ　なま　ごめ　なま　たまご<br>生　　麦　　生　　米　　生　　卵</p><p>ももも　すももも　もものうち<br>桃子    李子      都是桃科的</p><table><thead><tr><th>日文</th><th>中文</th><th>日文</th><th>中文</th></tr></thead><tbody><tr><td>ハム</td><td>火腿</td><td>トマト</td><td>番茄</td></tr><tr><td>うま</td><td>马</td><td>みなみ</td><td>南</td></tr><tr><td>みせ</td><td>店</td><td>くも</td><td>云</td></tr><tr><td>メモ</td><td>笔记</td><td>むすめ</td><td>女儿</td></tr></tbody></table><p>おもい　にもつ<br>重的    行李<br>こわい　むし<br>可怕的  虫子</p><h2 id="50音毎日や行"><a href="#50音毎日や行" class="headerlink" title="50音毎日や行"></a>50音毎日や行</h2><table><thead><tr><th>日文</th><th>中文</th><th>日文</th><th>中文</th></tr></thead><tbody><tr><td>やさい</td><td>蔬菜</td><td>いや</td><td>讨厌</td></tr><tr><td>つよい</td><td>强</td><td>ゆめ</td><td>梦</td></tr><tr><td>ふゆ</td><td>冬</td><td>うめ</td><td>梅子</td></tr><tr><td>よこ</td><td>横</td><td>やさしい</td><td>简单的</td></tr></tbody></table><p>つめたい　ゆき<br>冷冰冰的  雪<br>すきやきが　すき<br>寿喜烧      喜欢</p><h2 id="50音毎日ら行"><a href="#50音毎日ら行" class="headerlink" title="50音毎日ら行"></a>50音毎日ら行</h2><table><thead><tr><th>日文</th><th>中文</th><th>日文</th><th>中文</th></tr></thead><tbody><tr><td>さくら</td><td>樱花</td><td>ほたる</td><td>萤火虫</td></tr><tr><td>はる</td><td>春</td><td>とり</td><td>鸟</td></tr><tr><td>アメリカ</td><td>美国</td><td>あらし</td><td>岚</td></tr><tr><td>れきし</td><td>历史</td><td>ろく</td><td>六</td></tr></tbody></table><p>おふろに　はいる<br>浴池      进入  = 洗澡<br>おもしろい　はなし<br>好玩的      故事  = 有趣的事</p><h2 id="50音わ行"><a href="#50音わ行" class="headerlink" title="50音わ行"></a>50音わ行</h2><p>ひまわぃ<br>向日葵<br>かわいい<br>可爱的<br>わかい<br>年轻的<br>ちくわ<br>竹轮<br>かおを あらわない<br>脸     不洗     = 不洗脸<br>かわいい　うちわ<br>可爱的    团扇  = 可爱的扇子</p><h2 id="浊音"><a href="#浊音" class="headerlink" title="浊音"></a>浊音</h2><p>ガムをかむ<br>口香糖 嚼 = 吃口香糖<br>すずしい　かぜですね<br>凉爽的    风    啊  = 风真凉爽啊<br>ぜんぜん　じかんが　ない<br>全部      时间     没  = 一点时间也没有了<br>でぐちは　どこですか<br>出口      哪里     = 出口在哪里<br>ほしが　ぴかぴか、ふとんが　ぽかぽか<br>星星    亮闪闪    被子     暖烘烘  = 闪亮的星星，暖和的被子<br>どきどきします<br>怦然心动</p><h2 id="ん播音"><a href="#ん播音" class="headerlink" title="ん播音"></a>ん播音</h2><table><thead><tr><th>日文</th><th>中文</th><th>日文</th><th>中文</th></tr></thead><tbody><tr><td>にんにく</td><td>大蒜</td><td>さんま</td><td>秋刀鱼</td></tr><tr><td>レモン</td><td>柠檬</td><td>てんき</td><td>天气</td></tr><tr><td>まんか</td><td>漫画</td><td>じかん</td><td>时间</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 日语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
            <tag> 日语 </tag>
            
            <tag> 例句 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日语50音</title>
      <link href="/2020/10/17/ri-yu-50-yin/"/>
      <url>/2020/10/17/ri-yu-50-yin/</url>
      
        <content type="html"><![CDATA[<h2 id="平假名"><a href="#平假名" class="headerlink" title="平假名"></a>平假名</h2><table><thead><tr><th></th><th>a</th><th>i</th><th>u</th><th>e</th><th>o</th></tr></thead><tbody><tr><td></td><td>あ（安）</td><td>い（以）</td><td>う（宇）</td><td>え（衣）</td><td>お（於）</td></tr><tr><td>k</td><td>か（加）</td><td>き（机）</td><td>く（久）</td><td>け（计）</td><td>こ（己）</td></tr><tr><td>s</td><td>さ（左）</td><td>し（之）xi</td><td>す（寸）</td><td>せ（世）</td><td>そ（曾）</td></tr><tr><td>t</td><td>た（太）</td><td>ち（知）chi</td><td>つ（川）tsu</td><td>て（天）て</td><td>と（止）</td></tr><tr><td>n</td><td>な（奈）</td><td>に（仁）</td><td>ぬ（奴）</td><td>ね</td><td>の（乃）</td></tr><tr><td>h</td><td>は（波）</td><td>ひ （比）</td><td>ふ （孙）fu（读法吹气）</td><td>へ（部）</td><td>ほ（保）</td></tr><tr><td>m</td><td>ま（末）</td><td>み （美）</td><td>む （武）</td><td>め（女）</td><td>も（毛）</td></tr><tr><td>y</td><td>や（也）</td><td></td><td>ゆ （由）</td><td></td><td>よ（舆）</td></tr><tr><td>r</td><td>ら（良）</td><td>り（利）</td><td>る （留）</td><td>れ（礼）</td><td>ろ（吕）</td></tr><tr><td>w</td><td>わ（和）</td><td></td><td></td><td></td><td>を（远）（读作o）</td></tr></tbody></table><h2 id="片假名"><a href="#片假名" class="headerlink" title="片假名"></a>片假名</h2><table><thead><tr><th></th><th>a</th><th>i</th><th>u</th><th>e</th><th>o</th></tr></thead><tbody><tr><td></td><td>ア（阿）</td><td>イ（伊）</td><td>ウ（宇）</td><td>エ</td><td>オ（於）</td></tr><tr><td>k</td><td>カ（加）</td><td>キ（机）</td><td>ク（久）</td><td>ケ（介）</td><td>コ（己）</td></tr><tr><td>s</td><td>サ（散）</td><td>シ（之）xi</td><td>ス（须）</td><td>セ（世）</td><td>ソ（曾）</td></tr><tr><td>t</td><td>タ（多）</td><td>チ（千）chi</td><td>ツ（川）tsu</td><td>テ（天）</td><td>ト（止）</td></tr><tr><td>n</td><td>ナ（奈）</td><td>ニ（仁）</td><td>ヌ（奴）</td><td>ネ</td><td>ノ （乃）</td></tr><tr><td>h</td><td>ハ （八）</td><td>ヒ （比）</td><td>フ（不）</td><td>ヘ（部）</td><td>ホ（保）</td></tr><tr><td>ｍ</td><td>マ（末）</td><td>ミ（三）</td><td>ム （牟）</td><td>メ（女）</td><td>モ（毛）</td></tr><tr><td>y</td><td>ヤ（也）</td><td></td><td>ユ （由）</td><td></td><td>ヨ（舆）</td></tr><tr><td>r</td><td>ラ（良）</td><td>リ（利）</td><td>ル （流）</td><td>レ（礼）</td><td>ロ（吕）</td></tr><tr><td>ｗ</td><td>ワ（和）</td><td></td><td></td><td></td><td>ヲ（乎）（读作o）</td></tr></tbody></table><h2 id="字形相似的平假名"><a href="#字形相似的平假名" class="headerlink" title="字形相似的平假名"></a>字形相似的平假名</h2><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>く</td><td>へ</td><td></td><td></td></tr><tr><td>る</td><td>ろ</td><td></td><td></td></tr><tr><td>ぬ</td><td>め</td><td>ね</td><td></td></tr><tr><td>き</td><td>さ</td><td></td><td></td></tr><tr><td>い</td><td>こ</td><td>に</td><td>り</td></tr><tr><td>は</td><td>ほ</td><td></td><td></td></tr><tr><td>ね</td><td>わ</td><td>れ</td><td></td></tr></tbody></table><h2 id="字形相似地片假名"><a href="#字形相似地片假名" class="headerlink" title="字形相似地片假名"></a>字形相似地片假名</h2><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>エ</td><td>ニ</td><td></td><td></td></tr><tr><td>ク</td><td>ケ</td><td></td><td></td></tr><tr><td>マ</td><td>ム</td><td></td><td></td></tr><tr><td>リ</td><td>ソ</td><td></td><td></td></tr><tr><td>シ</td><td>ツ</td><td>ミ</td><td></td></tr><tr><td>ヌ</td><td>フ</td><td></td><td></td></tr><tr><td>ヌ</td><td>メ</td><td>ノ</td><td></td></tr><tr><td>コ</td><td>ユ</td><td>ヨ</td><td></td></tr><tr><td>セ</td><td>ヤ</td><td></td><td></td></tr><tr><td>ウ</td><td>ワ</td><td>ク</td><td>ヲ</td></tr></tbody></table><h2 id="浊音"><a href="#浊音" class="headerlink" title="浊音"></a>浊音</h2><table><thead><tr><th>が</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>が</td><td>ぎ</td><td>ぐ</td><td>げ</td><td>ご</td></tr><tr><td>ga</td><td>gi</td><td>gu</td><td>ge</td><td>go</td></tr><tr><td>ざ</td><td>じ</td><td>ず</td><td>ぜ</td><td>ぞ</td></tr><tr><td>za</td><td>ji(zi)</td><td>zu</td><td>ze</td><td>zo</td></tr><tr><td>だ</td><td>ぢ</td><td>づ</td><td>で</td><td>ど</td></tr><tr><td>da</td><td>ji(di)</td><td>zu(du)</td><td>de</td><td>do</td></tr></tbody></table><table><thead><tr><th>ガ</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>ガ</td><td>ギ</td><td>グ</td><td>ゲ</td><td>ゴ</td></tr><tr><td>ga</td><td>gi</td><td>gu</td><td>ge</td><td>go</td></tr><tr><td>ダ</td><td>ヂ</td><td>ヅ</td><td>デ</td><td>ド</td></tr><tr><td>da</td><td>ji(di)</td><td>zu(du)</td><td>de</td><td>do</td></tr><tr><td>ザ</td><td>ジ</td><td>ズ</td><td>ゼ</td><td>ゾ</td></tr><tr><td>za</td><td>ji(zi)</td><td>zu</td><td>ze</td><td>zo</td></tr></tbody></table><hr><table><thead><tr><th>ば</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>ば</td><td>び</td><td>ぶ</td><td>べ</td><td>ぼ</td></tr><tr><td>ba</td><td>bi</td><td>bu</td><td>be</td><td>bo</td></tr><tr><td>ぱ</td><td>ぴ</td><td>ぷ</td><td>ぺ</td><td>ぽ</td></tr><tr><td>pa</td><td>pi</td><td>pu</td><td>pe</td><td>po</td></tr></tbody></table><table><thead><tr><th>バ</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>バ</td><td>ビ</td><td>ブ</td><td>ベ</td><td>ボ</td></tr><tr><td>ba</td><td>bi</td><td>bu</td><td>be</td><td>bo</td></tr><tr><td>パ</td><td>ピ</td><td>プ</td><td>ペ</td><td>ポ</td></tr><tr><td>pa</td><td>pi</td><td>pu</td><td>pe</td><td>po</td></tr></tbody></table><h2 id="ん播音"><a href="#ん播音" class="headerlink" title="ん播音"></a>ん播音</h2><h3 id="n-た-だ-な-ら"><a href="#n-た-だ-な-ら" class="headerlink" title="[n] た　だ　な　ら"></a>[n] た　だ　な　ら</h3><p>もんだい　あんない　ほんらい<br>问题      向导     本来</p><h3 id="m-ぱ-ば-ま"><a href="#m-ぱ-ば-ま" class="headerlink" title="[m] ぱ　ば　ま"></a>[m] ぱ　ば　ま</h3><p>さんぽ　しんまい　えんぴつ<br>散步    新人     铅笔</p><h3 id="ng-其他场合及词尾"><a href="#ng-其他场合及词尾" class="headerlink" title="[ng] 其他场合及词尾"></a>[ng] 其他场合及词尾</h3><p>へんか　れない　パソコン　図書館<br>变化    恋爱   电脑      图书馆</p>]]></content>
      
      
      <categories>
          
          <category> 日语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
            <tag> 日语 </tag>
            
            <tag> 50音 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中异常特点的总结</title>
      <link href="/2020/10/16/java-yi-chang/"/>
      <url>/2020/10/16/java-yi-chang/</url>
      
        <content type="html"><![CDATA[<h2 id="程序中的异常"><a href="#程序中的异常" class="headerlink" title="程序中的异常"></a>程序中的异常</h2><ul><li>在程序运行过程中，意外发生的情况，背离我们程序本身意图的表现，都可以理解为异常；</li><li>利用Java中的异常机制，我们可以更好地提升程序的健壮性；</li><li>在Java中，通过Throwable及其子类描述各种不同的异常类型。</li></ul><p><img src="/1.png" alt="异常类树状图"></p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul><li>通过5个关键字来实现：<code>try</code>、<code>catch</code>、<code>finally</code>、<code>throw</code>、<code>throws</code></li></ul><p><img src="/2.png" alt="异常处理的几种方式"></p><p><img src="/3.png" alt="try-catch-finally结构"></p><ul><li>实际应用中的经验与总结<ul><li>处理运行时异常时，采用逻辑去合理规避同时辅助try-catch处理；</li><li>在多重catch块后面，可以加一个catch（Exception）来处理可能会被遗漏的异常；</li><li>对于不确定的代码，也可以加上try-catch，处理潜在的异常；</li><li>尽量去处理异常，切忌知识简单地调用<code>printStackTrace()</code>去打印输出；</li><li>具体如何处理异常，要根据不同的任务需求和异常类型去决定；</li><li>尽量添加finally语句块去释放占用的资源。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
            <tag> Java </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中单例设计模式的总结</title>
      <link href="/2020/10/14/java-she-ji-mo-shi/"/>
      <url>/2020/10/14/java-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul><li>一种设计经验</li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul><li><p>优点</p><ol><li>在内存中只有一个对象，节省内存空间；</li><li>避免频繁的创建销毁对象，提高性能</li><li>避免对共享资源多重占用</li></ol></li><li><p>缺点</p><ol><li>扩展比较困难；</li><li>如果实例化后的对象长期不利用，系统将默认为垃圾进行回收，造成对象状态丢失。</li></ol></li><li><p>适用的设计场景</p><ol><li>创建对象时占用的资源过多，但同时又需要用到该类对象；</li><li>对系统内资源要求统一读写，如读写配置信息；</li><li>当多个实例存在可能引起程序逻辑错误，如号码生成器。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中多态特点的总结</title>
      <link href="/2020/10/13/java-duo-tai/"/>
      <url>/2020/10/13/java-duo-tai/</url>
      
        <content type="html"><![CDATA[<h2 id="多态的分类"><a href="#多态的分类" class="headerlink" title="多态的分类"></a>多态的分类</h2><ol><li>编译时多态（设计时多态）：方法重载；</li><li>运行时多态：JAVA运行时根据调用该方法的实例的类型来决定调用哪个方法则被称为运行时多态；</li><li>平时说的多态，多指运行时多态。</li></ol><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ol><li>向上类型转换（Upcast）：将子类型转换为父类型，隐式/自动类型转换，是小类型到大类型的转换；</li><li>向下类型转换（Downcast）：将父类型转换为子类型，强制类型转换，是大类型到小类型；</li><li>通过instanceof运算符，来解决引用对象的类型，避免类型转换的安全性问题，提高代码的强壮性。</li></ol><h2 id="抽象类-amp-抽象方法"><a href="#抽象类-amp-抽象方法" class="headerlink" title="抽象类&amp;抽象方法"></a>抽象类&amp;抽象方法</h2><ul><li>应用场景：某个父类知识限定其子类应该包含怎样的方法，但不需要准确知道这些子类如何实现这些方法。</li></ul><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul><li>Java中使用抽象类，限制实例化；</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><ul><li><code>abstract</code>也可以用于方法——抽象方法。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>注意：<ol><li>抽象类不能直接实例化；</li><li>子类如果没有重写父类所有的抽象方法，则也要定义为抽象类；</li><li>抽象方法所在的类一定是抽象类；</li><li>抽象类中可以没有抽象方法。</li></ol></li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li>接口定义了某一批类所要遵守的规范；</li><li>接口不关心这些类的内部数据，也不关心这些类里方法的实现细节，它只规定1这些类里必须提供某些方法。</li><li>语法：</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//[修饰符] interface 接口名 [extends 父接口 1, 父接口2...]</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//零到多个常量定义...</span>    <span class="token comment" spellcheck="true">//零到多个抽象方法的定义...</span>    <span class="token comment" spellcheck="true">//零到多个默认方法的定义...（jdk1.8新增）</span>    <span class="token comment" spellcheck="true">//零到多个静态方法的定义...（jdk1.8新增）</span><span class="token punctuation">}</span></code></pre><ul><li>注意：<ul><li>接口可以实现多继承，即一个子接口可以同时继承多个父接口；</li><li>实现接口的类如果不能实现所有接口中待重写的方法，则必须设置为抽象类；</li><li>一个类可以继承自一个父类，同时实现(<code>implements</code>)多个接口。</li></ul></li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul><li>在Java中，可以将一个类定义在另一类里面或者一个方法里面，这样的类称为内部类；</li><li>与之对应，包含内部类的类被称为外部类；</li><li>优势：内部类提供了更好地封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类，更好地实现了信息隐藏。</li></ul><h2 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h2><ul><li>成员内部类</li><li>静态内部类</li><li>方法内部类</li><li>匿名内部类</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
            <tag> Java </tag>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中继承特点的总结</title>
      <link href="/2020/10/13/java-ji-cheng/"/>
      <url>/2020/10/13/java-ji-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h2><ul><li>将父类（基类）的属性和方法给予子类（派生类）；</li><li>一种类与类的关系；</li><li>使用已存在的类的定义作为基础建立新的类；</li><li>新类的定义可以增加新的数据或者新的功能，也可以用父类的功能，但不能选择性地继承父类；</li><li>两个类满足”A is a b”的关系是就可以使用继承。</li></ul><h2 id="继承的实现"><a href="#继承的实现" class="headerlink" title="继承的实现"></a>继承的实现</h2><ul><li>利用<code>extends</code>实现继承；</li><li>只能支持单一继承，只有一个父类。</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//子类</span>Class <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//父类</span>Class <span class="token class-name">Animal</span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><ul><li>此时父类的所有属性和方法都会在子类中存在</li></ul><h2 id="方法重写和方法重载"><a href="#方法重写和方法重载" class="headerlink" title="方法重写和方法重载"></a>方法重写和方法重载</h2><table><thead><tr><th>方法重写</th><th>方法重载</th></tr></thead><tbody><tr><td>在满足继承关系的子类中</td><td>在同一个类中</td></tr><tr><td>方法名、参数个数、顺序、返回值与父类相同、或者与父类兼容</td><td>方法名相同</td></tr><tr><td>访问修饰符的限定范围大于等于父类方法</td><td>参数个数、顺序、类型不同</td></tr><tr><td></td><td>返回值类型、访问修饰符任意</td></tr></tbody></table><h2 id="super关键字的使用"><a href="#super关键字的使用" class="headerlink" title="super关键字的使用"></a><code>super</code>关键字的使用</h2><ul><li><code>super</code>关键字主要是用来调用多参父类构造方法的。在默认情况下，实例化子类的过程中，虚拟机默认调用的是父类的无参构造方法，如果用户与要调用父类的多参构造需要使用<code>super</code>关键字；</li><li>代表父类引用；</li><li>子类对象的构造过程中必须调用其父类的构造方法；</li><li>如果子类的构造方法中没有显示标注，则系统默认调用父类的无参构造方法；</li><li>如果子类构造方法没有显示标注，且父类没有无参构造方法，系统将提示错误；</li><li>使用<code>super</code>调用父类指定构造方法，必须要在子类的构造方法的第一行。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token string">"xxx"</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是子类的无参构造方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//访问父类成员方法</span><span class="token keyword">super</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//访问父类属性</span><span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//访问父类构造方法</span></code></pre><ul><li><strong>注意</strong><code>super</code>关键字只能在子类构造方法中使用，且必须位于构造方法的第一行。</li></ul><h2 id="子类实例化时的程序执行顺序问题"><a href="#子类实例化时的程序执行顺序问题" class="headerlink" title="子类实例化时的程序执行顺序问题"></a>子类实例化时的程序执行顺序问题</h2><ul><li>总结一下来说是，父类与静态代码块先行，子类、构造代码块以及构造方法紧随其后；</li><li>父类静态成员<code>-&gt;</code>子类静态成员<code>-&gt;</code>父类对象构造<code>-&gt;</code>子类对象构造。</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/***我是父类的静态代码块*我是子类的静态代码块*我是父类的构造代码块*我是父类的多参构造方法*我是子类的构造代码块*我是子类的无参构造方法**/</span></code></pre><h2 id="this关键字与super关键字的对比"><a href="#this关键字与super关键字的对比" class="headerlink" title="this关键字与super关键字的对比"></a><code>this</code>关键字与<code>super</code>关键字的对比</h2><ul><li><code>this</code>关键字用来调用当前类允许被访问的属性和方法；</li><li><code>super</code>关键字用来调用父类当中允许被访问的属性和方法；</li><li><code>this</code>和<code>super</code>关键字都不能在静态方法中被使用；</li><li><code>this</code>和<code>super</code>不能同时出现在同一个构造方法中，一个关键字只能出现在一个构造方法中。</li></ul><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><table><thead><tr><th>访问修饰符</th><th>本类</th><th>同包</th><th>子类</th><th>其他</th></tr></thead><tbody><tr><td>private</td><td>$\checkmark$</td><td></td><td></td><td></td></tr><tr><td>默认</td><td>$\checkmark$</td><td>$\checkmark$</td><td></td><td></td></tr><tr><td>protected</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\checkmark$</td><td></td></tr><tr><td>public</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\checkmark$</td></tr></tbody></table><h2 id="Object关键字"><a href="#Object关键字" class="headerlink" title="Object关键字"></a><code>Object</code>关键字</h2><ul><li><code>Object</code>类是所有类的父类；</li><li>Java中的每一个类都可以使用<code>Object</code>中定义的方法。</li></ul><pre class=" language-java"><code class="language-java"><span class="token function">equals</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h2 id="final修饰符"><a href="#final修饰符" class="headerlink" title="final修饰符"></a><code>final</code>修饰符</h2><ul><li>修饰类表示不允许被继承；</li><li>修饰方法表示不允许被子类重写；</li><li>修饰变量表示不允许修改；</li><li><code>final</code>修饰的方法可以被继承；</li><li>引用类型的变量：初始化之后不能再指向另一个对象，但指向的对象的内容是可以变动的；</li><li>可以配合<code>static</code>使用。</li></ul><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><ul><li>可以声明在包、类、属性、方法、局部变量、方法参数的前面，用来对这些元素进行说明、注释。</li></ul><table><thead><tr><th>按照运行机制分类</th><th>按照来源分类</th></tr></thead><tbody><tr><td>源码注解</td><td>来自JDK的注解</td></tr><tr><td>编译时注解</td><td>来自第三方的注解</td></tr><tr><td>运行时注解</td><td>我们自己定义的注解</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
            <tag> Java </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Approximate Computing. A Survey</title>
      <link href="/2020/10/12/lun-wen-fan-yi/"/>
      <url>/2020/10/12/lun-wen-fan-yi/</url>
      
        <content type="html"><![CDATA[<ul><li>尽管半导体科技以及能效设计技术在不断发展，但是计算机系统为了处理不断增加的信息，整体的能耗仍然在以令人担忧的速度不断增长。尤其是，随着计算机系统普及开来，计算机系统就用来与物质世界做交互同时用来处理从不同地方获取到的大量信息。此外，我们还希望它们能够识别不同的语境并且提供一种自然的人类接口。因此，出现了大量的应用，主要包括识别应用、挖掘应用以及综合应用，这些应用构成了从移动端和物联网设备到数据中心之间计算资源的一个重要组成部分。<br>为了能够跟上需要处理的信息发展速度，极大地改善这些新兴出现的设备的能耗效率是很有必要的。幸运的是，这些应用一般来说有一个内在的错误恢复的性质。它们处理一些冗余并且有噪声的数据，这些数据来自于一些非传统的输入，例如，不同的种类的传感器（非精准输入），并且一些相关的算法在本质上通常是随机的（例如，迭代算法）。此外，这些应用通常不需要计算出一些独一无二的或者非常精准的结果（结果一般来说要求是可以接受的而不是精准的）。例如，在多媒体处理中，由于人类有限的感知能力，一些偶然的错误，例如，丢失某一个帧的数据或者说一个小的图像质量损失都很少影响到用户的体验。以数据分析中的一个情况作为另一个例子，考虑有两个不同的分类器，这两个分类器对同一个数据集会产生类似的分类结果。鉴别哪一种分类器用于分类新事物的效果更好是非常困难的。<br>另一方面，随着半导体科技进一步进入了纳米的时代，为了保证没有错误的运算是需要消耗非常多的功率的。这是因为在低电压和不断增长的集成密度的情况下，电路对先进技术节点的参数变化和故障更为敏感。传统的无差错计算为了可接受的误差和错误校正，需要在不同层的设计层次结构中加入防护带宽以及一定的冗余量，这一点导致了巨大的能源开销。<br>受到上述的挑战的激励，一个有前途的解决方案吸引了来自工业界和学术界的目光。通过放宽错误容忍应用的指标和实际之间的等效范围，近似计算故意把可接受的误差引入计算过程并且保证了巨大的能效降低的收益。考虑到传统的Dannards缩放定理（随着MOSFET面积不断变小，由于单位面积的功耗是固定的，因此功耗与MOSFET成比例）说明集成电路生产技术进步带来的功耗收益越来越少，利用近似计算来实现功耗的降低已经越来越重要。<br>近几年来，在不同计算层次中的不同的近似计算技术已经在各种论文中被称述了。<strong>此篇文章的目的有两个。第一，我们提出一些现有的近似计算工作的观点并且通过一篇对文献综述巩固现有的一些结果和见解。请注意，我们并不会对文献进行一个完整的综述，而是对技术发展水平的一些关键方面进行阐述。第二，我们很重视开放的挑战并且讨论了一些未来的研究方向。通过与最近的一些综述作对比，我们的分类和组织结构是完全不同的并且我们的视角由于遍布整个计算层次所以也更宽。<br>此文剩下的内容是按照如下进行展开的。近似计算范例部分主要概括了近似计算的范例。在近似软件、近似结构以及近似电路板块，我们调查并且巩固了一些技术，这些技术主要与如下内容相关，近似软件开发，近似结构探索以及近似电路设计，我们对每一个方向的技术都有所覆盖。最后，我们在挑战和未来研究方向板块，提出了一些挑战并且指明了未来在近似计算方向中的研究方向。</strong></li></ul><h2 id="近似计算范式"><a href="#近似计算范式" class="headerlink" title="近似计算范式"></a>近似计算范式</h2><p>计算已经进入了一个近似的时代，在这个时代中硬件和软件生成和推理估计。导航应用通过GPS传感器的硬件，估计出地图和位置，把这些信息转换为驾驶的方向信息；语音识别把模拟的信号转换为一个最为可能的语句；搜索引擎软件把搜索请求转换为信息。这些复杂的系统需要及其精巧的算法才能够大规模地、尽快地、低功耗地给出足够好的结果，在这一过程中，往往近似计算是唯一一个能够达到上述目标的方式。在这一个板块中，我们简短地来看一下近似计算的范例。<br>对于已经给定的可以容忍一定错误的应用，应用近似计算的一个整体的框架在图1中显示出来。框架中的关键组成部分如下所述。<br><strong>近似内核</strong>。近似内核指的是那些用来实现近似计算以达到减少功耗目的的技术。通常来讲，有两种不同种类的近似计算内核。在硬件层面，我们要么可以用一些不那么精准的但在功效方面表现更好地电路来实现计算或者有意图地减少一些硬件部分的电源电压来在功耗和精准度之间做平衡。在软件层面，我们可以选择性地忽略一些特定的计算或者或者存储器的访问，这些计算或者存储器访问对最终的用来实现相同目标的应用质量没有关键的影响。<br>从软件层面到电路层面的一些代表性的近似计算内核描述在表1中。  </p><p><strong>弹性识别和特征</strong>  即使是一些能够容忍错误的应用，对错误敏感的部分使用一些非精准的计算会引起一些致命性的错误。因此，部署近似计算关键的一步就是去识别哪些弹性错误部件可以被用来使用近似计算。<br>弹性识别对的一种方法是标记应用或者使用精心设计的近似数据类型来表示哪些位置可以用来实现近似计算以及它们会如何影响结果。另外，我们可以把应用分成好几个部之后，来实现每一个部分的敏感度分析。有一部分部件可以被很容易地分类为敏感的或弹性的。对于那些剩下的部分，我们可以通过注入错误和仿真的方法来评估近似计算对他们的影响。如果某些部件在注入错误时，应用崩溃了或者说产生了一些不可接受的结果，那么这个部分就可以被标注为错误敏感的；反之，它就是弹性的。然而，如果仿真不够充分，这种方法也有可能是有风险的因为仿真有可能没能够捕捉到一些情况，在这些情况中，崩溃的数据所产生的的效果没有被立刻显示出来。<br>在弹性识别之后，我们需要描述不同近似方法对于不同弹性部件所产生的影响，那么这通常是通过使用一些仿真技术或者说让部件执行一些代表性的工作。注意，由于实际生产环境中在系统上执行的工作有可能会和仿真的有所不同，为了保证最终的应用质量，去做一些动态质量管理的工作往往是很有必要的。<br><strong>质量管理</strong>  在动态质量管理中，我们评估中间每一步的计算质量（最好是通过应用定制的轻量型检查器）并且决定在运行时的什么时候要使用近似计算方法以及对应的近似模式。<br>SAGE和GREEN在每N次对近似计算内核调用之后立刻检查输出的质量，在这之中，他们对比了近似计算和精准计算之间的质量并且相应地调整了接下来计算需要使用的的近似模式。很显然，通过这样一种质量采样的策略，质量检查得越频繁，最终应用质量的可靠性就越高，但是能耗也随之升高。另一方面，利用这种模式对每一次内核调用都进行监视也是不现实的，因为这种方式违背了近似计算的初衷。<br>上述的质量采样定理有一个重要的问题那就是我们绝无可能保证那些没有被检测到的输出质量的好坏。因此，连续的质量检测是更好的一种方法。毫无疑问，只能使用小开销的检测器，只有这样才不至于使从近似计算中获得的好处消失。受到大型认知性预测工作的启发（例如分支预测和值预测），一些在近似计算中使用的质量预测期被很多文献提出。在[21]中，Ringenburg和他的同事们介绍了一种所谓的模糊记忆的技术，这种技术记录了被检测代码先前的输入和输出并且也通过先前类似输入的记录来预测当前执行的输出内容。近似的质量是通过检测预测结果和实际结果之间的差距，从而被估计出来。Rumba通过观察近似加速器对的输出和输入，从而构建了多种简单的错误预测模型。如果一个很大的近似错误被检测到的话，那么需要进行精准计算来实现对错误的校正。<br>在接下来的板块中，我们将会详细讨论不同计算层次中使用的近似计算方法。  </p><h3 id="近似软件"><a href="#近似软件" class="headerlink" title="近似软件"></a>近似软件</h3><p>一个好的编程语言需要让编程人员变得更加高效。这种编程语言能够让编程人员迅速地表达他们的想法同时也要让编译器和运行时系统能够优化程序的执行过程。编程语言和他们的实施平衡着编程者的效率和系统的有效性。<br>编程语言是通过“抽象”这一方法来实现对两者的平衡的。抽象能够让程序员表达完成一个任务该做什么而不是该怎么做。这种怎么做——或者说是抽象的一种具象——是留给编译器和运行时系统去完成的。<br>简历精巧的应用是非常难得并且需要系统全栈的技术，在这个近似的时代下，这些技巧包括统计学（或者一些其他的意识到近似的推导）以及特定应用层面的知识。许多学者提出抽象这个概念来帮助程序员来完成这项烦人的工作也不足为奇了。这种抽象帮助程序员在程序（例如有近似意识的编程语言）中表达自己的想法，让分析引擎推导程序的正确性（例如有近似意识的分析），并且让编译器产生机器码（例如有近似意识的编译器）。<br>接下来的板块主要描述了最近学术界和工业界在有近似意识的编程语言、分析以及编译器这几个方向上取得的成果。</p><h3 id="有近似计算意识的编程语言"><a href="#有近似计算意识的编程语言" class="headerlink" title="有近似计算意识的编程语言"></a>有近似计算意识的编程语言</h3><p>有近似计算意识的编程语言让程序员能够表达在哪里和有多少随机性能够影响到他们的结果。在1979年，Kozen意识到符号和语义对于那些在执行过程中有随机性的程序是很有必要的。这项早期工作的目标是使用编程语言通过概率结构来确定程序的含义。这项工作给一个简单的概率语言提供了两种语义——一个是给采样建立模型，还有一个是直接计算概率分布——然后还证明了它们是等效的。这个结果表明了接下来的工作可以直接用采样来近似计算概率分布。<br><strong>程序中随机性的表达</strong>  大量的后继研究工作中的语言让程序员能够表达多大的随机性会影响到他们的程序。例如，程序语言比方说Eon，EnerJ以及Rely把近似通过编程语言的符号提供给程序员。考察EnerJ和Rely这两种语言，它们让程序员能够用近似类型的信息来注释他们的程序。在EnerJ中程序员必须显式地把近似类型转换为精确类型，然而在Rely语言中，编译器尝试去从统计角度来推理一个近似的类型怎么转换为其他类型。<br>库函数，比方说Uncertain，提供了一种抽象，这种抽象把近似的数据封装在标准的面向对象编程语言中，并且通过运行时的程序变量来传递数据。当一个程序需要利用近似数据时，Uncertain运行时利用假设检验来作出统计意义上正确地分支决策。<br>有近似意识的编程语言的关键挑战是把这个推理过程尽可能自动化从而程序员不需要理解很多关于近似计算如何会影响他的程序的准确性的细节。<br><strong>通过概率编程进行推断</strong>  大量的工作尝试通过建立一个由Kozen提出的理论结构体的方式来解决这个问题。概率编程语言把概率的语言叠加在现有的编程语言。这些语言的主要目标是用观察到的事实对概率推断的有效实施然后根据事实推断程序中变量的概率分布。全为的概率编程案例解决了如下问题，“给定机器草是湿的这一事实，需要判断产生这一现象的原因是因为下雨还是因为洒水车撒的水？”。作为一个概率的程序，程序员需要把这个概率模型描述出来，或者需要把程序中变量之间的关系描述出来（例如，下雨的可能性以及当下雨的时候，人们不太可能会用洒水器），之后，给定一个现象（例如，草是湿的），之后，概率编程运行时会依据给定的现象或条件推断出魔性的各种性质。<br>这些编程语言吧推断的细节抽象出来，也因此这些语言被机器学习专家们用来建立他们的模型。概率编程语言在推广概率推断这方面取得了重要的进展；他们让机器学习专家把他们的模型转换成代码，并且通过概率推断提出复杂的需要大量计算的关于模型的问题。总体来说，概率推断问题是NP问题，是比较难的问题，并且大多数概率编程语言学术研究都是在研究如何让概率推断变得效率更高。<br>一些概率编程语言，例如Church，可以在他们支持的所有分布上做概率推断。其他的概率编程语言牺牲表达性来换取性能，还限制了他们所支持的分布，这也因此让概率推断更容易处理也更加高效。Infer.NET使用多种近似推断引擎以及精确推断引擎，每一种推断引擎都会有不同的限制。<br>举一个具体的例子，考虑一个简单的在LINQ中的概率编程实现，在这种实现中，开发者把概率程序和程序的推断表达为一个LINQ请求。在列表1a的第一个程序提供了一种二项分布的实现方法，第二段程序说明了通过一个LINQ中的<code>where</code>语句，如何增加条件——或者说是事实。这些程序使用LINQ来美剧所有抛硬币的可能性，并且求出边缘概率分布是概率推断的任务，边缘概率分布可以把程序输出映射为可能性。例如，运行<code>Inference</code>将会导致一个结果。<br>这个简单的案例清晰地表明了概率推断中间的一些难点，对于所有的那些小型应用来说枚举一个程序中所有的可能路径是不现实的（这种推断的实施在随机原语的数量上呈指数增长）。对于概率编程的深入理解是：（1）让程序员可以简易地表达一个概率程序，在此基础之上一个运行时可以高效地开始做推理的工作而不是把程序所有的可能性全部枚举一遍。概率编程的社区对这个目标实现了突破，在这个程度上，推理可以成为一种抽象，这种抽象把近似结构和和为近似结构定制的程序统一为一个整体。换句话说，给定一个程序推断，可以让我们推断出一个结构必须提供的可分配的近似硬件范围，从而能够保证某种性质的正确性以及程序的质量条件限制。  </p><h3 id="有近似意识的分析"><a href="#有近似意识的分析" class="headerlink" title="有近似意识的分析"></a>有近似意识的分析</h3><p>分析的目的是为了建立程序某个部分语义的模型或者理解部分程序的语义。可能性建模被广泛用在计算机系统对的设计和分析，并且在近几年已经越来越重要。这个部分主要简述了这个领域的最近的工作。<br><strong>模型的检查</strong>  概率模型的检查是一种自动化的程序，这个程序是为了确定一个一个需要的性质是不是已经被加载到概率系统之中。传统的模型检查器让程序员正式地描述一个状态转移的系统（通常以时序逻辑的形式被表达出来）并且模型检查器提供了系统性质的正式保障。相反，一个概率模型检测器需要程序员来用概率来确定系统的状态变化并且因此提供了概率上的保障。现在比较流行的工具MRMC和PRISM已经在多个领域中使用了，应用场景覆盖了从分析无线协议的源代码中的错误到在自动驾驶中给人类司机行为进行建模。<br><strong>概率准确度</strong>  相似地，一些研究把一些更加传统的程序分析方法应用到了概率领域。例如，在给定两种非常相似的输入的前提下，概率静态程序分析方法计算了大输出偏离的可能性边界值。这些分析推断出在近似硬件上工作的软件通过有精确意识的改变发生了变化，并且可以接收不确定的输入。相似地，动态程序分析通过一些有代表性的输入，使用程序估计了大输出偏差的可能性。<br>近似，有可能通过近似硬件和编译器变形实现，或者通过让运行时来平衡应用的准确性以及功耗和性能来实现。最近著名的工作研究了最优化以及或变化，这些在精确度的限制下最优化了功耗。这一种探索通过动态测试完成或者在统计上减少为一种优化问题，之后使用线性或者整数数学算法即可完成。  </p><h3 id="有近似意识的编译器"><a href="#有近似意识的编译器" class="headerlink" title="有近似意识的编译器"></a>有近似意识的编译器</h3><p>有近似意识的编译器除了有近似意识的编译器，也可以使用近似（推断的或者说显式表达的），来自动转换并且因此改变了程序的语义，从而牺牲程序结果的准确性来换取更好的性能或者更低的能耗。例如，循环渗透技术是一种软件上的技术，这种技术修改了程序，从而让程序执行更少的迭代，也因此让程序跑得更快。一个编译器可以把确定那一部分需要使用近似计算完成的工作自动化。相似地，Stoke减少了编译时浮点数运算的位宽，牺牲精确度来换取性能。Sampson和他的同事们阐述了如何通过对值得概率分布，从程序对值的实际操作中提取程序的语义。因此，他们采用了一种变形，这种变形并不遵循原始程序的语义，但是在统计上维持了原先程序的语义，并且表明了这些变形显著地提升了程序的运行时速度。最后，Schkufza和他的同事们介绍了一种“随机超级优化”的方法，这是一种利用蒙特卡洛马尔科夫链来寻找没有循环的86代码中可以被优化的空间。他们的编译器并没有在产生代码的时候就引入近似计算，而是使用了一种近似的方法来产生快速的代码，而不需要编译器知道任何x86代码的语义，仅仅需要知道如何加入、修改以及删除单独的x86代码。  </p><h2 id="近似计算的架构"><a href="#近似计算的架构" class="headerlink" title="近似计算的架构"></a>近似计算的架构</h2><p>一个计算机系统的关键硬件组成部分是处理器、内存以及存储器。对于这些硬件组成部分，电脑架构师们想要在给定例如面积以及功耗的技术指标的各种限制前提下，平衡性能与功耗。对于内存以及存储器，架构师们尝试去平衡密度（或者说是没比特的成本）和性能。<br>但是，同时优化这些部件的性能、能耗以及密度是非常困难的，因为通常是以牺牲另一个指标的前提下提升的某个指标。例如，一个激进乱序的的构建技术提高了处理器的性能，但是因为电路和微结构复杂性的增加，使功耗大幅上升。另外，内存和存储器的密度越大，计算机读写信息的速度就越慢。<br>近似计算的出现引入了另一个可供考虑的折中的方向，那就是计算的质量与性能、功耗以及密度之间做平衡；略微牺牲计算的质量可以提高性能或功耗或密度。<br>这一个板块主要介绍了最近的一些工作，这些工作提出了一些利用近似计算来用计算质量换取能效或性能这样的一种基于处理器、存储器或者内存的子系统架构。  </p><h3 id="近似处理器"><a href="#近似处理器" class="headerlink" title="近似处理器"></a>近似处理器</h3><p>支持近似计算的处理器架构可以被分为两个不同的类。第一个分类中的处理器主要目的是为了给那些在跑在通用处理器上的通用代码提供近似支持，这些通用处理器在高效地在近似模式下，执行一些指令或者或者代码块。另一种近似处理器把可近似计算的程序段或者传统代码变形为一种类似神经网络的算法，使它能够在加速器上运行。这两种处理器都是需要编译器或者程序员来识别或者标注可以被近似的代码段。<br><strong>使用增强型通用处理器的近似计算</strong>  在使用增强型通用处理器的近似计算中，需要分析传统的代码，并且代码块或者指令的精确计算部分以及可近似部分需要被标注出来，就像近似计算软件板块说的那样。因此，可以做出不同的微架构的选择来高能效地执行一些可近似的指令或代码块；可近似的指令或代码块可以被一些高能效但不可靠的数据通路以及在粗或者细调节状态下的核心执行。<br>对于那些细粒度近似计算，一个指令集架构定义了一系列特殊的指令，这些指令让编译器能够表达什么东西可以被近似而不需要解释如何进行近似。为了避免一些动态错误检查以及错误恢复的开销，这种指令集架构的目标就是提供一种严谨的近似程序风格。之后，微架构可以从一系列近似技术中选择一个而不需要把他们暴露出来。总的来说，近似技术可以被分为运行时近似技术以及设计时近似技术。例如，一个编译器可以提供既精确又近似的数据通路，就像图2中描述的那样。近似数据通路可以使用一个工作在加强电压上的电压或者是工作在有精度限制的特殊设计的数据通路。<br>对于那些粗粒度近似计算，可近似的程序段可以被加载到处理器中那些高能效但不怎么可靠的核心，之后结构性的的选择与细粒度近似计算中非常相似，在运行时和设计时选用那些不可靠但高能效地核心。例如，一个处理器由均匀同质的核心组成，这些核心中的部分被设计来通过牺牲计算精度以及偶尔的计算错误来实现高能效。<br>这些之前讨论的处理器架构可以被很容易地在一些包含近似指令与近似程序段的传统的应用被采用，但是它们的能效好处是有限的因为受到了传统的冯诺依曼处理器架构的限制——冯诺依曼架构采用的是指令存取与控制，数据在处理器内存结构之间交换以及处理器中所有时序部件时钟是统一的。尽管这些部件的能耗可以通过近似计算或者容许错误降低，但他们能耗仍然是现代通用计算机最主要的能耗。<br><strong>通过算法变化来实现近似计算</strong>  一个数据或计算密集型的近似代码段可以通过一个鹦鹉变换（parrot transformation）被转换为一个被神经网络启发的一个算法，例如人工神经网络（ANN），从而进行更高效地进行处理。变换的代码主要是被加载到神经网络加速器中国，这些加速器由一个主加速器耦合起来，见图3。编译器通过调用神经网络硬件自动地实现这一系列的神经变换以及自动决定那一部分代码可以被近似计算，这些神经网络硬件加速了线程的速度。因为神经网络类的算法其内在是对错误弹性的，神经网络加速器可以以不同方式被架构和优化，为了能够实现最好的能耗。神经网络加速器板块讨论了不同的底层实施以及它们的优势和劣势。  </p><h3 id="近似内存以及存储器结构"><a href="#近似内存以及存储器结构" class="headerlink" title="近似内存以及存储器结构"></a>近似内存以及存储器结构</h3><p>近似内存以及存储器结构设计主要牺牲数据的质量来换取（1）更小的芯片及内存芯片，这些芯片可以工作在更低的工作电压以及提供对于粒子撞击的更强的保护（2）更低的DRAM能耗（3）更快的固态内存，这些固态内存能够有更长的寿命（4）更大的内存通道带宽。<br><strong>内存</strong>  当工作电压低于某一特定值的时候，一些芯片级的SRAM单元就不能工作了，这一点确定了整个芯片的最低工作电压以及限制了最大的功耗。更进一步，SRAM单元非常容易受到粒子流撞击的影响。因此，为了能够获得一个更低的工作电压以及对粒子流撞击更强的保护，需要一个有更多更大晶体管的更大的SRAM单元。但是用大SRAM单元来构建芯片级的SRAM内存的成本在很多方面都很高。为了能够在内存上降低成本，如果对于一些不重要的数据在精度上的要求可以放松的话，可以给最低位的数据使用一种小的SRAM单元。这种设计技术可以仅通过可以被忽略的计算质量损失来显著地减少芯片级内存在空间和能量上的损耗，同时提供相同程度的对粒子流撞击的保护。<br>DRAM刷新的操作构成了DRAM芯片功耗的主要损失部分来源，刷新率通常取决于一小部分的比较弱的单元。为了减少DRAM的能量损耗，一个间隔更长的刷新率被应用到DRAM的列上，这些部分存储了一些错误弹性的数据（可以近似的数据）。因为采用间隔更长的刷新率的话，仅仅很少一部分的单元会出现错误，这对于计算质量的影响可以忽略不计，但这一技术大大降低了DRAM刷新消耗的能量。<br><strong>存储器</strong>  固态内存可以让我们从一个存储单元中读写多种状态。但是为了精确地从一个单元中读取更多的状态，这是非常困难的。另一方面，如果精度要求可以被忽略，并且偶尔的不精准可以被忍受的话，这些状态可以被更容易地读写。这种固态内存的性质可以被利用来在更短的延迟内，读写对错误弹性的数据。这一种技术可以通过牺牲某些数据的质量，显著地降低内存的延迟。更进一步，对错误弹性的数据可以被存在代码块中，这些代码块已经被损坏，并且通过优先提供错误纠正的硬件资源给更加重要的那些已经损坏的为来控制那些不可能被校正的数据位。这种技术可以通过引入可以忽略的数据质量丢失来延长内存的寿命。<br><strong>互联</strong>  新兴的应用都是数据密集型的，因此也需要比较大的内存带宽。为了增加内存带宽，必须增加数据传输速率或者内存通道的数量，但是这是非常困难的以内由于严格的针脚和功率限制。为了更加高效地使用给定的数据带宽，数据可以在送入存储器信道之前/后被压缩/解压缩。这种方法通常采用一种无损压缩算法但是它所能带来的好处（即，有效数据传输速率）经常被有多少给定的数据可以被压缩所限定（即，压缩比）。为了更进一步1改善压缩比，从而进一步改善数据传输速率，我们可以采用一种有损的数据压缩算法来处理一些对错误弹性的数据因为这一部分数据的精度损失是可以接受的。</p><h2 id="近似电路"><a href="#近似电路" class="headerlink" title="近似电路"></a>近似电路</h2><p>对于一个给定的电路来说，我们通过降低它的电源电压来降低能耗而不需要降低其对应的工作频率。可以利用这种所谓的过缩放技术来实现近似计算。但是，这种由于过缩放导致的数据通路的时序错误往往会导致非常巨大的计算错误，除非利用一种缩放友好型的方式来设计电路。但是，即使是利用了这种缩放友好型，在能耗上取得的收益相对来说非常少。因此，文献提出的主要的近似电路方案转向了功能上的近似，在这种发难中电路的原始功能就被有目的地设计，为了在功耗与准确性中寻找到一个折中。<br>在这个板块中，我们首先介绍了不同的近似算术单元设计，这些设计通常是手工设计的以你为他们有着很广泛的应用以及充分研究过的结构。接着，我们讨论了给通用逻辑电路近似的近似综合解决方案。最后，我们引入了一种神经网络加速器，这种加速器可以获得巨大的能耗收益。  </p><h3 id="近似算术单元"><a href="#近似算术单元" class="headerlink" title="近似算术单元"></a>近似算术单元</h3><p>因为加法器是RMS应用中的关键算术电路，许多文献已经提出了很多近似加法器的设计。Jiang和他的同事们给出了一种在该领域近期工作的对比点评。我们会在加下来介绍一些有代表性的近似加法器设计。<br>在某种文献的设计中，一种晶体管级的近似设计被用来设计近似加法器单元。把这种加法器与传统的镜像加法器单元作对比，我们会发现最激进的一种近似实现的布局面积仅仅是传统加法器的三分之一。为了保持一种合理的输出质量，这种加法器仅仅可以用在最低位的加法这种。在Kim和他的同事提出的一种进位舍弃加法器中，这种加法器用了分割方法去吧进位传播链分割为几个部分，并且每个部分的计算时基于由低位的部分传递来的进位信号进行的，这种进位信号是通过低位的部分的位来估计出来的。<br>因为不同应用在运行时对精度的要求有可能有巨大的区别，最好是使用一种精确度可以配置的近似计算单元设计。工程师可以把原先的加法器分割为好几个子加法器，之后合并子加法器的部分和，从而产生最终的结果。为了减少错误，引入了一种错误检测和校正单元，我们可以通过控制在计算过程中校正数量的多少来配置运行时的准确度。例如，在Ye和他们的同事提出的一种方案中，一种可配置的近似加法器设计可以做到逐步降低计算的质量，在他们的方案中，近似计算错误可以被最高位和最低位校正。图4中，这种加法器包括了几个k位的子加法器，这些加法器的进位可以选择从更低位的加法器进位获得或者从预测部件中获得。通过设置子加法器的长度并且控制多路选择器的信号，加法器的精度不仅是可调节的，并且更重要的是，它可以逐步地降低精度，因此可以获得一个更好的对于计算质量和实现困难程度上的折中。<br>另外一个非常重要的用在计算中的计算单元是乘法器。在这个领域中已经有了部分工作成果，并且基本的设计原则与近似加法器的设计原则类似。一个高能效地乘法器是由2*2的近似乘法器构成的，在这种乘法器在[52]中被提出来。在[53]中，提出了体用近似加法器来组建一个可以配置计算精度的近似乘法器。  </p><h3 id="近似电路综合"><a href="#近似电路综合" class="headerlink" title="近似电路综合"></a>近似电路综合</h3><p>当我们可以为了通用逻辑电路，手动地用一些知名结构来设计一些近似加法单元，最好是利用一些自动化的综合技术来简历他们的近似方案从而能够降低设计繁琐程度。<br>不像算术单元，没有一种可以被广泛采用的近似电路的误差模型。因此，这项工作的关键难点在于近似综合如何能够高效地表示出算术质量限制条件并且把他们高效地带入综合过程。<br>早期这个领域的设计采用了一种非常简单的误差模型。综合的问题被等效为这样的一个问题，给定一个错误率的限制条件之后，寻找到一种能够在最小面积下实现的近似方案。之后，错误率和误差程度都被考虑了进来，在这个过程中，为了解决这个问题一种两步式方案被提了出来。在第一阶段中电路仅仅是在错误程度的限制下进行综合。之后在第二阶段中，获得的电路需要进行不断地迭代优化来满足错误率的限制。SALSA把计算质量限制编码为一种虚拟逻辑函数并且用“Approximation don’t care”来简化电路，这种想法源于对于计算质量的宽限。通过这种方法，设计者可以明确额更加复杂的计算质量限制条件。另一个SALSA的优势是它可以为了近似电路综合，复用那些不再使用的逻辑综合工具。上述的技术主要应用在近似组合逻辑之中。ASLAN能够综合近似时序逻辑，它是通过利用虚拟时序计算质量限制条件电路来通过扩展SALSA实现的。<br>近期Tazdanbakhsh和他的同事们提出了一系列Verilog语言中的标记，把它命名为Axilog来实现近似硬件设计。Axilog能够让设计者来近似设计中的某个部分，并且同时还能保证关键部分的计算精度。虽然这个语言有很大的潜力，但是如何在逻辑综合中高效地利用这种语言扩展仍然是一个未探索的问题。<br>最后，最近也有一些学者尝试开发更高层次的近似电路综合工具，在这些方案中，运算符变形、位宽优化以及有近似意识的列表规划这几种方法都用来实现电路简化。  </p><h3 id="神经网络加速器"><a href="#神经网络加速器" class="headerlink" title="神经网络加速器"></a>神经网络加速器</h3><p>神经网络在本质上是一种通用的近似函数。随着近似计算范式的出现，他们被提出来，来加速一些对错误弹性的应用。一大部分工作主要研究神经网络的硬件实现，并且他们可以通过数字逻辑、模拟信号或者混合信号电路进行实现。总的来说，数字实现提供了一种高精度更高可靠性的解决方案，模拟信号和混合信号在结构上更为紧凑并且在能效上更高效。需要注意的是模拟电路好混合信号电路的实现以及通过科技缩放来获得好处要比数字电路更为困难。因此，为了确定神经网络加速器的模拟实现方法是否比数字实现更为优秀，需要通过一个非常彻底的研究来决定，这是因为不同的大规模集成电路的可集成性以及可生产性产生的实际的问题。<br>最近，一种通过记阻元件实现的RRAM的横梁结构阵列获得了大量的关注因为这种设备可以实现超级大的集成密度。因为这种技术可以自然地近似矩阵向量的乘法而不需要实际的计算，我们可以利用这种元件来实现近似计算。当把这种元件与它的同样功能的数字实现进行对比时，这种方案能够产生数量级上的优势。尽管这种技术有很大的潜力，基于RRAM的系统仍然面临了诸多挑战。首先，在基于RRAM的模拟数据处理单元以及剩下的系统之间的接口的能耗开销是非常大的，这种超大能量开销会把近似电路缩小的功耗补偿回来。第二，RRAM设备的非理想因素，例如信号的波动以及处理偏差让近似计算的质量更加困难</p><h2 id="挑战以及未来的研究方向"><a href="#挑战以及未来的研究方向" class="headerlink" title="挑战以及未来的研究方向"></a>挑战以及未来的研究方向</h2><p>当近似计算在近些年获得了非常多的关注，这个领域仍然处在发展的初期。目前的解决方案主要集中在硬件或软件的单一层面的技术栈中，并且大多数的的工作仅仅是一些应用面比较狭窄的方案。然而，不像过去硬件软件可以通过一个稳定的统一接口（即，ISA指令架构）互相独立地产生进步，如果应用不能够有效地把自己的精度需求与底层的硬件进行沟通并且在运行时监控运算质量的话，寄希望于系统能够在给定质量限制条件下获得预期的能耗收益是不现实的。仍然有部分研究尝试去构建近似计算新的硬件或软件接口，但是这种通用的解决方案通常把包袱丢给程序员来保证应用的质量因此也阻碍了这些方案的实际落地。<br>并且，软件工程——构建复杂可靠地代码——被抽象和成分构成实现，这是通过布尔代数和其他的工作来实现的。我们仍然没有一个等小的方法来明确、描述以及推理不可靠的硬件单元、APIs或者更高层次的库函数，这些东西能够产生一些不确定的结果。例如，许多近似计算的工作目前为止证明了输出图像并且询问读者来根据主观上判断画是不是足够好来进行评分。尽管这能够实现终端用户的认知学习，但它仍然没有对系统产生一个正式的推理。为了应用科学上的和工程上的方案来设计、优化以及生产近似计算系统（从硬件上以及软件上），我们仍然需要来把终端用户的认知标准转化为一种可定量可测试的每一个部件以及他们的解决方案的指标的接下来的几个问题。第一，一个芯片生产商如何能够确定生产线上的产品的一个部分符合了交货的标准？（或者说保证了某个确定部分的的近似计算的质量）。第二，硬件应该如何被描述？第三，软件应该以来哪一种架构上的保证？第四，数据库的API函数应该如何被确定，从而能够实现错误的引入或者把错误从输入传递到输出？最后，哪一种程序设计语言以及工具能够捕捉到编程者的意图并且帮助他们来实现一个需求？<br><strong>总结一下</strong>  目前近似计算的的工作在某些领域有重大的前途，但是仍然需要重大的革新以及研究工作来使近似计算称为一个实际可用的主流计算范式。</p>]]></content>
      
      
      <categories>
          
          <category> 集成电路设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文翻译 </tag>
            
            <tag> 近似计算 </tag>
            
            <tag> 文献综述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中构造方法的总结</title>
      <link href="/2020/09/30/java-zhong-gou-zao-fang-fa-de-zong-jie/"/>
      <url>/2020/09/30/java-zhong-gou-zao-fang-fa-de-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="构造方法的特征"><a href="#构造方法的特征" class="headerlink" title="构造方法的特征"></a>构造方法的特征</h2><ul><li>构造方法必须与类的名字相同，可以带有和不带有参数，没有返回值;</li><li>构造方法必须有访问修饰符，没有返回值类型;</li><li>只能在对象实例化的时候调用;</li><li>当没有指定构造方法时，系统会自动添加无参的构造方法;</li><li>当有指定构造方法时，无论是有参数还是没有参数的构造方法，都不会自动添加五参数的构造方法;</li><li>一个类中可以有若干个构造方法;</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> 构造方法名<span class="token punctuation">(</span>可选参数<span class="token number">1</span><span class="token punctuation">,</span>可选参数<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//初始化代码</span><span class="token punctuation">}</span></code></pre><h2 id="构造方法使用的注意事项"><a href="#构造方法使用的注意事项" class="headerlink" title="构造方法使用的注意事项"></a>构造方法使用的注意事项</h2><ul><li>构造函数有<strong>两种</strong>办法给新实例化的对象的属性赋值。构造函数内如果要调用实例化的参数属性，需要使用<code>this.属性</code>的形式来调用新实例化的属性；<strong>或者</strong>也可以使用与对象属性名不同的参数名来实现对新实例化对象属性的赋值;</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Cat</span><span class="token punctuation">{</span>    String name<span class="token punctuation">;</span>    <span class="token keyword">int</span> month<span class="token punctuation">;</span>    <span class="token keyword">double</span> weight<span class="token punctuation">;</span>    String species<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//使用与类的属性名不同的参数名称来实现对新实例化的对象属性的赋值</span><span class="token keyword">public</span> <span class="token function">Cat</span><span class="token punctuation">(</span>String newName<span class="token punctuation">,</span> <span class="token keyword">int</span> newMonth<span class="token punctuation">,</span> <span class="token keyword">double</span> newWeight<span class="token punctuation">,</span> String newSpecies<span class="token punctuation">)</span><span class="token punctuation">{</span>    name <span class="token operator">=</span> newName<span class="token punctuation">;</span>    month <span class="token operator">=</span> newMonth<span class="token punctuation">;</span>    weight <span class="token operator">=</span> newWeight<span class="token punctuation">;</span>    species <span class="token operator">=</span> newSpecies<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="This关键字的使用"><a href="#This关键字的使用" class="headerlink" title="This关键字的使用"></a><code>This</code>关键字的使用</h2><ul><li><code>This</code>可以调用当且对象当中的属性以及方法，使用<code>This</code>关键字可以实现构造函数给当前属性赋初值，这种方案广泛用于构造函数的赋初值问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识总结 </tag>
            
            <tag> Java </tag>
            
            <tag> 构造函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保研之路以及保研之后的计划</title>
      <link href="/2020/09/28/bao-yan-zhi-hou-de-sheng-huo/"/>
      <url>/2020/09/28/bao-yan-zhi-hou-de-sheng-huo/</url>
      
        <content type="html"><![CDATA[<h2 id="保研之路的艰辛"><a href="#保研之路的艰辛" class="headerlink" title="保研之路的艰辛"></a>保研之路的艰辛</h2><ul><li>2019-2020学年是充满变化、痛苦与惊喜的一年，在这一年中，我成长了许多，理解了曾经或许不能够理解的人情世故。<br>2019年初，我在虹桥机场踏上了前往欧洲大英帝国的飞机，我记得那是卡塔尔航空公司的客机，当时为了省钱，买了便宜的卡塔尔航空公司的机票。虽然说机票买的是最便宜的，但仍然花费了我将近5000元，这一笔钱就让我心理压力倍增。在英国一年的学费是18955英镑，住宿费和生活费还要另算，大概加起来总共有10000英镑左右，这还是建立在我省吃俭用的基础之上的，可见英国留学一年的消费之高。我是一个把钱看得很重的人，如果能不花父母的钱，我就尽量不花，这是我的原则。但是这一年的英国之行，确实花销特别多，这也是我后期为什么选择中断学习回国的原因之一。<br>在大英帝国的一年过得也很辛苦，虽然中途圣诞节回来了几个星期，但是我仍然觉得心里很累，我不愿意承受这份出国留学的压力，我甚至晚上会做梦，梦见我回了南航，在南航南区吃着13.6一份的砂锅套餐，这简直就是神仙一般的生活。在英国的一年，我除了披萨、牛肉就是一些粗制滥造的食堂菜，让人很是烦躁。但这也没有办法，毕竟是自己选择的路，就算死也要走下去。<br>2020年伊始，新冠病毒在中国武汉华南海鲜市场爆发了，造成了中国将近10万人感染，2000多人死亡。病毒刚开始在中国扩散的时候，我在英国非常担心我父母的情况，有时候甚至会睡不着觉，担心新冠病毒会传播得飞速，最终导致中国大部分城市的沦陷。后来的情况证明了我的考虑是多余的，反倒是国外欧洲这边，开始疯了似的传播。我仍然记得北欧的环保小女孩桑伯格的到来是我们这座城病毒发展的转折点，自从那天之后，布里斯托就开始不断增长了，后来导致了停课。<br>在刚开始停课的时候，我不以为然，我觉得新冠病毒既然在中国传播得不厉害，那意味着在英国也不会怎么传播的，最后可能还会被控制住。我的同伴杜蔚峰劝我早点离开英国，回到中国去。可是，一想到我在英国只呆了3个多月就要回去了就有点不甘心，我想最后赌一把，看看新冠能不能好，如果可以好的话，我就留在英国不回去了。后来的情况证明我错了，我滞留在了英国，后来差点没回来，那时候机票特别难买，我是找了学校的老师认识的票贩子购买的回程机票，那张机票大概花了50000块，又是一大笔支出。不过好在后来学校退回了学费，也能补偿一点损失。我之所以后来会回来，是因为南航管理出国交换的张静老师跟我沟通了中断交流的事宜，我当时感觉如释重负，这非人的国外留学生活我是一分钟都不想再过了，这段时间我是被心理压力和生理压力共同影响，导致我头发掉了不少。好在最后还是回来了，当时我想着要是不能进行学分替代，不能参与保研我也要回来，因为国外的生活的压力我没办法承受。我记得当时我爸妈在和我讨论国外工作帮我买房的事情，我很不想在国外工作，又不想让父母知道真实的情况，于是，不知道怎么回事，我就非常烦躁，我感受到我爸妈也察觉了我的异常，于是没有再和我讨论这个事情。<br>在英国从三月份开始我就停课了，我当时想着得找点事情做，当时已经联系好了中断留学交流的事宜，于是，我不再把工作的重心放在学校的课程上面。当时，我做了个计划，想着回国就是两条路，一是保研，二是考研。我没有考虑工作，因为我爸妈非常坚定地要让我读研究生，我也有读研的意愿，所以工作就不在考虑的范围之内。当时我综合考虑了一下我的情况，保研可能有点困难，原因有两点，一是因为我出国可能不能进行学分替换，如果学分替换不能正常进行，那么保研也就无从谈起；二是因为我绩点有可能不够，后来发现这两点原因都是多虑了。但当时想着不能保研的话我就得考研，这是板上钉钉的事情，没有任何商量的余地，所以我从网上找了考研的复习材料，从三月份就开始准备，我显示准备了数学，当时还没有开始准备政治英语以及专业课，因为我自认为政治到10月份准备也行；英语的话我水平比较高应该问题不大；专业课的话我还没想好目标院校，最好还是先学习数学比较合适。于是我就开始了视频和书结合的复习方法，这段时间的复习的确巩固了一下我的数学基础，虽然之后不会参加考试了，但对我的帮助还是很大，尤其是高等数学和线性代数部分。<br>时间来到了五月份，我回国了，我在虹口区的君亭酒店隔离，隔离这段时间，我作息没有调整过来，过着没黑没夜的生活，基本上是醒着的时候就是在学习，睡着的时候就是在做梦，整个人压力很大，心理状态也不是很好。那段时间是我数学和运维技术突飞猛进的一段时间，两个星期的隔离时间里，我学习了太多知识了。说到运维技术，运维技术这个坑是我在英国的时候挖的，当时在阿里云上买了个服务器，想搭建一个个人博客网站，于是我就在阿里云大学上面学习马哥的运维技术，当时觉得讲得很不错，可能是因为一个人在英国隔离觉得非常寂寞的原因，我觉得视频里的老师讲中国话特别亲切，于是我每天基本上看8~10个小时的运维视频，那段时间，我的运维水平和计算机知识也突飞猛进，后来回国我利用我实习得到的工资购买了以整套运维课程，对我之后的对计算机的理解和网络技术的理解起到了非常重要的作用。<br>回到家的那一天我还记得，是5月22日，是我生日之后的两天，我在隔离酒店里面过了自己的生日，那是我第一次自己一个人过生日，我们家是一个非常和谐的家庭，如果谁过生日的话是一定会买蛋糕庆祝的。之后我在家里面依旧复习着，想着考研之后的各种计划。同时，我还要应付英国的各种乱起八糟的事情，比如课程考试，课程作业提交、学分证明的申请、退学手续的办理以及英国宿舍退宿退钱的办理。那段时间很多事情我都是装在肚子里，没有和任何人说过。这一点很奇怪，我是一个不愿意和他人交流的难处的人，好像就不想让别人知道我现在遇到了困难一样，可能是因为自己是一个比较好胜的人。那段时间我心理压力大到梦里做梦都是非常痛苦悲伤的梦，第二天醒来发现眼角还残留着泪水，枕头湿了一大片，这是我从来没有过得情况。那段时间在家里面，父母的各种要求，我也是尽量满足，虽然我能感受到他们对我回来这件事感到十分高兴，但我仍让克服不了自己心里面的压力。好在这个暑假一晃就过去了，马上就来到了九月…<br>九月是收获的季节，说实话我的确是心里还抱着能够保研的一丝希望的，我硬着头皮问了好几个老师关于这方面问题，得到的基本都是不确定的回答，搞的我迷迷糊糊的，也不知道是不是可以保研。但心里想着已经做了考研的准备，所以也不是很慌张。但是后面想到如果可以保研的话，我的求学之路就可以轻松很多，我就在争取保研这件事上做了很多工作，一开始我跑了教务处，问了这方面的问题，教务处说没有什么问题，只要正常交流的回来保研都是可以进行的，后来导员也是这么回复的。直到有一天，学院里面组织了推免生的情况说明会，我发现里面的邀请名单里面没有我，我就很慌，过去问了导员这方面的情况。后来才了解到我们学院的保研政策是成绩加权，这就意味着如果大三没有成绩的话，就不可能参与保研了。听到这个消息我故作镇定，我还记得这句话就像是一个棒子敲在我头上，让我的耳朵嗡嗡作响，我当时非常沮丧，回到了教室里面，立刻想好了我要考交大。这有几方面的原因，一是交大本身实力很强；二是我想要回到上海上学；三是学校的做法实在是让我觉得恶心，不想再在学校里面呆下去了。我那段时间早上七点就起来学习了，一直干到晚上十一点才回去，干了两天我就有点坚持不住了。交大考研的专业课包含了信号与系统和数字信号处理，信号与系统还好，我有本科基础，但是数字信号处理我没有基础，相当于要从头学起，这对我来说是极大地挑战，我甚至不知道自己是不是可以坚持过这段时间。我自认为是没办法一战考上的，我还做了二战的打算，这件事我还征求了我女朋友的意见，她说没有问题，我说那好，那我就准备二战。<br>后来，过了两天，我实在是有点坚持不下去，我就又动了保研的主意，我显示调查了我们学院负责保研的老师都有谁，发现了刘伟强老师，他是一位非常负责的老师，虽然可能行政工作做的比较多，但是他人很好，我联系了他之后他立刻就帮我了这个忙，通过各种操作，让我保研之路又死灰复燃。可以说他是我人生路上遇到的“贵人”，如果没有他，我也不会在保研之后坐在电脑前面写这篇文章了。之后的事情就变得顺利了起来，我为了能够多一点选择，我还参加了西安电子科技大学的预推免面试，最后也是顺利地通过了预推免，获得了接收函。<br>保研的艰辛之路到这里就结束了。我最后拿到了学校的推免资格，学校也把名单公示在了学院网上，整个保研的过程让人觉得充满了坎坷与痛苦，确实让我成长了许多。</li></ul><h2 id="保研之后的计划"><a href="#保研之后的计划" class="headerlink" title="保研之后的计划"></a>保研之后的计划</h2><ul><li>我保研之后，按照先前在国外的想法，主要是要学习面向对象的编程、学习算法知识以及学习运维知识，并且按照网上开发工程师的招聘要求进行学习。具体来讲，做到一天学习至少6个小时，其中要学习两个小时的运维，两个小时的算法以及两个小时的编程语言知识。此外，我还要更新我的博客，尽量做到一周三更，分享我个人的生活体验以及学业知识。并且我还希望可以利用这段时间提升一下英语水平，背一下GRE的单词。这段时间来之不易，希望我还可以好好利用起来，充实自己，为下一个阶段的到来做好充足的准备。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数组知识总结</title>
      <link href="/2020/09/28/java-xue-xi-bi-ji/"/>
      <url>/2020/09/28/java-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="Java数组简介"><a href="#Java数组简介" class="headerlink" title="Java数组简介"></a>Java数组简介</h2><ul><li>数组是一系列<strong>同类型</strong>元素的<strong>有序</strong>集合。</li><li>数组只能存储<strong>固定数量</strong>的元素，即，数组的长度在数组最初创建的时候就确定了，之后不能变动。</li></ul><h2 id="Java数组的特点"><a href="#Java数组的特点" class="headerlink" title="Java数组的特点"></a>Java数组的特点</h2><ul><li>数组是**引用类型</li><li>**的。</li><li>所有的元素都<strong>按照顺序</strong>存储在一块<strong>连续的</strong>内存中。</li><li>数组的每一个元素都要通过他的数字底标访问其元素。</li><li>数组中的元素可以是任意类型的变量。</li><li>数组的最大大小被<code>Integer.MAX_VALUE</code>定义;</li></ul><h2 id="Java数组使用的步骤（三部曲）"><a href="#Java数组使用的步骤（三部曲）" class="headerlink" title="Java数组使用的步骤（三部曲）"></a>Java数组使用的步骤（三部曲）</h2><ol><li>将一个变量<strong>声明</strong>为数组类型（declaration）;</li><li>创建一个数组对象的<strong>实例</strong>（instantiation）;</li><li>用某些值<strong>初始化</strong>数组（initialization）;</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//declaration</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//declaration</span>array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">//instantiation</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//instantiation &amp; initialization</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//declaration &amp; instantition</span><span class="token keyword">float</span><span class="token punctuation">[</span><span class="token punctuation">]</span> floatNumbers<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//declaration </span>floatNumbers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">float</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token number">1.02f</span><span class="token punctuation">,</span> <span class="token number">0.03f</span><span class="token punctuation">,</span> <span class="token number">4f</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//instantiation and initialization</span></code></pre><h2 id="Java数组提供的几个实用工具-Utility"><a href="#Java数组提供的几个实用工具-Utility" class="headerlink" title="Java数组提供的几个实用工具(Utility)"></a>Java数组提供的几个实用工具(Utility)</h2><pre class=" language-java"><code class="language-java">Array<span class="token punctuation">.</span>length    <span class="token comment" spellcheck="true">//return the length of the array</span>Array<span class="token punctuation">.</span>toString  <span class="token comment" spellcheck="true">//return the string of the array</span>Array<span class="token punctuation">.</span>equals    <span class="token comment" spellcheck="true">//compare two different arrays</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 计算机理论 </tag>
            
            <tag> 知识梳理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研线性代数知识点提纲（行列式）</title>
      <link href="/2020/07/01/kao-yan-xian-xing-dai-shu-zhi-shi-dian-ti-gang-xing-lie-shi/"/>
      <url>/2020/07/01/kao-yan-xian-xing-dai-shu-zhi-shi-dian-ti-gang-xing-lie-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="行列式的性质"><a href="#行列式的性质" class="headerlink" title="行列式的性质"></a>行列式的性质</h3><ol><li>经过转置后行列式的值不变。</li><li>两行或两列互换位置，行列式的值变号。</li><li>某行或某列如有公因子$k$，则可以把$k$提出行列式的记号外。</li><li>如果行列式某行或者某列是两个元素之和，则可以把行列式拆分成两个行列式之和。</li><li>把某行或某列的k倍加到另一行，行列式的值不变。</li></ol><h3 id="行列式的算法"><a href="#行列式的算法" class="headerlink" title="行列式的算法"></a>行列式的算法</h3><ol><li>行列式的余子式和代数余子式的区别是代数余子式有正负，余子式没有正负，都是正的。</li></ol><h3 id="行列式的展开的巧妙算法"><a href="#行列式的展开的巧妙算法" class="headerlink" title="行列式的展开的巧妙算法"></a>行列式的展开的巧妙算法</h3><ol><li>上下三角形行列式的值等于主对角线元素的乘积。</li><li>范德蒙行列式</li><li>爪型行列式</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 电磁场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电磁场知识梳理1（在球坐标和柱坐标下散度旋度公式）</title>
      <link href="/2020/06/23/dian-ci-chang-zhi-shi-shu-li-1/"/>
      <url>/2020/06/23/dian-ci-chang-zhi-shi-shu-li-1/</url>
      
        <content type="html"><![CDATA[<h2 id="在球坐标和柱坐标下散度旋度公式"><a href="#在球坐标和柱坐标下散度旋度公式" class="headerlink" title="在球坐标和柱坐标下散度旋度公式"></a>在球坐标和柱坐标下散度旋度公式</h2><h3 id="柱坐标下的散度公式"><a href="#柱坐标下的散度公式" class="headerlink" title="柱坐标下的散度公式"></a>柱坐标下的散度公式</h3><p>$$<br>\nabla\cdot\overrightarrow{F}=\frac{\partial(\rho F_\rho)}{\rho\partial\rho}+\frac{\partial F_\phi}{\rho\partial\phi}+\frac{\partial F_z}{\partial z}=\frac{1}{\rho}[\frac{\partial}{\partial\rho},\frac{\partial}{\partial\phi},\frac{\partial}{\partial z}]<br>\begin{bmatrix}<br>    \rho F_\rho\\<br>    F_\phi\\<br>    \rho F_z<br>\end{bmatrix}<br>$$</p><h3 id="柱坐标下的旋度公式"><a href="#柱坐标下的旋度公式" class="headerlink" title="柱坐标下的旋度公式"></a>柱坐标下的旋度公式</h3><p>$$<br>\nabla\times\overrightarrow{F}=\frac{1}{\rho}<br>\begin{bmatrix}<br>    \overrightarrow{e_\rho}&amp;\overrightarrow{\rho e_\phi}&amp;\overrightarrow{e_z}\\<br>    \frac{\partial}{\partial \rho}&amp;\frac{\partial}{\partial\phi}&amp;\frac{\partial}{\partial z}\\<br>    F_\rho&amp;\rho F_\phi&amp;F_z<br>\end{bmatrix}<br>$$</p><h3 id="球坐标系下的散度方程"><a href="#球坐标系下的散度方程" class="headerlink" title="球坐标系下的散度方程"></a>球坐标系下的散度方程</h3><p>$$<br>\nabla\cdot\overrightarrow{F}=\frac{\partial(r^2F_r)}{r^2\partial r}+\frac{\partial(sin\theta F_\theta)}{rsin\theta\partial\theta}+\frac{\partial F_\phi}{rsin\theta\partial\phi}=\frac{1}{r^2sin\theta}[\frac{\partial}{\partial r},\frac{\partial}{\partial\theta},\frac{\partial}{\partial\phi}]<br>\begin{bmatrix}<br>    r^2sin\theta F_r\\<br>    rsin\theta F_\theta\\<br>    rF_\phi<br>\end{bmatrix}<br>$$</p><h3 id="球坐标系下的旋度方程"><a href="#球坐标系下的旋度方程" class="headerlink" title="球坐标系下的旋度方程"></a>球坐标系下的旋度方程</h3><p>$$<br>\nabla\times\overrightarrow{F}=\frac{1}{r^2sin\theta}<br>\begin{bmatrix}<br>    \overrightarrow{e_r}&amp;\rho \overrightarrow{e_\theta}&amp;rsin\theta \overrightarrow{e_\phi}\\<br>    \frac{\partial}{\partial r}&amp;\frac{\partial}{\partial\theta}&amp;\frac{\partial}{\partial\phi}\\<br>    F_r&amp;rF_\theta&amp;rsin\theta F_\phi<br>\end{bmatrix}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 数理知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电磁场 </tag>
            
            <tag> 计算公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研数学知识点总结7（特征值、特征向量）</title>
      <link href="/2020/06/22/kao-yan-shu-xue-zhi-shi-dian-zong-jie-7/"/>
      <url>/2020/06/22/kao-yan-shu-xue-zhi-shi-dian-zong-jie-7/</url>
      
        <content type="html"><![CDATA[<h2 id="特征值、特征向量"><a href="#特征值、特征向量" class="headerlink" title="特征值、特征向量"></a>特征值、特征向量</h2><p>$A$是一个n阶方阵，如果对于数$\lambda$，存在非零向量$\alpha$，使得</p><p>$$<br>A\alpha=\lambda\alpha(a\neq0)<br>$$</p><p>成立，则称$\lambda$是$A$的<strong>特征值</strong>，$\alpha$是$A$对应于$\lambda$的<strong>特征向量</strong>。</p><h3 id="特征方程、特征多项式、特征矩阵"><a href="#特征方程、特征多项式、特征矩阵" class="headerlink" title="特征方程、特征多项式、特征矩阵"></a>特征方程、特征多项式、特征矩阵</h3><p>由上式可得，$(\lambda E-A)\alpha=0$，因$\alpha\neq0$，所以</p><p>$$<br>\begin{vmatrix}<br>\lambda E-A<br>\end{vmatrix}=<br>\begin{vmatrix}<br>    \lambda-a_{11}&amp;-a_{12}&amp;\dotsb&amp;-a_{1n}\\<br>    -a_{21}&amp;\lambda-a_{22}&amp;\dotsb&amp;-a_{2n}\\<br>    \vdots&amp;\vdots&amp;&amp;\vdots\\<br>    -a_{n1}&amp;-a_{n2}&amp;\dotsb&amp;\lambda-a_{nn}<br>\end{vmatrix}<br>$$</p><h3 id="特征值的性质"><a href="#特征值的性质" class="headerlink" title="特征值的性质"></a><strong>特征值的性质</strong></h3><p>设$A=[a_{ij}]_{m\times n}$，$\lambda_i(i=1,2,\dotsc,n)$是$A$的特征值，则</p><p>$$<br>(1)\sum_{i = 1}^{n}\lambda_i = \sum_{1 = 1}^{\infty}a_{ii};矩阵特征值的和为对角线元素之和<br>$$</p><p>$$<br>(2)\prod_{i=1}^{n}\lambda_i=\left\lvert A\right\rvert;矩阵特征值的积为矩阵的行列式<br>$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维笔记13</title>
      <link href="/2020/06/18/yun-wei-bi-ji-13/"/>
      <url>/2020/06/18/yun-wei-bi-ji-13/</url>
      
        <content type="html"><![CDATA[<h2 id="运维笔记13"><a href="#运维笔记13" class="headerlink" title="运维笔记13"></a>运维笔记13</h2><h3 id="磁盘分区设置"><a href="#磁盘分区设置" class="headerlink" title="磁盘分区设置"></a>磁盘分区设置</h3><p>磁盘分区设置共分为3个步骤，在此博客中详细叙述。</p><ol><li>创建分区</li><li>创建文件系统</li><li>挂载分区到文件上</li></ol><h4 id="创建分区"><a href="#创建分区" class="headerlink" title="创建分区"></a>创建分区</h4><p>使用<code>fdisk</code>命令可以实现分区操作。<br><code>fdisk -l [device]</code>查看分区。<br><code>fdisk /dev/sdb</code>管理分区。<br>管理分区子命令：  </p><table><thead><tr><th align="center">p</th><th align="center">分区列表</th></tr></thead><tbody><tr><td align="center">t</td><td align="center">更改分区类型</td></tr><tr><td align="center">n</td><td align="center">创建新分区</td></tr><tr><td align="center">d</td><td align="center">删除分区</td></tr><tr><td align="center">v</td><td align="center">校验分区</td></tr><tr><td align="center">u</td><td align="center">转换单位</td></tr><tr><td align="center">w</td><td align="center">保存并推出</td></tr><tr><td align="center">q</td><td align="center">不保存退出</td></tr></tbody></table><p>在创建完分区之后需要同步分区表，使得新分区生效，需要使用<code>partprobe [device]</code>命令。重新同步分区表之后，可以使用<code>cat /proc/partations</code>命令查看系统是否识别了新的分区。<br><strong>注意：</strong> 在此<code>CentOS 6</code>与<code>CentOS 7</code>使用的同步分区命令是不同的，在这里介绍的是适用于<code>CentOS 7</code>的同步命令，如果需要<code>CentOS 6</code>可以查看对应的命令。</p><h4 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h4><p>文件系统是操作系统用于明确存储设备或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。操作系统中负责管理和存储文件信息的软件结构称为文件管理系统，简称文件系统。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研数学知识点总结6（考研中常用的分布）</title>
      <link href="/2020/06/18/kao-yan-shu-xue-zhi-shi-dian-zong-jie-6/"/>
      <url>/2020/06/18/kao-yan-shu-xue-zhi-shi-dian-zong-jie-6/</url>
      
        <content type="html"><![CDATA[<h2 id="常用分布"><a href="#常用分布" class="headerlink" title="常用分布"></a>常用分布</h2><p>常用的分布，包括离散型随机变量的分布与连续型随机变量的分布与其对应的概率密度函数都在这篇博客当中描述了出来，尤其要注意相关分布的特性以及应用场合，如果可以的话，可以记住分布之间的可转换性。</p><h3 id="离散分布"><a href="#离散分布" class="headerlink" title="离散分布"></a>离散分布</h3><h3 id="0-1-分布"><a href="#0-1-分布" class="headerlink" title="$0-1$分布"></a>$0-1$分布</h3><p><strong>定义：</strong> 如果随机变量$X$有分布律</p><table><thead><tr><th align="center">$X$</th><th align="center">$0$</th><th align="center">$1$</th></tr></thead><tbody><tr><td align="center">$P$</td><td align="center">$1-p$</td><td align="center">$p$</td></tr></tbody></table><p>$0&lt;p&lt;1$则称$X$服从参数为$p$的$0-1$分布，或称X具有$0-1$分布。</p><h3 id="二项分布（有放回的抽样）"><a href="#二项分布（有放回的抽样）" class="headerlink" title="二项分布（有放回的抽样）"></a>二项分布（有放回的抽样）</h3><p><strong>定义：</strong> 如果随机变量$X$有分布律</p><p>$$<br>P{X=k}=C^k_np^kq^{n-k}, k=0, 1, 2, \dotsb, n,<br>$$</p><p>其中$0&lt;p&lt;1, q=1-p, $则称$X$服从参数为n, p的二项分布，记作$X\sim B(n, p).$<br>在$n$重伯努利实验中，如果每次试验成功率为$p(0&lt;p&lt;1)$，则在n<br>次独立重复试验中成功的总次数$X$服从二项分布。<br>当$n=1$时，不难验证二项分布就退化为$0-1$分布，所以$0-1$分布也可以记为$B(1, p)$。  </p><h3 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h3><p><strong>定义：</strong> 如果随机变量$X$的分布律为<br>$$P{X=k}=\frac{\lambda^k}{k!}, k=0, 1, 2, \dotsb, $$<br>其中$\lambda&gt;0$为常数，则称随机变量$X$服从参数为$\lambda$的泊松分布，记为$X\sim P(\lambda)$。<br><strong>注意：</strong> 当二项分布的n很大p很小时，二项分布可以近似看做成泊松分布。</p><hr><h3 id="连续分布"><a href="#连续分布" class="headerlink" title="连续分布"></a>连续分布</h3><hr><h3 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h3><p><strong>定义：</strong> 如果连续型随机变量$X$的概率密度为</p><p>$$<br>f(n) = \begin{cases} \frac{1}{b-a}, &amp; a\leq x \leq b, \ 0, &amp; 其他, \end{cases}<br>$$<br>则称$X$在区间$[a, b]$上服从均匀分布，记作$X\sim U[a, b]$.<br>如果概率密度为<br>$$<br>f(n) = \begin{cases} \frac{1}{b-a}, &amp; a&lt; x &lt; b, \ 0, &amp; 其他, \end{cases}<br>$$<br>则称$X$在区间$(a, b)$上服从均匀分布，记作$X\sim U(a, b)$.</p><h3 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h3><p><strong>定义：</strong> 如果连续型随机变量$X$的概率密度为<br>$$<br>f(n) = \begin{cases}\lambda e^{-\lambda x}, &amp;x&gt;0, \0, &amp;x<br>\leq 0, \lambda &gt;0, \end{cases}<br>$$<br>称$X$服从参数为$\lambda$的指数分布，记作$X\sim E(\lambda)$<br>设$X\sim E(\lambda)$，则$X$的分布函数为<br>$$<br>F(x)=\begin{cases}<br>  1-e^{-\lambda x}, &amp;x&gt;0, \<br>  0, &amp;x\leq 0, \lambda&gt;0,<br>\end{cases}<br>$$</p><h3 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h3><p><strong>定义：</strong> 如果连续型随机变量$X$的概率密度为<br>$$<br>f(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}},-\infty&lt;x&lt;+\infty<br>$$<br>当$\mu,\sigma$为常数且$\sigma&gt;0$，则称$X$服从参数为$\mu,\sigma$的正态分布，记作$X\sim N(\mu,\sigma^2)$<br>当$\mu=0,\sigma^2=1$时，即$X\sim N(0,1)$，称$X$服从标准正态分布，此时用$\varphi(x)$表示$X$的概率密度，即$\varphi(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{x^2}{2}},-\infty&lt;x&lt;+\infty.$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研数学知识点总结5（矩阵）</title>
      <link href="/2020/05/20/kao-yan-shu-xue-zhi-shi-dian-zong-jie-5/"/>
      <url>/2020/05/20/kao-yan-shu-xue-zhi-shi-dian-zong-jie-5/</url>
      
        <content type="html"><![CDATA[<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="概念-amp-运算"><a href="#概念-amp-运算" class="headerlink" title="概念&amp;运算"></a>概念&amp;运算</h3><ul><li><strong>矩阵的定义</strong>：$m\times n$个数排列成的$m$行$n$列的表格。</li></ul><p>$$\begin{bmatrix}<br>    a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}\\<br>    a_{21}&amp;a_{22}&amp;\cdots&amp;a_{2n}\\<br>    \vdots&amp;\vdots&amp;\cdots&amp;\vdots\\<br>    a_{m1}&amp;a_{m2}&amp;\cdots&amp;a_{mn}<br>\end{bmatrix}\\$$<br>上述称为一个$m\times n$的矩阵，当$m=n$时，称为$n$阶矩阵或$n$阶方阵。</p><ul><li><p>如果一个矩阵所有的元素都是0，则称此矩阵为<strong>零矩阵</strong>，简记0。</p></li><li><p>如果$A$和$B$都是$m\times n$的矩阵，称$A$和$B$为<strong>同型矩阵</strong>。</p></li><li><p>设$A$和$B$为同型矩阵，如果$a_{ij}=b_{ij}(\forall i=1,2,\cdots ,m;\forall j=1,2,\cdots,m)$,则称$A=B$。</p></li><li><p>设$A=[a_{ij}]$为n阶方阵，其所有元素构成的行列式称为方阵$A$的行列式，记为$\left\lvert A\right\rvert$。</p></li><li><p><strong>注意</strong>:</p><ol><li>仅方阵才有行列式$\left\lvert A\right\rvert$。</li><li>$A=0$与$\left\lvert A\right\rvert=0$不要混淆。</li></ol><p>  $$A=\begin{bmatrix}<br>      1&amp;2\\<br>      2&amp;4<br>  \end{bmatrix}\\ \neq0，但是\left\lvert A\right\rvert=0$$</p></li><li><p><strong>矩阵的运算法则</strong></p><ol><li>同型矩阵的<strong>加法</strong>： $A+B=[a_{ij}+b{ij}]$。矩阵的加法相当于对应元素相加，且满足<strong>交换律</strong>、<strong>结合律</strong>。</li><li>矩阵的<strong>数乘</strong>：$kA=[ka_{ij}]$。矩阵的数乘相当于单独乘以每一个元素，且满足<strong>交换律</strong>、<strong>结合律</strong>。</li><li>矩阵的<strong>乘法</strong>：假设$A$矩阵是$m\times s$的矩阵，$B$矩阵是$s\times n$的矩阵（A的列数必须与B的行数相等），则$AB=C$，其中$C$矩阵为$m\times n$的矩阵，且满足$c_{ij}=a_{i1}b_{1j}+a_{i2}b_{2j}+\cdots+a_{is}b_{sj}$（行与列点积）。乘法满足<strong>结合律</strong>，<strong>分配律</strong>，但<strong>不满足交换律</strong>。</li><li>与<strong>单位矩阵</strong>$E$相乘：$AE=A$。</li><li><strong>转置</strong>：设$[a_{ij}]_{m\times n}$，将这个矩阵行列互换，得到矩阵$A^T$，新矩阵为原矩阵的转置矩阵。记作$A=A^T$。<ul><li>$(A+B)^T=A^T+B^T$</li><li>$(kA)^T=kA^T$</li><li>$(AB)^T=B^TA^T$</li><li>$(A^T)^T=A$</li></ul></li></ol></li><li><p><strong>注意</strong>：</p><ol><li>$AB\neq BA$矩阵乘法没有交换律。</li><li>$AB=0\nRightarrow A=0或b=0$。</li><li>$AB=AC且A\neq 0 \nRightarrow B=C$。</li></ol></li><li><p><strong>对角矩阵</strong>的运算：</p><ul><li>对角矩阵的定义：只有在主对角线上有值，其余位置全为0的矩阵称为对角矩阵。</li></ul></li></ul><p>$$\begin{bmatrix}<br>    a_1&amp;0&amp;0\\<br>    0&amp;a_2&amp;0\\<br>    0&amp;0&amp;a_3<br>\end{bmatrix}<br>\begin{bmatrix}<br>    b1&amp;0&amp;0\\<br>    0&amp;b_2&amp;0\\<br>    0&amp;0&amp;b_3<br>\end{bmatrix}=<br>\begin{bmatrix}<br>    a_1b_1&amp;0&amp;0\\<br>    0&amp;a_2b_2&amp;0\\<br>    0&amp;0&amp;a_2b_3<br>\end{bmatrix}\\$$</p><ul><li><p><strong>注意</strong>：</p><ol><li>$\wedge_1\wedge_2=\wedge_2\wedge_1$满足<strong>交换律</strong>。</li><li>n个对角矩阵等于对角矩阵元素的n次方。<br>$$\begin{bmatrix}<br> a_1\\<br> &amp;a_2\\<br> &amp;&amp;a_3<br>\end{bmatrix}^n=<br>\begin{bmatrix}<br> a_1^n\\<br> &amp;a_2^n\\<br> &amp;&amp;a_3^n<br>\end{bmatrix}\\$$</li><li>对角矩阵求逆等于对角矩阵个元素求倒数。<br>$$\begin{bmatrix}<br> a_1\\<br> &amp;a_2\\<br> &amp;&amp;a_3<br>\end{bmatrix}^{-1}=<br>\begin{bmatrix}<br> \frac{1}{a_1}\\<br> &amp;\frac{1}{a_2}\\<br> &amp;&amp;\frac{1}{a_3}<br>\end{bmatrix}\\$$</li></ol></li></ul><h3 id="伴随矩阵"><a href="#伴随矩阵" class="headerlink" title="伴随矩阵"></a>伴随矩阵</h3><ul><li>定义：假设$A$是n阶方阵，$A$的伴随矩阵为$A^\ast$</li></ul><p>$$A^\ast=\begin{bmatrix}<br>    A_{11}&amp;A_{21}&amp;\cdots&amp;A_{n1}\\<br>    A_{12}&amp;A_{22}&amp;\cdots&amp;A_{n2}\\<br>    \vdots&amp;\vdots&amp;\cdots&amp;\vdots\\<br>    A_{1n}&amp;A_{2n}&amp;\cdots&amp;A_{nn}<br>\end{bmatrix}\\其中，A_{ij}为第i行第j列的代数余子式。$$</p><ul><li><p>性质：</p><ul><li>$AA^\ast=A^\ast A=\left\lvert A\right\rvert E$</li><li>$(kA)^\ast=k^{n-1}A^\ast$</li><li>$(A^\ast)^T=(A^T)^\ast$</li><li>$\left\lvert A^\ast\right\rvert=\left\lvert A\right\rvert^{n-1}$</li><li>$(A^\ast)^\ast=\left\lvert A\right\rvert^{n-2}A$</li><li>$A^{-1}=\left\lvert A\right\rvert^{-1}A^\ast,A^\ast=\left\lvert A\right\rvert A^{-1}$</li><li>$(A^\ast)^{-1}=(A^{-1})^\ast=\left\lvert A\right\rvert^{-1}A$</li></ul></li><li><p>注意：</p></li></ul><p>$$r(A^\ast)=\begin{cases}<br>    n,&amp;r(A)=n\\<br>    1,&amp;r(A)=n-1\\<br>    0,&amp;r(A)&lt;n-1<br>\end{cases}\\$$</p><h3 id="可逆矩阵"><a href="#可逆矩阵" class="headerlink" title="可逆矩阵"></a>可逆矩阵</h3><ul><li><p>定义：假设$A$是$n$阶矩阵，如果存在$n$阶矩阵B，使$AB=BA=E$成立，则称$A$是<strong>可逆矩阵</strong>，$B$是$A$的<strong>逆矩阵</strong>，记作$A^{-1}=B$。</p></li><li><p>定理1：如果$A$可逆，则$A$的<strong>逆矩阵唯一</strong>。</p></li><li><p>定理2：设$A、B$均为$n$阶方阵，且$AB=E$，则$BA=E$。</p></li><li><p>定理3：$A$矩阵可逆$\Leftrightarrow \left\lvert A\right\rvert\neq0$。</p></li><li><p>性质</p><ol><li>如果$A$可逆，则$A^{-1}$也可逆，且$(A^{-1})^{-1}=A$。</li><li>如果$A$可逆，且$k\neq 0$，则$kA$可逆，且$(kA)^{-1}=k^{-1}A^{-1}$。</li><li>如果$A、B$均可逆，则$AB$也可逆，且$(AB)^{-1}=B^{-1}A^{-1}$，特别地，$(A^2)^{-1}=(A^{-1})^2,(A^n)^{-1}=(A^{-1})^n$。</li><li>如果$A$可逆，则$A^T$也可逆，且$(A^T)^{-1}=(A^{-1})^T$。</li><li>二阶矩阵的逆矩阵求法：主对角线互换，副对角线变号。</li></ol></li><li><p><strong>注意</strong>：</p><ol><li>如果$A$可逆，则$\left\lvert A^{-1}\right\rvert=\left\lvert A\right\rvert^{-1}$。</li><li>当$A、B、A+B$都可逆时，$(A+B)^{-1}\neq A^{-1}+B^{-1}$（处理这个矩阵的时候要利用单位矩阵变形）。</li></ol></li><li><p>求逆矩阵的方法</p><ol><li>定义法。</li><li>使用伴随矩阵求逆矩阵。</li><li>使用初等行变换求逆矩阵。$(A|E)\longrightarrow(E|A^{-1})$。</li><li>使用分块矩阵求逆矩阵。<br>  $$\begin{bmatrix}<br>   A&amp;0\\<br>   0&amp;B<br>  \end{bmatrix}^{-1}=<br>  \begin{bmatrix}<br>   A^{-1}&amp;0\\<br>   0&amp;B^{-1}<br>  \end{bmatrix}或<br>  \begin{bmatrix}<br>   0&amp;A\\<br>   B&amp;0<br>  \end{bmatrix}^{-1}=<br>  \begin{bmatrix}<br>   0&amp;B^{-1}\\<br>   A^{-1}&amp;0<br>  \end{bmatrix}\\$$</li></ol></li></ul><h3 id="初等变换与初等矩阵"><a href="#初等变换与初等矩阵" class="headerlink" title="初等变换与初等矩阵"></a>初等变换与初等矩阵</h3><ul><li><p>矩阵的初等行（列）变换</p><ol><li>用$k\neq 0$乘第$A$行中的每一个元素（倍乘）。</li><li>互换$A$中的两行元素（互换）。</li><li>把某行的元素的$k$倍加到另一行上（倍加）。</li></ol></li><li><p>初等矩阵</p><ul><li>单位矩阵经过一次初等变换所得的矩阵称为初等矩阵。</li><li>初等矩阵$P$左乘$A$，$PA$是$A$作一次与$P$同样的行变换（左乘行变换）。</li><li>初等矩阵$P$右乘$A$，$PA$是$A$作一次与$P$同样的列变换（右乘列变换）。</li></ul></li><li><p>初等矩阵的逆矩阵</p><ul><li><p>倍加矩阵的逆矩阵还是初等矩阵（倍加）</p><p>$$\begin{bmatrix}<br>1&amp;0&amp;X\\<br>0&amp;1&amp;0\\<br>0&amp;0&amp;1<br>\end{bmatrix}^{-1}=<br>\begin{bmatrix}<br>1&amp;0&amp;-X\\<br>0&amp;1&amp;0\\<br>0&amp;0&amp;1<br>\end{bmatrix}\\$$</p></li><li><p>互换矩阵的逆矩阵是其本身</p><p>$$\begin{bmatrix}<br>0&amp;1&amp;0\\<br>1&amp;0&amp;0\\<br>0&amp;0&amp;1<br>\end{bmatrix}^{-1}=<br>\begin{bmatrix}<br>0&amp;1&amp;0\\<br>1&amp;0&amp;0\\<br>0&amp;0&amp;1<br>\end{bmatrix}\\$$</p></li><li><p>倍乘矩阵的逆矩阵还是倍乘矩阵</p><p>$$\begin{bmatrix}<br>1&amp;0&amp;0\\<br>0&amp;k&amp;0\\<br>0&amp;0&amp;1<br>\end{bmatrix}^{-1}=<br>\begin{bmatrix}<br>1&amp;0&amp;0\\<br>0&amp;\frac{1}{k}&amp;0\\<br>0&amp;0&amp;1<br>\end{bmatrix}\\$$</p></li><li><p>可逆矩阵$A$总可以表示为若干初等矩阵的乘积。</p></li></ul></li><li><p>行阶梯矩阵</p><ol><li>如果有零行，则零行一定在矩阵的底部。</li><li>每个非零行的主元（即该行最左边的第一个非零元）所在的列下面是零。</li><li>行最简：一个阶梯矩阵，如果还满足：非零行的主元都是1，且主元所在列的其他元素都是零，则称该阶梯矩阵行最简。</li></ol></li><li><p>矩阵等价</p><ul><li>如果矩阵$A$可以通过若干次初等变换得到$B$,就称矩阵$A$和$B$等价。</li><li>等价的充要条件：两个矩阵秩相等。$A\cong B\Longleftrightarrow r(A)=r(B)$</li></ul></li></ul><h3 id="分块矩阵"><a href="#分块矩阵" class="headerlink" title="分块矩阵"></a>分块矩阵</h3><ul><li><p>分块运算</p><ol><li>加法</li></ol><p>  $$\begin{bmatrix}<br>      A_1&amp;A_2\\<br>      A_3&amp;A_4<br>  \end{bmatrix}+<br>  \begin{bmatrix}<br>      B_1&amp;B_2\\<br>      B_3&amp;B_4<br>  \end{bmatrix}=<br>  \begin{bmatrix}<br>      A_1+B_1&amp;A_2+B_2\\<br>      A_3+B_3&amp;A_4+B_4<br>  \end{bmatrix}\\$$</p><ol start="2"><li>乘法</li></ol><p>  $$\begin{bmatrix}<br>      A&amp;B\\<br>      C&amp;D<br>  \end{bmatrix}\cdot<br>  \begin{bmatrix}<br>      X&amp;Y\\<br>      Z&amp;W<br>  \end{bmatrix}=<br>  \begin{bmatrix}<br>      AX+BZ&amp;AY+BW\\<br>      CX+DZ&amp;CY+DW<br>  \end{bmatrix}\\$$</p><ol start="3"><li>转置</li></ol><p>  $$\begin{bmatrix}<br>      A&amp;B\\<br>      C&amp;D<br>  \end{bmatrix}^T=<br>  \begin{bmatrix}<br>      A^T&amp;C^T\\<br>      B^T&amp;D^T<br>  \end{bmatrix}\\$$</p><ol start="4"><li>连乘</li></ol><p>  $$\begin{bmatrix}<br>      A&amp;0\\<br>      0&amp;B<br>  \end{bmatrix}^n=<br>  \begin{bmatrix}<br>      A^n&amp;0\\<br>      0&amp;B^n<br>  \end{bmatrix}\\$$</p><ol start="5"><li>求逆</li></ol><p>  $$\begin{bmatrix}<br>      A&amp;0\\<br>      0&amp;B<br>  \end{bmatrix}^{-1}=<br>  \begin{bmatrix}<br>      A^{-1}&amp;0\\<br>      0&amp;B^{-1}<br>  \end{bmatrix}或<br>  \begin{bmatrix}<br>      0&amp;A\\<br>      B&amp;0<br>  \end{bmatrix}^{-1}=<br>  \begin{bmatrix}<br>      0&amp;B^{-1}\\<br>      A^{-1}&amp;0<br>  \end{bmatrix}\\$$</p></li></ul><h3 id="方阵的行列式"><a href="#方阵的行列式" class="headerlink" title="方阵的行列式"></a>方阵的行列式</h3><ol><li>$\left\lvert A^T\right\rvert=\left\lvert A\right\rvert$</li><li>$\left\lvert kA\right\rvert=k^n\left\lvert A\right\rvert$</li><li>$\left\lvert AB\right\rvert=\left\lvert A\right\rvert\left\lvert B\right\rvert$</li><li>$\left\lvert A^2\right\rvert=\left\lvert A\right\rvert^2$</li><li>$\left\lvert A^\ast\right\rvert=\left\lvert A\right\rvert^{n-1}$</li><li>$\left\lvert A^{-1}\right\rvert=\left\lvert A\right\rvert^{-1}$</li><li>$$\begin{bmatrix}<br>   A&amp;0\\<br>   \ast&amp;B<br>   \end{bmatrix}=<br>   \begin{bmatrix}<br>   A&amp;\ast\\<br>   0&amp;B<br>   \end{bmatrix}=\left\lvert A\right\rvert\left\lvert B\right\rvert\\$$</li><li>$$\begin{bmatrix}<br>   0&amp;A\\<br>   B&amp;\ast<br>   \end{bmatrix}=<br>   \begin{bmatrix}<br>   \ast&amp;A\\<br>   B&amp;0<br>   \end{bmatrix}=(-1)^{mn}\left\lvert A\right\rvert\left\lvert B\right\rvert\\$$</li></ol><p>\partial </p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研数学知识点总结4（行列式）</title>
      <link href="/2020/05/19/kao-yan-shu-xue-zhi-shi-dian-zong-jie-4/"/>
      <url>/2020/05/19/kao-yan-shu-xue-zhi-shi-dian-zong-jie-4/</url>
      
        <content type="html"><![CDATA[<h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><h3 id="行列式的概念"><a href="#行列式的概念" class="headerlink" title="行列式的概念"></a>行列式的概念</h3><ul><li><strong>行列式</strong>是一个数，是不同行不同列乘积的代数和。</li></ul><p>$$\begin{vmatrix}<br>    a&amp;b\\<br>    c&amp;d<br>\end{vmatrix}=ad-bc$$<br>$$\begin{vmatrix}<br>    a_1&amp;a_2&amp;a_3\\<br>    a_4&amp;a_5&amp;a_6\\<br>    a_7&amp;a_8&amp;a_9<br>\end{vmatrix}=a_1b_2c_3+a_2b_3c_1+a_3b_1c_2\\<br>-a_3b_2c_1-a_2b_1c_3-a_1b_3c_2$$</p><ul><li><strong>排列的定义</strong>：由1~n组成的有序数组称为n阶排列，通常用$\Sigma_{i=1}^nj_i$表示n阶排列。</li><li><strong>逆序的定义</strong>：一个排列中，如果一个大的数排在小的数前面，则称这两个数构成一个逆序。</li><li>一个排列中的逆序总数称为排列的<strong>逆序数</strong>，用$\tau(j_1,j_2,…,j_3)$表示$j_1,j_2,…,j_3$的逆序数。</li><li><strong>奇排列偶排列的定义</strong>：如果一个排列的逆序数是偶数，则称排列为偶排列，否则称为奇排列。</li></ul><h3 id="行列式的性质"><a href="#行列式的性质" class="headerlink" title="行列式的性质"></a>行列式的性质</h3><ol><li>经过转置之后行列式的值不变。<strong>（转置值不变）</strong></li></ol><p>$$\left\lvert A^T\right\rvert = \left\lvert A\right\rvert $$</p><ol start="2"><li><p>行列式两行互换，行列式的值变号。特别地，两行相同行列式的值为0。<strong>（互换行变号）</strong></p></li><li><p>某行有公因数k，可把k提出行列式外。特别地，某行全为0，行列式的值为0。<strong>（可提公因数）</strong></p></li><li><p>如果某行元素是两个数之和，可把行列式拆成两个行列式之和。<strong>（行列式可拆）</strong></p></li></ol><p>$$\begin{vmatrix}<br>    a_{11}+b_{1}&amp;a_{12}+b_{2}&amp;a_{13}+b_{3}\\<br>    a_{21}&amp;a_{22}&amp;a_{23}\\<br>    a_{31}&amp;a_{32}&amp;a_{33}<br>\end{vmatrix}=<br>\begin{vmatrix}<br>    a_{11}&amp;a_{12}&amp;a_{13}\\<br>    a_{21}&amp;a_{22}&amp;a_{23}\\<br>    a_{31}&amp;a_{32}&amp;a_{33}<br>\end{vmatrix}+<br>\begin{vmatrix}<br>    b_{1}&amp;b_{2}&amp;b_{3}\\<br>    a_{21}&amp;a_{22}&amp;a_{23}\\<br>    a_{31}&amp;a_{32}&amp;a_{33}<br>\end{vmatrix}<br>$$</p><ol start="5"><li>某行的k倍加到1另一行上行列式的值不变。</li></ol><h3 id="行列式的展开公式"><a href="#行列式的展开公式" class="headerlink" title="行列式的展开公式"></a>行列式的展开公式</h3><ul><li><p><strong>余子式：</strong>$a_{ij}$的余子式是去掉第$i$行第$j$列后得到的矩阵，记为$M_{ij}$。</p></li><li><p><strong>代数余子式：</strong>$A_{ij}=(-1)^{i+j}a_{ij}$。</p></li><li><p><strong>通过代数余子式计算行列式：</strong>$\left\lvert A\right\rvert=a_{11}A_{11}+a_{12}A_{12}+…+a_{1n}A_{1n}$</p></li><li><p><strong>重要公式：</strong></p><ol><li>上下三角矩阵的值是主对角线元素的乘积。</li></ol><p>  $$\begin{vmatrix}<br>      a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}\\<br>      &amp;a_{22}&amp;\cdots&amp;a_{2n}\\<br>      &amp;&amp;\ddots&amp;\vdots\\<br>      &amp;&amp;&amp;a_{nn}<br>  \end{vmatrix}=<br>  \begin{vmatrix}<br>      a_{11}\\<br>      a_{21}&amp;a_{22}\\<br>      \vdots&amp;\vdots&amp;\ddots\\<br>      a_{n1}&amp;a_{n2}&amp;\cdots&amp;a_{nn}<br>  \end{vmatrix}=<br>  a_{11}a_{22}\cdots a_{nn}$$</p><ol start="2"><li>上下反三角矩阵的值是副对角线元素的乘积加上或不加符号。</li></ol><p>  $$\begin{vmatrix}<br>      a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}\\<br>      a_{21}&amp;\cdots&amp;a_{2(n-1)}\\<br>      \vdots&amp;\cdot\\<br>      a_{n1}<br>  \end{vmatrix}=<br>  \begin{vmatrix}<br>      &amp;&amp;&amp;a_{1n}\\<br>      &amp;&amp;a_{2(n-1)}&amp;a_{2n}\\<br>      &amp;\cdot&amp;\vdots&amp;\vdots\\<br>      a_{n1}&amp;a_{n2}&amp;\cdots&amp;a_{nn}<br>  \end{vmatrix}=<br>  (-1)^{\frac{n(n-1)}{2}}a_{11}a_{22}\cdots a_{nn}$$</p><ol start="3"><li>拉普拉斯公式三角（有零在角上时可以使用该公式）</li></ol><p>  $$\begin{vmatrix}<br>      A&amp;0\\<br>      \ast&amp;B<br>  \end{vmatrix}=<br>  \begin{vmatrix}<br>      A&amp;\ast\\<br>      0&amp;B<br>  \end{vmatrix}=<br>  \begin{vmatrix}<br>      A<br>  \end{vmatrix}<br>  \begin{vmatrix}<br>      B<br>  \end{vmatrix}$$</p><ol start="4"><li>拉普拉斯公式反三角（其中m为A方阵阶数，n为B方阵阶数）</li></ol><p>  $$\begin{vmatrix}<br>      0&amp;A\\<br>      B&amp;\ast<br>  \end{vmatrix}=<br>  \begin{vmatrix}<br>      \ast&amp;A\\<br>      B&amp;0<br>  \end{vmatrix}=(-1)^{mn}<br>  \begin{vmatrix}<br>      A<br>  \end{vmatrix}<br>  \begin{vmatrix}<br>      B<br>  \end{vmatrix}$$</p><ol start="5"><li>范德蒙矩阵</li></ol><p>  $$\begin{vmatrix}<br>      1&amp;1&amp;\cdots&amp;1\\<br>      x_1&amp;x_2&amp;\cdots&amp;x_n\\<br>      x_1^2&amp;x_2^2&amp;\cdots&amp;x_n^2\\<br>      \vdots&amp;\vdots&amp;\vdots&amp;\vdots\\<br>      x_1^{n-1}&amp;x_2^{n-1}&amp;\cdots&amp;x_n^{n-1}<br>  \end{vmatrix}=<br>  \prod_{1\le j&lt;i\le n}(x_i-x_j)\\<br>  所有大的数减小的数的差的乘积。$$</p><ol start="6"><li>爪型行列式</li></ol><p>  $$形如，<br>  \begin{vmatrix}<br>      x&amp;x&amp;x&amp;x\\<br>      x&amp;x&amp;0&amp;0\\<br>      x&amp;0&amp;x&amp;0\\<br>      x&amp;0&amp;0&amp;x<br>  \end{vmatrix}\\<br>  的行列式为爪型行列式。$$</p><ul><li>运算方法为，将第一行（列）的所有元素消去，利用上（下）三角法则运算。</li></ul></li></ul><h2 id="克拉默法则"><a href="#克拉默法则" class="headerlink" title="克拉默法则"></a>克拉默法则</h2><ul><li><p>如果方程的系数行列式$D=\left\lvert A\right\rvert\neq 0$，则方程存在唯一解，且，</p><p>$$x_1=\frac{D_1}{D}, x_2=\frac{D_2}{D}, \cdots, x_n=\frac{D_n}{D}\\$$</p><p>其中，$D_i$为将第$i$列替代为常数项列$b_1,b_2,\cdots,b_n$后的行列式。</p></li><li><p><strong>推论1</strong>：如果齐次方程组的系数行列式不为0，则方程组只有一组零解</p></li><li><p><strong>推论2</strong>：如果齐次方程组有非零解，则它的系数行列式必为0。</p><p><strong>注</strong>：齐次方程组：常数项系数为0的方程组称为齐次方程组</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 考研数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维笔记12</title>
      <link href="/2020/05/06/yun-wei-bi-ji-12/"/>
      <url>/2020/05/06/yun-wei-bi-ji-12/</url>
      
        <content type="html"><![CDATA[<h1 id="运维笔记11"><a href="#运维笔记11" class="headerlink" title="运维笔记11"></a>运维笔记11</h1><h2 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h2><ul><li><p>可以通过如下命令获取帮助</p><ul><li><code>whatis</code></li><li><code>command --help</code></li><li><code>man and info</code></li><li><code>/usr/share/doc/</code></li><li><code>Red Hat documentation</code></li></ul></li></ul><h2 id="whatis命令"><a href="#whatis命令" class="headerlink" title="whatis命令"></a><code>whatis</code>命令</h2><ul><li><p>显示命令的简短描述</p></li><li><p>使用数据库</p></li><li><p>刚安装后不可以立刻使用</p></li><li><p><code>makewhatis | mandb</code>制作数据库</p></li><li><p>使用实例：</p><ul><li><code>whatis cal</code>或<code>man -f cal</code></li></ul></li></ul><h2 id="命令帮助"><a href="#命令帮助" class="headerlink" title="命令帮助"></a>命令帮助</h2><ul><li><p>内部命令：<code>help COMMAND</code>或<code>man bash</code></p></li><li><p>外部命令：</p><ul><li><code>COMMAND --help</code>或<code>COMMAND -h</code></li><li>使用手册<code>manual</code>：<code>man COMMAND</code></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维笔记10</title>
      <link href="/2020/05/06/yun-wei-bi-ji-11/"/>
      <url>/2020/05/06/yun-wei-bi-ji-11/</url>
      
        <content type="html"><![CDATA[<h1 id="运维笔记11"><a href="#运维笔记11" class="headerlink" title="运维笔记11"></a>运维笔记11</h1><h2 id="bash的快捷键"><a href="#bash的快捷键" class="headerlink" title="bash的快捷键"></a>bash的快捷键</h2><ul><li><code>Ctrl + a</code>光标移到命令行首，相当于<code>Home</code></li><li><code>Ctrl + e</code>光标移到命令行尾，相当于<code>End</code></li><li><code>Ctrl + f</code>光标向右移动一个字符</li><li><code>Ctrl + b</code>光标向左移动一个字符</li><li><code>Alt + f</code>光标向右移动一个单词尾</li><li><code>Alt + f</code>光标向左移动一个单词首</li><li><code>Ctrl + xx</code>光标在命令行首和光标之间移动</li><li><code>Ctrl + u</code>从光标处删除至命令行首</li><li><code>Ctrl + k</code>从光标处删除至命令行尾</li><li><code>Alt + r</code>删除当前整行</li></ul><h2 id="bash的快键键"><a href="#bash的快键键" class="headerlink" title="bash的快键键"></a>bash的快键键</h2><ul><li><code>Ctrl + l</code>清屏，相当于clear命令</li><li><code>Ctrl + o</code>执行当前命令，并重新显示本命令</li><li><code>Ctrl + s</code>组织屏幕删除，锁定</li><li><code>Ctrl + q</code>允许屏幕输出</li><li><code>Ctrl + c</code>终止命令</li><li><code>Ctrl + z</code>挂起命令</li></ul><h2 id="bash的快捷键-1"><a href="#bash的快捷键-1" class="headerlink" title="bash的快捷键"></a>bash的快捷键</h2><ul><li><code>Ctrl + w</code> 从光标处向左删除至单词首</li><li><code>Alt + d</code> 从光标处向右删除至单词尾</li><li><code>Ctrl + d</code> 删除光标处的一个字符</li><li><code>Ctrl + h</code> 删除光标前的一个字符</li><li><code>Ctrl + y</code> 将删除的字符粘贴至光标后</li><li><code>Alt + c</code> 从光标处开始向右更改为首字母大写的单词</li><li><code>Alt + u</code> 从光标处开始，将右边一个单词更改为大写</li><li><code>Alt + l</code> 从光标处开始，将右边一个单词更改为小写</li><li><code>Ctrl + t</code> 交换光标处和之前的字符位置</li><li><code>Alt + t</code> 交换光标处和之前的单词位置</li><li><code>Alt + N</code> 提示输入指定字符后，重复显示该字符N次</li><li>注意： Alt组合快捷键经常和其它软件冲突</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研数学知识点总结3（导数）</title>
      <link href="/2020/04/23/kao-yan-shu-xue-zhi-shi-dian-zong-jie-3/"/>
      <url>/2020/04/23/kao-yan-shu-xue-zhi-shi-dian-zong-jie-3/</url>
      
        <content type="html"><![CDATA[<h2 id="导数与微分的概念"><a href="#导数与微分的概念" class="headerlink" title="导数与微分的概念"></a>导数与微分的概念</h2><ol><li><p>导数的概念</p><ul><li>导数的定义</li><li>左导数的定义</li><li>右导数的定义</li><li>定理：函数在$x_0$处可导的充分必要条件</li><li>区间上可导与导函数的定义</li></ul></li><li><p>微分的概念</p><ul><li>微分的定义</li><li>定理函数在$x_0$处可微的充要条件</li></ul></li><li><p>导数与微分的几何意义</p><ul><li>导数的几何意义</li><li>微分的几何意义</li></ul></li></ol><ul><li>连续、可导以及可微之间的关系</li></ul><h2 id="导数公式与求导法则"><a href="#导数公式与求导法则" class="headerlink" title="导数公式与求导法则"></a>导数公式与求导法则</h2><ol><li><p>基本初等函数的导数公式</p><ul><li>C</li><li>$x^a$</li><li>$a^x$</li><li>$e^x$</li><li>$log_ax$</li><li>$ln\left\lvert x\right\rvert$</li><li>$sinx$</li><li>$cosx$</li><li>$tanx$</li><li>$cotx$</li><li>$secx$</li><li>$cscx$</li><li>$arcsinx$</li><li>$arccosx$</li><li>$arctanx$</li><li>$arccotx$</li></ul></li><li><p>求导法则</p><ul><li>有理运算法则</li><li>复合函数求导法</li><li>隐函数求导法</li><li>反函数的导数</li><li>参数方程求导法</li><li>对数求导法</li></ul></li></ol><h2 id="高阶导数"><a href="#高阶导数" class="headerlink" title="高阶导数"></a>高阶导数</h2><ol><li><p>高阶导数的概念</p><ul><li>高阶导数的定义</li><li>函数在x处n阶可导，则函数在x的某一个领域内必定具有一切低于n阶的导数</li></ul></li><li><p>常用的高阶求导公式（4个）</p><ul><li>$(sinx)^{(n)}$</li><li>$(cosx)^{(n)}$</li><li>$(u\pm v)^{(n)}$</li><li>$(uv)^{(n)}$</li></ul></li></ol><h2 id="导数的应用"><a href="#导数的应用" class="headerlink" title="导数的应用"></a>导数的应用</h2><ol><li>导数的几何意义（求切线法线）</li><li>相关变化率</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 考研数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研数学知识点总结2（连续）</title>
      <link href="/2020/04/23/kao-yan-shu-xue-zhi-shi-dian-zong-jie-2/"/>
      <url>/2020/04/23/kao-yan-shu-xue-zhi-shi-dian-zong-jie-2/</url>
      
        <content type="html"><![CDATA[<h2 id="连续性的概念"><a href="#连续性的概念" class="headerlink" title="连续性的概念"></a>连续性的概念</h2><ol><li>连续的定义（两个）（连续性是研究函数在某点的极限值与该点数值之间的关系）</li><li>左连续定义</li><li>右连续定义</li><li>函数在$x_0$处连续的充要条件</li><li>函数的开区间和闭区间上连续的定义</li></ol><h2 id="间断点及其分类"><a href="#间断点及其分类" class="headerlink" title="间断点及其分类"></a>间断点及其分类</h2><ol><li><p>间断点的定义</p></li><li><p>间断点的分类</p><ul><li><p>第一类间断点的定义</p><ol><li>可去间断点的定义</li><li>跳跃间断点</li></ol></li><li><p>第二类间断点的定义（答题可以直接答第二类间断点）</p><ol><li>无穷间断点</li><li>振荡间断点</li></ol></li></ul></li></ol><h2 id="连续性的运算与性质"><a href="#连续性的运算与性质" class="headerlink" title="连续性的运算与性质"></a>连续性的运算与性质</h2><ol><li>定理：两个函数在$x_0$连续，则和差积商也连续</li><li>定理：复合函数的内外函数若均连续，则符合函数也连续</li><li>基本初等函数在其定义域内都是连续的</li><li>初等函数在其定义区间内都是连续的</li></ol><h2 id="闭区间上连续函数的性质"><a href="#闭区间上连续函数的性质" class="headerlink" title="闭区间上连续函数的性质"></a>闭区间上连续函数的性质</h2><p>下列定理均要求函数在闭区间内连续</p><ol><li><p>最值定理</p></li><li><p>有界性定理</p></li><li><p>介值定理</p><ul><li>推论最大值最小值定理</li></ul></li><li><p>零点定理（应用：证明跟的存在性）</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 考研数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研数学知识点总结1（极限）</title>
      <link href="/2020/04/23/kao-yan-shu-xue-zhi-shi-dian-zong-jie-1/"/>
      <url>/2020/04/23/kao-yan-shu-xue-zhi-shi-dian-zong-jie-1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、极限的概念"><a href="#一、极限的概念" class="headerlink" title="一、极限的概念"></a>一、极限的概念</h2><ol><li><p>数列的极限定义（$\varepsilon -N$）</p></li><li><p>函数的极限</p><ul><li>自变量趋于无穷大时函数的极限（$\varepsilon -X$）</li><li>自变量趋于有限值时函数的极限（$\varepsilon -\delta$）（要求的是去心邻域，即函数值可以在这一点没有定义）</li><li>左极限定义（$\varepsilon -\delta$）</li><li>右极限定义（$\varepsilon -\delta$）</li><li>定理：函数极限存在的充要条件</li></ul></li></ol><h2 id="二、极限的性质"><a href="#二、极限的性质" class="headerlink" title="二、极限的性质"></a>二、极限的性质</h2><ol><li><p>有界性</p></li><li><p>保号性</p><ul><li>注意如果 $f(x)&gt;0$，只能推得 $limf(x)\geq0$，但是 $limf(x)&gt;0$ 却可以推得 $f(x)&gt;0$。可以从极限的定义考虑这个问题。</li></ul></li><li><p>极限值与无穷小量之间的关系</p></li></ol><h2 id="三、极限存在的准则"><a href="#三、极限存在的准则" class="headerlink" title="三、极限存在的准则"></a>三、极限存在的准则</h2><ol><li>夹逼准则</li><li>单调有界准则</li></ol><h2 id="四、无穷小量"><a href="#四、无穷小量" class="headerlink" title="四、无穷小量"></a>四、无穷小量</h2><ol><li><p>无穷小量的概念</p></li><li><p>无穷小量的比较</p><ul><li>高阶</li><li>低阶</li><li>同阶</li><li>等价</li><li>无穷小阶的定义</li></ul></li><li><p>无穷小的性质</p><ul><li>有限个无穷小的和仍然是无穷小</li><li>有限个无穷小的积仍然是无穷小</li><li>无穷小量与有界量的积仍然是无穷小</li></ul></li></ol><h2 id="无穷大量"><a href="#无穷大量" class="headerlink" title="无穷大量"></a>无穷大量</h2><ol><li><p>无穷大量的概念</p></li><li><p>常用的一些无穷大量的比较（五个无穷大量的比较）</p></li><li><p>无穷大量的性质</p><ul><li>两个无穷大量的积仍然是无穷大量</li><li>无穷大量与有界变量之和仍然是无穷大量</li></ul></li><li><p>无穷大量与无界变量的关系（回顾无穷大量与无界变量定义的区别）</p></li><li><p>无穷大量与无穷小量的关系</p></li></ol><h2 id="求极限（7种方法-x2F-8种方法）"><a href="#求极限（7种方法-x2F-8种方法）" class="headerlink" title="求极限（7种方法/8种方法）"></a>求极限（7种方法/8种方法）</h2><ol><li><p>利用基本极限求极限</p></li><li><p>利用等价无穷小求极限</p></li><li><p>利用有理运算法则求极限</p><ul><li>如果两个函数的极限存在，他们的和差积的极限也存在，如果位于分母的函数极限不为零，那么商也存在。</li><li>存在 $\pm$ 不存在 $=$ 不存在，其他牵扯到极限不存在的函数的运算结果均为不一定。</li></ul></li><li><p>利用洛必达法则求极限</p><p> 使用条件：</p><ul><li>（易错）$lim_{x \to x_0}f(x)=lim_{x \to x_0}g(x)=0(\infty)$</li><li>$f(x)$ 和 $g(x)$ 在 $x_0$ 的某个去心邻域内可导，且 $g(x) \neq 0$</li><li>（易错）$lim_{x \to x_0}\frac{f’(x)}{g’(x)}$ 存在</li></ul></li><li><p>利用泰勒公式求极限（带<code>Peano</code>余项的泰勒公式）</p><ul><li>四个常用泰勒公式（$e^x,sinx,cosx,ln(1+x)$）</li></ul></li><li><p>利用夹逼准则求极限</p></li><li><p>利用单调有界性准则求极限</p><ul><li>证明单调有界（极限存在）之后使用两边取极限</li></ul></li><li><p>利用定积分定义求极限</p><ul><li>提可爱因子$\frac{1}{n}$。</li></ul></li><li><p>利用拉格朗日中值定理求极限</p><ul><li>出现两个相同形式的函数的差的时候可以使用拉格朗日中值定理。</li><li>尤其是复杂函数的差可以考虑用拉格朗日中值定理，例如，根式的差，指数函数的差，三角函数的差，反三角函数的差</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 考研数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研数学易错点总结</title>
      <link href="/2020/04/23/kao-yan-shu-xue-yi-cuo-dian-zong-jie/"/>
      <url>/2020/04/23/kao-yan-shu-xue-yi-cuo-dian-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-函数与数列的极限的定义"><a href="#第一章-函数与数列的极限的定义" class="headerlink" title="第一章 函数与数列的极限的定义"></a>第一章 函数与数列的极限的定义</h2><ul><li>数列的极限趋向于无穷默认趋向于正无穷$\lim_{x \to \infty} a_n=\lim_{x \to +\infty} a_n$。</li><li>函数在某一点极限存在的充分必要条件为函数在该点的左右极限存在且相等，即$\lim_{x \to x_0^{-1}} {f(x)}=\lim_{x \to x_0^{+1}} {f(x)}=A$。</li><li>函数在某一点极限存在不一定需要函数在该点有定义。对于$\lim_{x \to x_0} {f(x)}$，其定义为函数需要在$x_0$的去心邻域内有定义，所以函数在$x_0$处可以没有定义，但极限依然可以存在。</li><li>函数的极限$\lim_{x \to \infty}{f(x)}$的极限需要考虑两个情况，因为$x\rightarrow\infty$中并没有指明$x\rightarrow+\infty$还是$x\rightarrow-\infty$，所以两个情况都需要考虑。特别的，遇到$\lim_{x \to \infty} {e^x}$以及$\lim_{x \to \infty} {arctan(x)}$需要特别考虑。</li></ul><h2 id="第一章-函数与数列极限的性质"><a href="#第一章-函数与数列极限的性质" class="headerlink" title="第一章 函数与数列极限的性质"></a>第一章 函数与数列极限的性质</h2><ul><li>有界性<ul><li>数列如果收敛（极限存在的另一种说法），那么数列一定有界（定义证明）；但是函数有界不一定收敛（举反例$\lim_{x \to +\infty}{sinx}$）。</li></ul></li><li>保号性<ul><li>注意保号性里面数列极限如果$&gt;0$，可以推出数列从某个点开始的无穷多项也$&gt;0$；但是如果数列从某个点开始的极限$&gt;0$，只能推出数列的极限$\geqslant0$。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数理知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识梳理 </tag>
            
            <tag> 考研数学 </tag>
            
            <tag> 高等数学 </tag>
            
            <tag> 极限连续函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维笔记10</title>
      <link href="/2020/04/23/yun-wei-bi-ji-10/"/>
      <url>/2020/04/23/yun-wei-bi-ji-10/</url>
      
        <content type="html"><![CDATA[<h1 id="运维笔记9"><a href="#运维笔记9" class="headerlink" title="运维笔记9"></a>运维笔记9</h1><h2 id="命令行历史"><a href="#命令行历史" class="headerlink" title="命令行历史"></a>命令行历史</h2><ul><li>保存你输入的命令历史。可以用它来重复执行命令。</li><li>登录shell时，会读取历史文件中记录下的命令<code>~/.bash_history</code>。</li><li>登录进入shell后新执行的命令只会记录在缓存中；这些命令会在用户退出之后追加到命令历史文件<code>~/.bash_history</code>中。</li></ul><h2 id="命令行历史回溯命令与快捷键"><a href="#命令行历史回溯命令与快捷键" class="headerlink" title="命令行历史回溯命令与快捷键"></a>命令行历史回溯命令与快捷键</h2><ul><li><p>重复之前一个命令，有四种办法</p><ul><li>重复前一个命令使用上下方向键。</li><li>按<code>!!</code>并回车执行</li><li>输入<code>!-1</code>并回车执行</li><li>按<code>Ctrl+p</code>并回车执行。</li></ul></li><li><p><code>!:0</code>执行前一条命令（去除参数）</p></li><li><p><code>Ctrl+n</code>显示当前历史中的下一条命令，但不执行</p></li><li><p><code>Ctrl+j</code>执行当前命令</p></li><li><p><code>Ctrl+r</code>来在命令历史中搜索命令</p></li><li><p><code>Ctrl+g</code>从历史搜索模式退出</p></li><li><p><code>!n</code>执行<code>history</code>命令输出对应序号n的命令</p></li><li><p><code>!-n</code>执行history历史中倒数第n个命令</p></li></ul><h2 id="命令行历史的高级功能"><a href="#命令行历史的高级功能" class="headerlink" title="命令行历史的高级功能"></a>命令行历史的高级功能</h2><ul><li><code>!string</code>重复前一个以<code>string</code>开头的命令</li><li><code>!?string</code>重复前一个包含<code>string</code>的命令</li><li><code>!string:p</code>仅打印命令历史，而不执行</li><li><code>!$:p</code>打印输出<code>!$</code>（上一条命令的最后一个参数）的内容</li><li><code>!*:p</code>打印输出<code>!*</code>（上一条命令的所有参数）的内容</li><li><code>^string</code>删除上一条命令中的第一个<code>string</code></li><li><code>^string1^string2</code>将上一条命令中的第一个<code>string1</code>更换为<code>string2</code></li><li><code>!:gs/string1/string2</code>将上一条命令中所有的<code>string1</code>都替换为<code>string2</code></li><li>要重新调用前一个命令中最后一个参数<ul><li><code>!$</code>表示前一个命令中的最后一个参数</li><li><code>Esc+.</code>（点击<code>Esc</code>键后松开，然后点击<code>.</code>键）</li><li><code>Alt+.</code>（按住Alt键的同时点击<code>.</code>键）</li></ul></li></ul><h2 id="调用历史参数"><a href="#调用历史参数" class="headerlink" title="调用历史参数"></a>调用历史参数</h2><ul><li><code>command !^</code> 利用上一个命令的第一个参数做<code>command</code>的参数</li><li><code>command !$</code> 利用上一个命令的最后一个参数做<code>command</code>的参数</li><li><code>command !*</code> 利用上一个命令的全部参数做<code>command</code>的参数</li><li><code>command !:n</code> 利用上一个命令的第n个参数做<code>command</code>的参数</li><li><code>command !n:^</code> 调用第<code>n</code>条命令的第一个参数</li><li><code>command !n:$</code> 调用第<code>n</code>条命令的最后一个参数</li><li><code>command !n:m</code> 调用第<code>n</code>条命令的第<code>m</code>个参数</li><li><code>command !n:*</code> 调用第<code>n</code>条命令的所有参数</li></ul><h2 id="命令history"><a href="#命令history" class="headerlink" title="命令history"></a>命令<code>history</code></h2><ul><li><code>history [-c] [-d offset] [n]</code></li><li><code>history -anrw [filename]</code></li><li><code>history -ps arg [arg...]</code><ul><li><code>-c</code>: 清空命令历史</li><li><code>-d offset</code>: 删除历史中指定的第offset个命令</li><li><code>n</code>: 显示最近的n条历史</li><li><code>-a</code>: 追加本次会话新执行的命令历史列表至历史文件</li><li><code>-r</code>: 读历史文件附加到历史列表</li><li><code>-w</code>: 保存历史列表到指定的历史文件</li><li><code>-n</code>: 读历史文件中未读过的行到历史列表</li><li><code>-p</code>: 展开历史参数成多行，但不存在历史列表中</li><li><code>-s</code>: 展开历史参数成一行，附加在历史列表后</li></ul></li></ul><h2 id="命令历史相关环境变量"><a href="#命令历史相关环境变量" class="headerlink" title="命令历史相关环境变量"></a>命令历史相关环境变量</h2><ul><li><p><code>HISTSIZE</code>：命令历史记录的条数</p></li><li><p><code>HISTFILE</code>：指定历史文件，默认为<code>~/.bash_history</code></p></li><li><p><code>HISTFILESIZE</code>：命令历史文件记录历史的条数</p></li><li><p><code>HISTTIMEFORMAT = "%F %T"</code>：显示时间</p></li><li><p><code>HISTIGNORE = "str1:str2*..."</code>：忽略str1命令，str2开头的历史</p></li><li><p>控制命令历史的记录方式：</p><p>环境变量：<code>HISTCONTROL</code></p><ul><li><code>ignoredups</code>：默认，忽略重复的命令，连续且相同为“重复”</li><li><code>ignorespace</code>：忽略所有以空白开头的命令</li><li><code>ignoreboth</code>：相当于<code>ignoredups</code>，<code>ignorespace</code>的组合</li><li><code>erasedups</code>：删除重复命令</li></ul></li><li><p><code>export</code> 变量名 = “值”</p></li><li><p>存放在<code>/etc/profile</code>或<code>~/.bash_profile</code></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维笔记9</title>
      <link href="/2020/04/21/yun-wei-bi-ji-9/"/>
      <url>/2020/04/21/yun-wei-bi-ji-9/</url>
      
        <content type="html"><![CDATA[<h1 id="运维笔记9"><a href="#运维笔记9" class="headerlink" title="运维笔记9"></a>运维笔记9</h1><h2 id="日期与时间"><a href="#日期与时间" class="headerlink" title="日期与时间"></a>日期与时间</h2><ul><li><p>Linux的两种时钟</p><ol><li>系统时钟：由Linux内核通过CPU的工作频率计时</li><li>硬件时钟：主板</li></ol></li><li><p>相关命令</p><ol><li><p><code>date</code> 显示和设置系统时间</p><ul><li><code>date +%s</code></li><li><code>date -d @1509536033</code></li></ul></li><li><p><code>hwclock</code>, <code>clock</code>：显示硬件时钟</p><ul><li><code>-s</code>, <code>--hctosys</code>以硬件时钟为准，校正系统时钟</li><li><code>-w</code>, <code>--systohc</code> 以系统时钟为准， 校正硬件时钟</li></ul></li></ol></li><li><p>时区</p><p>  打开配置文件<code>/etc/localtime</code>，修改内容</p></li><li><p>显示日历</p><p>  使用命令<code>cal -y</code></p></li></ul><h2 id="开机重启命令"><a href="#开机重启命令" class="headerlink" title="开机重启命令"></a>开机重启命令</h2><ul><li><p>关机</p><ol><li><code>halt</code>，表示关机不断电</li><li><code>poweroff</code>，表示关机并断电</li></ol></li><li><p>重启</p><p>  <code>reboot</code>命令可以重启计算机，<code>-f</code>命令表示强制重启，不调用<code>shutdown</code>；<code>-p</code>命令表示切断电源</p></li><li><p>关机或重启</p><p>  <code>shutdown</code>命令可以在不同的配置下完成重启和关机工作</p><pre><code>- `-r`，表示重新启动- `-h`，表示关机- `-c`，表示取消</code></pre></li></ul><h2 id="用户登录信息查看命令"><a href="#用户登录信息查看命令" class="headerlink" title="用户登录信息查看命令"></a>用户登录信息查看命令</h2><ul><li><code>whoami</code>，显示当前登录的有效用户</li><li><code>who</code>，显示系统当前所有的登录回话</li><li><code>w</code>，显示系统当前所有的登录回话以及所做的操作</li></ul><h2 id="screen投屏命令的操作"><a href="#screen投屏命令的操作" class="headerlink" title="screen投屏命令的操作"></a><code>screen</code>投屏命令的操作</h2><ul><li><p>创建新的screen会话</p><p>  使用命令，<code>screen –S [SESSION]</code></p></li><li><p>加入已有的screen会话</p><p>  使用命令，<code>screen –x [SESSION]</code></p></li><li><p>退出并关闭screen会话</p><p>  使用命令，<code>exit</code></p></li><li><p>剥离当前screen会话</p><p>  使用快捷键，<code>CTRL+a,d</code></p></li><li><p>显示所有已经打开的<code>screen</code>会话</p><p>  使用命令，<code>screen -ls</code></p></li><li><p>恢复某<code>screen</code>会话</p><p>  使用命令，<code>screen -r [SESSION]</code></p></li></ul><h2 id="echo命令使用的解释"><a href="#echo命令使用的解释" class="headerlink" title="echo命令使用的解释"></a><code>echo</code>命令使用的解释</h2><ul><li><p>语法，<code>echo [-neE][字符串]</code></p></li><li><p>说明：echo会将输入的字符串送往标准输出。输出的字符以空白字符隔开，并在最后加上换行符</p></li><li><p>选项</p><ul><li><code>-E</code>（默认）不支持转义字符<code>\</code>功能</li><li><code>-n</code>不自动换行</li><li><code>-e</code>启用转义字符<code>\</code>功能</li></ul></li><li><p>显示变量</p><ul><li><code>echo "$VAR_NAME"</code>，使用双引号时，变量会替换，弱引用，即变量没有办法被识别</li><li><code>echo '$VAR_NAME'</code>，使用单引号时，变量不会替换，强引用，即变量可以被识别</li></ul></li></ul><h2 id="命令行扩展、被括起来的集合"><a href="#命令行扩展、被括起来的集合" class="headerlink" title="命令行扩展、被括起来的集合"></a>命令行扩展、被括起来的集合</h2><ul><li><p>命令行扩展：<code>$()</code>或<code>``</code></p><ul><li><p>把一个命令的输出打印给另一个命令的参数（有点类似重定向或者管道）</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">"This system's name is <span class="token variable"><span class="token variable">$(</span><span class="token function">hostname</span><span class="token variable">)</span></span>"</span>This system's name is server1.example.com<span class="token keyword">echo</span> <span class="token string">"i am <span class="token variable"><span class="token variable">`</span><span class="token function">whoami</span><span class="token variable">`</span></span> "</span>i am root</code></pre></li></ul></li><li><p>符号扩展；<code>{}</code></p><ul><li><p>打印重复字符串的简化形式</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> file<span class="token punctuation">{</span>1,3,5<span class="token punctuation">}</span> <span class="token comment" spellcheck="true">#结果为： file1 file3 file5</span><span class="token function">rm</span> -f file<span class="token punctuation">{</span>1,3,5<span class="token punctuation">}</span><span class="token keyword">echo</span> <span class="token punctuation">{</span>1<span class="token punctuation">..</span>10<span class="token punctuation">}</span><span class="token keyword">echo</span> <span class="token punctuation">{</span>a<span class="token punctuation">..</span>z<span class="token punctuation">}</span><span class="token keyword">echo</span> <span class="token punctuation">{</span>000<span class="token punctuation">..</span>20<span class="token punctuation">..</span>2<span class="token punctuation">}</span></code></pre></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维笔记8</title>
      <link href="/2020/04/18/yun-wei-bi-ji-8/"/>
      <url>/2020/04/18/yun-wei-bi-ji-8/</url>
      
        <content type="html"><![CDATA[<h1 id="运维笔记8"><a href="#运维笔记8" class="headerlink" title="运维笔记8"></a>运维笔记8</h1><h2 id="Shell命令的种类"><a href="#Shell命令的种类" class="headerlink" title="Shell命令的种类"></a><code>Shell</code>命令的种类</h2><ul><li><p>外部命令</p><p>  可以利用<code>type</code>命令来查看命令是否为内部命令，外部命令储存在磁盘上，载入需要比较长的时间。</p></li><li><p>内部命令</p><p>  <code>enable</code>命令可以用来查看内部命令，内部命令在系统上电之后就被自动载入内存，所以执行速度快。</p></li></ul><h2 id="命令的格式"><a href="#命令的格式" class="headerlink" title="命令的格式"></a>命令的格式</h2><ul><li><p><code>COMMAND [OPTIONS...] [ARGUMENTS...]</code></p><ol><li><p>选项：用于启用或关闭命令的某个或某些功能。</p><ul><li>短选项：<code>-c</code> 例如：<code>-l</code>，<code>-h</code></li><li>长选项：<code>--word</code> 例如：<code>--all</code>，<code>--human-readable</code></li></ul></li><li><p>参数：命令的作用对象，比如文件名用户名等</p></li></ol></li><li><p>注意</p><ol><li>多个选项以及多参数和命令之间使用空白字符分割</li><li>取消和结束命令执行：<code>Ctrl+c</code>，<code>Ctrl+d</code></li><li>多个命令可以使用<code>;</code>号隔开</li><li>一个命令可以用<code>\</code>分成多行</li></ol></li></ul><h2 id="管理内部命令的办法"><a href="#管理内部命令的办法" class="headerlink" title="管理内部命令的办法"></a>管理内部命令的办法</h2><ul><li><code>enable</code>命令可以用来管理内部命令。</li><li><code>enable -n [command]</code>命令可以用来禁用该命令。</li><li><code>enable [command]</code>命令可以用来恢复命令，是命令使能。</li><li><code>enable -n</code>可以用来查看所有被禁用的命令。</li></ul><h2 id="系统执行命令的过程（按照如下顺序执行）"><a href="#系统执行命令的过程（按照如下顺序执行）" class="headerlink" title="系统执行命令的过程（按照如下顺序执行）"></a>系统执行命令的过程（按照如下顺序执行）</h2><ol><li><p>检查别名<code>alias</code>内部是否有和输入命令相同的命令，有的话使用该命令。否则进行下一步。</p><ul><li><p><code>alias [name]=["command"]</code>可以用来定义命令的别名<code>alias</code>。使用这种方法定义别名<code>alias</code>仅仅是暂时性的，如果重新登录或者重启系统，该别名会失效，如果想要使别名<code>alias</code>永久有效，需要使用下面的操作。</p></li><li><p>如果想要使别名<code>alias</code>永久性生效，需要将别名写入<code>/etc/.bashrc</code>文件中，这个会设置所有用户的别名，如果仅仅想要设置特定用户的别名，需要在该用户的家目录下寻找<code>.bashrc</code>文件，将别名写入该文件。</p></li><li><p>如果要使得这个文件的修改立刻生效，有如下几种方法</p><ol><li>重启终端或者重启系统。</li><li>使用<code>source .bashrc</code>或<code>. .bashrc</code>命令可以使得配置文件生效。其中<code>source</code>命令与<code>.</code>命令等价。</li></ol></li><li><p>使用<code>unalias</code>命令可以删除别名。</p></li><li><p>使用<code>\[aliasname]</code>可以忽略别名。</p></li></ul></li><li><p>判断命令是否为内部命令，否则执行下一步。</p></li><li><p>判断hash表里是否有该命令，有的话按照hash表找到命令所在位置，执行命令，否则进行下一步。</p><ul><li>使用<code>hash</code>命令可以查看命令的缓存情况，并可以查看命令的命中次数，即缓存的命中率，利用了存储器的局部性原理。</li><li>使用<code>hash -d [command]</code>命令可以删除hash表里面的命令。</li><li>使用<code>hash -r</code>命令可以删除hash表中所有的命令。</li><li>hash表中记录了外部命令所在的路径。</li></ul></li><li><p>判断是否命令存储在外存中，否则执行下一步。其中<code>$PATH</code>记录了命令在外存中的位置。</p></li><li><p>发送命令找不到提示。</p></li></ol><h2 id="命令的等待、命令的终止与单行多命令的写法"><a href="#命令的等待、命令的终止与单行多命令的写法" class="headerlink" title="命令的等待、命令的终止与单行多命令的写法"></a>命令的等待、命令的终止与单行多命令的写法</h2><ul><li><p>多命令写在单行内</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>command1<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">[</span>command2<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">[</span>command3<span class="token punctuation">]</span></code></pre></li><li><p>命令终止</p><p>  可以使用快捷键<code>ctrl + c</code>或者<code>ctrl + d</code>。</p></li><li><p>命令的等待</p><p>  可以使用<code>sleep [n]</code>命令来等待，<code>n</code>表示等待的时间，以秒为单位。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维笔记7</title>
      <link href="/2020/04/14/yun-wei-bi-ji-7/"/>
      <url>/2020/04/14/yun-wei-bi-ji-7/</url>
      
        <content type="html"><![CDATA[<h1 id="运维笔记7"><a href="#运维笔记7" class="headerlink" title="运维笔记7"></a>运维笔记7</h1><h2 id="操作系统与配置信息查看相关命令"><a href="#操作系统与配置信息查看相关命令" class="headerlink" title="操作系统与配置信息查看相关命令"></a>操作系统与配置信息查看相关命令</h2><ul><li><p>查看当前系统版本</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> /etc/centos-release</code></pre></li><li><p>查看当前系统内核版本命令</p><pre class=" language-bash"><code class="language-bash"><span class="token function">uname</span> -r</code></pre></li><li><p>查看各项电脑硬件信息</p><ol><li><p>查看CPU信息</p><pre class=" language-bash"><code class="language-bash">lscpu</code></pre></li><li><p>查看内存信息</p><pre class=" language-bash"><code class="language-bash"><span class="token function">free</span> -h<span class="token function">cat</span> /proc/meminfo</code></pre></li><li><p>查看硬盘信息</p><pre class=" language-bash"><code class="language-bash">lsblk</code></pre></li><li><p>查看网卡信息</p><pre class=" language-bash"><code class="language-bash">mii-tool <span class="token punctuation">[</span>接口名<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#mii-tool ens33 or mii-tool eth0</span></code></pre></li></ol></li><li><p>查看用户信息</p><pre class=" language-bash"><code class="language-bash"><span class="token function">who</span> <span class="token comment" spellcheck="true">#查看所有用户信息</span><span class="token function">who</span> am i <span class="token comment" spellcheck="true">#查看当前登录的用户信息</span></code></pre></li><li><p>查询当前使用的shell类型</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token variable">$SHELL</span></code></pre></li></ul><h2 id="常用系统设置"><a href="#常用系统设置" class="headerlink" title="常用系统设置"></a>常用系统设置</h2><ul><li><p>设置网络开机自动连接</p><pre class=" language-bash"><code class="language-bash">nmcli connection modify ens33 connection.autoconnection <span class="token function">yes</span></code></pre></li><li><p>更改并查看ip信息</p><pre class=" language-bash"><code class="language-bash">vim /etc/sysconfig/network-scripts/ifcfg-eth0 <span class="token comment" spellcheck="true">#打开网卡设置文件后更改内部信息即可</span><span class="token function">service</span> network restart <span class="token comment" spellcheck="true">#重启网络服务</span></code></pre></li><li><p>设置motd文件，更改登录初始界面</p><pre class=" language-bash"><code class="language-bash">vim /etc/motd</code></pre><pre class=" language-bash"><code class="language-bash">                   _ooOoo_                  o8888888o                  88<span class="token string">" . "</span>88                  <span class="token punctuation">(</span><span class="token operator">|</span> -_- <span class="token operator">|</span><span class="token punctuation">)</span>                  O\  <span class="token operator">=</span>  /O               ____/`---<span class="token string">'\____             .'</span>  \\<span class="token operator">|</span>     <span class="token operator">|</span>//  `.            /  \\<span class="token operator">||</span><span class="token operator">|</span>  <span class="token keyword">:</span>  <span class="token operator">||</span><span class="token operator">|</span>//  \           /  _<span class="token operator">||</span><span class="token operator">||</span><span class="token operator">|</span> -:- <span class="token operator">||</span><span class="token operator">||</span><span class="token operator">|</span>-  \           <span class="token operator">|</span>   <span class="token operator">|</span> \\\  -  /// <span class="token operator">|</span>   <span class="token operator">|</span>           <span class="token operator">|</span> \_<span class="token operator">|</span>  <span class="token string">''</span>\---/<span class="token string">''</span>  <span class="token operator">|</span>   <span class="token operator">|</span>           \  .-\__  <span class="token variable"><span class="token variable">`</span>-<span class="token variable">`</span></span>  ___/-. /         ___`. <span class="token keyword">.</span><span class="token string">'  /--.--\  `. . __      ."" '</span><span class="token operator">&lt;</span>  `.___\_<span class="token operator">&lt;</span><span class="token operator">|</span><span class="token operator">></span>_/___.<span class="token string">'  >'</span><span class="token string">""</span><span class="token keyword">.</span>     <span class="token operator">|</span> <span class="token operator">|</span> <span class="token keyword">:</span>  <span class="token variable"><span class="token variable">`</span>- \<span class="token variable">`</span></span><span class="token keyword">.</span><span class="token punctuation">;</span><span class="token variable"><span class="token variable">`</span>\ _ /<span class="token variable">`</span></span><span class="token punctuation">;</span><span class="token keyword">.</span><span class="token variable"><span class="token variable">`</span>/ - <span class="token variable">`</span></span> <span class="token keyword">:</span> <span class="token operator">|</span> <span class="token operator">|</span>     \  \ <span class="token variable"><span class="token variable">`</span>-.   \_ __\ /__ _/   .-<span class="token variable">`</span></span> /  /<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token variable"><span class="token variable">`</span>-.____<span class="token variable">`</span></span>-.___\_____/___.-`____.-<span class="token string">'======                   `=---='</span>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^           佛祖保佑       永不死机           心外无法       法外无心</code></pre></li><li><p>设置提示符样式和颜色</p><ul><li><p>更改<code>PS1</code>变量内容</p><pre class=" language-bash"><code class="language-bash">PS1<span class="token operator">=</span><span class="token string">"\[\e[1;5;41;33m\][\u@\h \W]\\$\[\e[0m\]"</span></code></pre></li><li><p><code>PS1</code>变量含义</p><pre class=" language-bash"><code class="language-bash">\e \033            \u 当前用户名\h 主机名简称       \H 主机名\w 当前工作目录     \W 当前工作目录名\t 24小时时间格式   \T 12小时时间格式\<span class="token operator">!</span> 命令历史数       \# 开机后的命令历史数</code></pre></li></ul></li><li><p>设置系统开机自动登录功能</p><ol><li><p>打开<code>GDM</code>配置文件</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> gedit /etc/gdm/custom.conf</code></pre></li><li><p>增加如下条目</p><pre class=" language-bash"><code class="language-bash">AutomaticLoginEnable<span class="token operator">=</span>trueAutomaticLogin<span class="token operator">=</span>add_your_username_here</code></pre></li><li><p>重启系统</p></li></ol></li><li><p>关闭防火墙</p><ol><li><p>在CentOS7上执行如下命令可以关闭防火墙</p><pre class=" language-bash"><code class="language-bash">systemctl stop firewalld <span class="token comment" spellcheck="true">#关闭服务</span>systemctl disable firewalld <span class="token comment" spellcheck="true">#设置开机不启动</span></code></pre></li><li><p>在CentOS6上执行如下命令可以关闭防火墙</p><pre class=" language-bash"><code class="language-bash"><span class="token function">service</span> iptables stop <span class="token comment" spellcheck="true">#关闭服务</span><span class="token function">chkconfig</span> iptables off <span class="token comment" spellcheck="true">#设置开机不启动</span></code></pre></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维笔记6</title>
      <link href="/2020/04/14/yun-wei-bi-ji-6/"/>
      <url>/2020/04/14/yun-wei-bi-ji-6/</url>
      
        <content type="html"><![CDATA[<h1 id="运维笔记6"><a href="#运维笔记6" class="headerlink" title="运维笔记6"></a>运维笔记6</h1><h2 id="终端（terminal）的分类"><a href="#终端（terminal）的分类" class="headerlink" title="终端（terminal）的分类"></a>终端（terminal）的分类</h2><ul><li><p>设备终端（terminal）</p><p>  鼠标、键盘、显示器</p></li><li><p>物理终端（/dev/console）</p><p>  控制台（console）</p></li><li><p>虚拟终端（tty：teletypewriters，/dev/tty# #为1~6）</p><p>  tty可以有多个，可以使用快捷键<code>ctrl + alt + f[1-6]</code>来切换终端。</p></li><li><p>图形终端（/dev/tty7）</p><ul><li>图形终端可以通过<code>startx</code>命令启用，使用这个命令启动的图形终端实际上并没有新建图形终端，而是启动了xwindows的软件。</li><li>在CentOS6中新建图形终端可以使用快捷键<code>ctrl + alt + f7</code>来启动图形终端。</li><li>在CentOS7中，图形终端在哪个虚拟终端启动，就位于哪个虚拟终端。</li></ul></li><li><p>串行终端（/dev/ttys#）</p><ul><li>ttys</li></ul></li><li><p>伪终端（pty：pseudo-tty，/dev/pts/#）</p><ul><li>图形终端</li></ul></li><li><p>查看当前图形设备命令</p><ul><li>使用命令<code>tty</code>便可以查看当前的终端设备。</li></ul></li><li><p>切换终端命令</p><ul><li>使用命令<code>chvt</code>可以切换终端。</li></ul></li></ul><h2 id="交互式接口"><a href="#交互式接口" class="headerlink" title="交互式接口"></a>交互式接口</h2><ul><li><p>GUI：Graphic User Interface 基于X协议</p><ul><li>X protocol，Window Manager，Desktop。Desktop：GNOME，KDE，XFCE（图形库，gtk，qt）</li></ul></li><li><p>CLI：Command Line Interface</p><ul><li>Shell程序：sh、csh、tcsh、ksh、bash、zsh</li></ul></li></ul><h2 id="系统的7个运行级别（runlevel）"><a href="#系统的7个运行级别（runlevel）" class="headerlink" title="系统的7个运行级别（runlevel）"></a>系统的7个运行级别（runlevel）</h2><ul><li><p>运行级别0</p><ul><li>系统停机状态，系统默认运行级别不能设为0，否则不能正常启动。</li></ul></li><li><p>运行级别1</p><ul><li>单用户工作状态，root权限，用于系统维护，禁止远程登录。</li></ul></li><li><p>运行级别2</p><ul><li>多用户状态(没有NFS)。</li></ul></li><li><p>运行级别3</p><ul><li>完全的多用户状态(有NFS)，登陆后进入控制台命令行模式。</li></ul></li><li><p>运行级别4</p><ul><li>系统未使用，保留。</li></ul></li><li><p>运行级别5</p><ul><li>X11控制台，登陆后进入图形GUI模式。</li></ul></li><li><p>运行级别6</p><ul><li>系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动。</li></ul></li><li><p>运行级别的切换</p><ul><li><p>使用如下命令可以切换。</p><pre class=" language-bash"><code class="language-bash">init n <span class="token comment" spellcheck="true">#init 3切换字符终端，init 5切换图形终端。</span></code></pre></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维笔记5</title>
      <link href="/2020/04/13/yun-wei-bi-ji-5/"/>
      <url>/2020/04/13/yun-wei-bi-ji-5/</url>
      
        <content type="html"><![CDATA[<h1 id="运维笔记5"><a href="#运维笔记5" class="headerlink" title="运维笔记5"></a>运维笔记5</h1><h2 id="设置Linux系统本地时间，使用ntp服务器设置"><a href="#设置Linux系统本地时间，使用ntp服务器设置" class="headerlink" title="设置Linux系统本地时间，使用ntp服务器设置"></a>设置Linux系统本地时间，使用ntp服务器设置</h2><ul><li><p>使用ntp服务器设置可以精确设置时间，并且在时区设置正确地情况下，保证时间的正确性。</p></li><li><p>使用ntp服务器设置系统时间需要使用如下命令。</p><pre class=" language-bash"><code class="language-bash">ntpdate <span class="token punctuation">[</span>serverIP<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#ntpdate 130.88.202.49 this server is in UK</span></code></pre></li><li><p><code>ntpdate</code>命令仅仅是更新了系统时间（date），如果需要更新硬件时间（clock），还需要使用如下命令</p><pre class=" language-bash"><code class="language-bash">clock -w <span class="token comment" spellcheck="true">#this command could set hardware time using os time</span></code></pre></li><li><p>如果需要通过硬件时间来设置软件时间，则可以使用如下命令</p><pre class=" language-bash"><code class="language-bash">clock -s <span class="token comment" spellcheck="true">#this command could set os time using hardware time</span></code></pre></li><li><p>设置时区的方法</p><ul><li><p>使用如下命令可以查看时区设置</p><pre class=" language-bash"><code class="language-bash">timedatectl</code></pre></li><li><p>使用如下命令可以设置时区</p><pre class=" language-bash"><code class="language-bash">timedatectl set-timezone Europe/London</code></pre></li></ul></li></ul><h2 id="更改主机名（hostname）的方法"><a href="#更改主机名（hostname）的方法" class="headerlink" title="更改主机名（hostname）的方法"></a>更改主机名（hostname）的方法</h2><ul><li><p>在CentOS中可以永久性更改主机名（hostname），也可以非永久性更改主机名。</p><ol><li><p>非永久性更改主机名</p><ul><li>使用hostname命令来更改主机名（hostname），但是重新启动电脑之后会失效，命令如下。</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">hostname</span> <span class="token punctuation">[</span>主机名<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#hostname CentOS7</span></code></pre></li><li><p>永久性更改主机名</p><ul><li>在CentOS6和CentOS7中使用的方法是不同的。在CentOS6中，我们使用如下命令找到配置文件<code>network</code>，并用vim打开。</li></ul><pre class=" language-bash"><code class="language-bash">vim /etc/sysconfig/network</code></pre><ul><li>打开文件之后，添加如下条目到文件中,即可永久性设置CentOS6主机名。</li></ul><pre class=" language-bash"><code class="language-bash">HOSTNAME<span class="token operator">=</span><span class="token punctuation">[</span>hostname<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#HOSTNAME=centos6.localdomain</span></code></pre><ul><li>在CentOS7中我们可以使用如下命令打开主机名设置文件。</li></ul><pre class=" language-bash"><code class="language-bash">vim /etc/hostname</code></pre><ul><li>在内部添加如下条目即可永久性设置CentOS7主机名。</li></ul><pre class=" language-bash"><code class="language-bash">HOSTNAME<span class="token operator">=</span><span class="token punctuation">[</span>hostname<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#HOSTNAME=centos7.localdomain</span></code></pre></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维笔记4</title>
      <link href="/2020/04/13/yun-wei-bi-ji-4/"/>
      <url>/2020/04/13/yun-wei-bi-ji-4/</url>
      
        <content type="html"><![CDATA[<h1 id="运维笔记4"><a href="#运维笔记4" class="headerlink" title="运维笔记4"></a>运维笔记4</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><ul><li>在使用SSH连接的时候，我发现登录等待提示输入密码的时间特别久，并且会出现一段时间之后掉线的情况，于是我上网搜索了如何解决这一问题，找到了解决方案，现在记录在这里。</li></ul><h2 id="如何解决PUTTY-secureCRT等SSH软件连接虚拟机一段时间之后掉线的问题"><a href="#如何解决PUTTY-secureCRT等SSH软件连接虚拟机一段时间之后掉线的问题" class="headerlink" title="如何解决PUTTY,secureCRT等SSH软件连接虚拟机一段时间之后掉线的问题"></a>如何解决PUTTY,secureCRT等SSH软件连接虚拟机一段时间之后掉线的问题</h2><ul><li>在使用虚拟机的时候，点击编辑-&gt;虚拟网络编辑器-&gt;更改设置-&gt;仅主机模式-&gt;DHCP设置里，修改默认租用时间，可以任意修改，这个可以解决虚拟机SSH连接情况下，一段时间后掉线的问题。</li></ul><h2 id="如何解决PUTTY-secureCRT等SSH软件连接虚拟机卡顿的现象。"><a href="#如何解决PUTTY-secureCRT等SSH软件连接虚拟机卡顿的现象。" class="headerlink" title="如何解决PUTTY,secureCRT等SSH软件连接虚拟机卡顿的现象。"></a>如何解决PUTTY,secureCRT等SSH软件连接虚拟机卡顿的现象。</h2><ul><li>修改配置文件设置，配置文件路径为<code>/etc/ssh/sshd_config</code>,修改内部两条内容如下，即可解决该问题。</li></ul><pre class=" language-bash"><code class="language-bash">GSSAPIAuthentication noUseDNS no</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维常用命令大集合</title>
      <link href="/2020/04/13/yun-wei-chang-yong-ming-ling-da-ji-he/"/>
      <url>/2020/04/13/yun-wei-chang-yong-ming-ling-da-ji-he/</url>
      
        <content type="html"><![CDATA[<h1 id="运维常用命令大集合"><a href="#运维常用命令大集合" class="headerlink" title="运维常用命令大集合"></a>运维常用命令大集合</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>在学习CentOS运维技术的时候，每次学习都会遇到特别多的命令，为了方便后期记忆学习，将这些命令整理在这里。</p><h2 id="命令集合"><a href="#命令集合" class="headerlink" title="命令集合"></a>命令集合</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">alias</span> <span class="token comment" spellcheck="true">#别名设置</span>authconfig<span class="token function">basename</span> <span class="token comment" spellcheck="true">#基名</span><span class="token function">cat</span> /etc/centos-release <span class="token comment" spellcheck="true">#print centos version info</span><span class="token function">cal</span> <span class="token comment" spellcheck="true">#print calendar</span><span class="token function">cd</span>  <span class="token comment" spellcheck="true">#change dir</span>chagechfnchshchpasswdclock <span class="token comment" spellcheck="true">#print hardware clock</span><span class="token function">cp</span> <span class="token comment" spellcheck="true">#copy command</span><span class="token function">clear</span> ctrl+L <span class="token comment" spellcheck="true">#clear session command</span><span class="token function">date</span> <span class="token comment" spellcheck="true">#print software clock</span><span class="token function">dd</span> <span class="token comment" spellcheck="true">#convert and copy file</span><span class="token function">dirname</span> <span class="token comment" spellcheck="true">#目录名</span><span class="token function">df</span> <span class="token comment" spellcheck="true">#reporting file system disk space usage</span><span class="token function">du</span> <span class="token comment" spellcheck="true">#estimated amount of disk space used by given files or directories</span><span class="token keyword">exit</span> <span class="token comment" spellcheck="true">#quit session or logout</span><span class="token function">enable</span> <span class="token comment" spellcheck="true">#enable builtin command</span><span class="token keyword">echo</span> <span class="token variable">$SHELL</span> <span class="token comment" spellcheck="true">#show which bash is used</span><span class="token function">file</span> <span class="token comment" spellcheck="true">#print file type analyze the file type</span>finger <span class="token comment" spellcheck="true">#查询个人信息</span>getent <span class="token comment" spellcheck="true">#查看条目 shadow passwd group gshadow</span>grpck<span class="token function">groupadd</span><span class="token function">groupmod</span><span class="token function">groupdel</span><span class="token function">groups</span>groupmemsgpasswdhalt <span class="token comment" spellcheck="true">#stop operating but without power off</span><span class="token function">hash</span> <span class="token comment" spellcheck="true">#check the command stored in cache and corresponding hit time</span><span class="token function">help</span> <span class="token comment" spellcheck="true">#literal meaning</span>hexdump <span class="token comment" spellcheck="true">#display  file contents in hexadecimal, decimal, octal, or ascii</span><span class="token function">history</span> <span class="token comment" spellcheck="true">#print command history</span><span class="token function">hostname</span> <span class="token comment" spellcheck="true">#print hostname if you want to change hostname you should do it in /etc/hostname(centos7) /etc/hostname(centos6)</span><span class="token function">iconv</span> <span class="token comment" spellcheck="true">#字符编码转换</span>info <span class="token comment" spellcheck="true">#find help info in this </span>init 3 5 0 6 <span class="token comment" spellcheck="true">#set runlevel</span><span class="token function">id</span> -u <span class="token comment" spellcheck="true">#print current user id</span><span class="token function">logout</span> ctrl+d <span class="token comment" spellcheck="true">#literal meaning</span>ll <span class="token comment" spellcheck="true">#ll == ls -l</span>lsblk <span class="token comment" spellcheck="true">#list info on block device</span><span class="token function">ls</span> <span class="token comment" spellcheck="true">#list file</span><span class="token function">lsof</span> <span class="token comment" spellcheck="true">#列出被进程打开的文件</span>lscpu <span class="token comment" spellcheck="true">#print cpu info</span>lsb_release -a <span class="token comment" spellcheck="true">#check os info (centos6)</span><span class="token function">ln</span> <span class="token comment" spellcheck="true">#构造硬链接</span><span class="token function">ln</span> -s <span class="token comment" spellcheck="true">#构造软链接</span>localectl  <span class="token comment" spellcheck="true">#设置显示字符集和语言</span><span class="token function">man</span> <span class="token comment" spellcheck="true">#find manual help</span>mandb <span class="token comment" spellcheck="true">#makewhatis 安装库</span>mii-tool <span class="token punctuation">[</span>interfacename<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#print info on interface eth0(centos6) ens33(centos7)</span>nmcli connection modify ens33 connection.autoconnect <span class="token function">yes</span> <span class="token comment" spellcheck="true">#set auto internet connect after booting</span><span class="token function">mv</span> <span class="token comment" spellcheck="true">#移动文件</span><span class="token function">nano</span> <span class="token comment" spellcheck="true">#file editor</span>newgrp <span class="token comment" spellcheck="true">#临时切换主组</span>newusers <span class="token comment" spellcheck="true">#批量创建用户 </span>ntpdate<span class="token comment" spellcheck="true">#网络时间协议服务器ntp</span>poweroff <span class="token comment" spellcheck="true">#关机</span><span class="token function">ps</span> <span class="token comment" spellcheck="true">#show process</span><span class="token function">pwd</span> <span class="token comment" spellcheck="true">#print current working dir</span>pwck<span class="token function">reboot</span> <span class="token comment" spellcheck="true">#重启</span><span class="token function">rename</span> <span class="token comment" spellcheck="true">#重新命名文件</span>reset <span class="token comment" spellcheck="true">#重置当前窗口</span><span class="token function">rm</span> <span class="token comment" spellcheck="true">#删除文件</span><span class="token function">rmdir</span> <span class="token comment" spellcheck="true">#删除文件夹</span>runlevel <span class="token comment" spellcheck="true">#running mode</span>rpm -ivh <span class="token comment" spellcheck="true">#install software</span>rz <span class="token comment" spellcheck="true">#传输文件</span><span class="token function">screen</span> <span class="token comment" spellcheck="true">#投屏软件，需要安装 rpm -ivh [安装光盘挂载点]</span><span class="token function">shutdown</span> <span class="token comment" spellcheck="true">#关机</span><span class="token function">sleep</span> <span class="token comment" spellcheck="true">#等待 sleep [n] 等待n秒</span>startx <span class="token comment" spellcheck="true">#use GUI</span><span class="token function">stat</span> <span class="token comment" spellcheck="true">#可以看到文件的三个时间 ctime, atime, mtime</span>sosreport <span class="token comment" spellcheck="true">#红帽信息收集包</span>source<span class="token operator">==</span>. <span class="token comment" spellcheck="true">#make config. file take effect</span><span class="token function">su</span> <span class="token comment" spellcheck="true">#带-号完全切换，不带-号不完全切换</span>sz <span class="token function">file</span> <span class="token comment" spellcheck="true">#传输文件</span>tree <span class="token comment" spellcheck="true">#树型显示目录内容</span><span class="token function">type</span> <span class="token comment" spellcheck="true">#show command type</span><span class="token function">tty</span> <span class="token comment" spellcheck="true">#session</span>timedatectl <span class="token comment" spellcheck="true">#print system time info</span><span class="token function">touch</span> <span class="token comment" spellcheck="true">#create file</span><span class="token function">unalias</span> <span class="token comment" spellcheck="true">#cancel alias</span><span class="token function">uname</span> -r <span class="token comment" spellcheck="true">#print kernel info</span><span class="token function">useradd</span><span class="token function">usermod</span><span class="token function">userdel</span>vipwvigr<span class="token keyword">.</span> .bashrc <span class="token comment" spellcheck="true">#make .bashrc file take effect</span>w <span class="token comment" spellcheck="true">#print terminal and user info</span><span class="token function">which</span> <span class="token comment" spellcheck="true">#show the full path of command</span><span class="token function">whereis</span> <span class="token comment" spellcheck="true">#locate the binary, source, and manual page files for a command</span><span class="token function">who</span> <span class="token comment" spellcheck="true">#show who is log on</span><span class="token function">whoami</span> <span class="token comment" spellcheck="true">#print effective userid</span>whatis <span class="token comment" spellcheck="true">#查看帮助</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">#可以分割多条命令，在一行内执行多条命令</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维笔记3</title>
      <link href="/2020/04/12/yun-wei-bi-ji-3/"/>
      <url>/2020/04/12/yun-wei-bi-ji-3/</url>
      
        <content type="html"><![CDATA[<h1 id="运维笔记3（Linux系统安装）"><a href="#运维笔记3（Linux系统安装）" class="headerlink" title="运维笔记3（Linux系统安装）"></a>运维笔记3（Linux系统安装）</h1><h2 id="Linux系统与Windows系统的区别"><a href="#Linux系统与Windows系统的区别" class="headerlink" title="Linux系统与Windows系统的区别"></a>Linux系统与Windows系统的区别</h2><ul><li>Windows系统中磁盘分区用盘符，Linux使用目录名。</li><li>Windows中的硬盘资源被认为是各自独立的。</li><li>Windows中的根目录用反斜线<code>\</code>表示，而Linux中用正斜线<code>/</code>表示。</li><li>Windows中有多少个盘符就多少个根目录，Linux中只有一个根目录。</li><li>Linux中挂载的概念是指将设备分配一个目录名。</li></ul><h2 id="Linux目录含义"><a href="#Linux目录含义" class="headerlink" title="Linux目录含义"></a>Linux目录含义</h2><ul><li><code>/usr</code>目录中存放了大量的系统文件。</li><li><code>/home</code>目录中存放了用户的信息。</li><li><code>/boot</code>目录用来存放启动文件。</li><li><code>/tmp</code>目录用来存放临时文件。</li><li><code>/var/log</code>用来存放日志。</li><li><code>/dev</code>目录中存放了各种硬件信息。</li><li><code>/dev/sda or /sdb or ...</code>表示磁盘的分区。</li></ul><h2 id="Linux分区概述"><a href="#Linux分区概述" class="headerlink" title="Linux分区概述"></a>Linux分区概述</h2><ul><li>分区策略：MBR策略，GPT策略。</li><li>分区的分类：主分区（1–4），扩展分区，逻辑分区。</li><li>主分区：一个硬盘上最多只能有4个主分区，主分区是最小的单位，不可以进行分割，活动状态只能有一个。</li><li>扩展分区：最多一个，要划分成更小的逻辑分区 1–4。</li><li>逻辑分区：分区号从5开始</li><li>只有将分区挂载到文件夹之后才能使用。</li></ul><h2 id="Linux分区规划"><a href="#Linux分区规划" class="headerlink" title="Linux分区规划"></a>Linux分区规划</h2><ul><li><code>/boot</code>可以单独放一个分区，用来存放启动文件，一般大小设置为1G。</li><li><code>/</code>根分区，一般大小为50G。</li><li><code>/data</code>分区，专门设置为了学习用的分区，实际生产中可以不加入这个分区，这里设置为30G。</li><li><code>swap</code>分区，这里采用了虚拟内存技术，为了防止内存不足的情况发生，虚拟内存大小一般为实际内存的2倍左右。</li></ul><h2 id="VMWARE中网络适配器三种模式详解"><a href="#VMWARE中网络适配器三种模式详解" class="headerlink" title="VMWARE中网络适配器三种模式详解"></a>VMWARE中网络适配器三种模式详解</h2><ul><li>仅主机模式：虚拟机只能在电脑内部进行通信，即只和其他本地虚拟机和Windows主机相连。</li><li>NAT模式：虚拟机可以和外部机器通信，但外部机器无法与之相连。</li><li>桥接模式：可以正常访问外部网络。</li></ul><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol><li>下载相应的光盘文件，下载完成之后验证，使用<code>sha1sum</code>与云盘上的信息做对比，这是Linux特有的工具。</li><li>创建分区。设置标准分区，默认文件系统，并且按照之前的分区规划设置分区。</li><li>设置root用户名称密码。</li><li>按照提示进行接下来的操作即可。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维笔记2</title>
      <link href="/2020/04/12/yun-wei-bi-ji-2/"/>
      <url>/2020/04/12/yun-wei-bi-ji-2/</url>
      
        <content type="html"><![CDATA[<h1 id="运维笔记2（Linux服务器简介）"><a href="#运维笔记2（Linux服务器简介）" class="headerlink" title="运维笔记2（Linux服务器简介）"></a>运维笔记2（Linux服务器简介）</h1><h2 id="Linux的哲学思想"><a href="#Linux的哲学思想" class="headerlink" title="Linux的哲学思想"></a>Linux的哲学思想</h2><ul><li>一切都是文件</li><li>小型，单一用途的程序</li><li>链接程序，完成复杂任务</li><li>避免过多的令人困惑的图形界面</li><li>配置数据储存在文本中</li></ul><h2 id="Linux机器架构（自顶向下）"><a href="#Linux机器架构（自顶向下）" class="headerlink" title="Linux机器架构（自顶向下）"></a>Linux机器架构（自顶向下）</h2><hr><ul><li>APP（Userspace）</li><li>OS（Kernelspace）</li><li>虚拟层（Kernelspace）</li><li>硬件层</li></ul><hr><ul><li>虚拟化技术使得一个服务器可以搭载多个系统</li><li>应用软件如果需要访问硬件资源需要经过Kernel</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统笔记1（操作系统概述）</title>
      <link href="/2020/04/10/cao-zuo-xi-tong-bi-ji-1/"/>
      <url>/2020/04/10/cao-zuo-xi-tong-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统笔记1（操作系统概述）"><a href="#操作系统笔记1（操作系统概述）" class="headerlink" title="操作系统笔记1（操作系统概述）"></a>操作系统笔记1（操作系统概述）</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>操作系统作为计算机的应用程序和硬件沟通的接口，保证了计算机能够正常运行各种程序，并且保证了程序不会因为硬件的不同而要改变程序内部的代码。为了之后的学习，在这里再开一个新坑，用来记录学习操作系统的心得。</p><h2 id="操作系统概览"><a href="#操作系统概览" class="headerlink" title="操作系统概览"></a>操作系统概览</h2><ul><li>定义：用于管理计算机硬件和软件的软件。提供了用户与硬件交互的接口。</li><li>产生原因：不能直接操作计算机硬件，设备种类繁多复杂，为了统一接口，研制出来了操作系统，使得更多人可以使用计算机。</li><li>好处：用户无需面向硬件编程，即操作系统实现了对硬件资源的抽象。</li></ul><h2 id="操作系统的相关概念"><a href="#操作系统的相关概念" class="headerlink" title="操作系统的相关概念"></a>操作系统的相关概念</h2><ul><li><p>并发性 VS 并行性</p><ol><li>并行性：两个或多个事件可以在同一个时刻发生，即多道程序同时运行。</li><li>并发性：两个或多个事件可以在同一段时间段内发生，即多道程序交替运行。</li></ol></li><li><p>共享性<br>主存被多个程序同时使用，计算机中存在两种共享性。</p><ol><li>互斥共享<br>  当资源被程序A使用时，其他程序想要使用只能等待。</li><li>同时访问<br>  某一资源在同一段时间内可以被多个程序共享。</li></ol></li><li><p>虚拟性<br>把物理实体转化为多个逻辑实体，虚拟的技术主要由时分复用技术和空分复用技术。</p><ol><li><p>时分复用技术：资源在时间上进行复用，不同的程序并发使用。  </p><ul><li>虚拟处理器技术  <ol><li>借助多道程序设计技术（并发多线程技术）</li><li>为每一个程序建立进程。</li><li>多个程序分时复用处理器。</li></ol></li><li>虚拟设备技术<ol><li>物理设备虚拟为为多个逻辑设备。</li><li>每个程序占用一个逻辑设备。</li><li>多个程序通过逻辑设备并发访问。</li></ol></li></ul></li><li><p>空分复用技术：资源在不同空间中被复用。</p><ul><li>虚拟磁盘技术<ol><li>物理磁盘虚拟为逻辑磁盘（CDE盘）</li></ol></li><li>虚拟内存技术<ol><li>在逻辑上扩大了储存容量。</li><li>使用比实际内存更大的容量。</li><li>大大提升了编程效率。</li></ol></li></ul></li></ol></li><li><p>异步性<br>  在多道程序的环境下，允许多个进程并发执行，进程在使用资源时可能需要等待或者放弃，会存在进程的不可预知性。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维笔记1</title>
      <link href="/2020/04/09/yun-wei-bi-ji-1/"/>
      <url>/2020/04/09/yun-wei-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<h1 id="运维笔记1（计算机知识简介）"><a href="#运维笔记1（计算机知识简介）" class="headerlink" title="运维笔记1（计算机知识简介）"></a>运维笔记1（计算机知识简介）</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>我的名字是张博闻，这是我的运维笔记。运维技术作为支撑性技术，需要Linux操作系统技术，服务器架构技术以及计算机网络技术等，是一个综合性比较强的技术领域。我对运维技术比较感兴趣，最近闲暇时间也比较多，就打算开一个新坑，记录一下自己的运维技术学习过程。</p><h2 id="运维涉及的技术"><a href="#运维涉及的技术" class="headerlink" title="运维涉及的技术"></a>运维涉及的技术</h2><ul><li>web应用：Apache、nginx</li><li>数据库管理软件：MySQL、Oracle</li><li>阿里巴巴提出的去IOE策略：去除IBM、Oracle、EMC</li><li>文件共享技术：WFS、SAMBA、FTP</li><li>中间件应用：TOMCAT</li><li>日志服务：RSYSLOG</li><li>监控：ZABBIX</li><li>版本控制软件：Git</li><li>虚拟机：KVM、DOCKER、K8S</li><li>邮件服务：SENDMAIL</li><li>域控制器：DM（Domain Control）、AD</li></ul><h2 id="服务器的分类"><a href="#服务器的分类" class="headerlink" title="服务器的分类"></a>服务器的分类</h2><ol><li>塔式服务器<br>类似于个人台式机，使用的比较少</li><li>刀片式服务器<br>在机箱中加入卡片式服务器，实现高性能计算，用得比较少</li><li>机架式服务器<br>用得比较广泛，并且大小的规格统一，高度统一用单位U来表示，1个U约等于5cm。主流的机箱一般都是1U、2U以及4U。机箱的宽度也是固定的，统一为19英寸（48.26cm）。深度的规格不固定，一般有600mm、800mm以及1000mm，为了防止机箱装不进机柜，一般采用1000mm的机柜。交换机路由器机柜一般可以选600mm。</li></ol><h2 id="服务器的硬件组成"><a href="#服务器的硬件组成" class="headerlink" title="服务器的硬件组成"></a>服务器的硬件组成</h2><ul><li><p>整体配置上来讲与家用电脑很类似，硬盘是可以拆卸式的。这样设计的目的是因为硬盘长期运行容易发生损坏，将硬盘外置可以便于更换。</p></li><li><p>主频，外频和倍频的概念。<br>主频是指CPU的实际运行频率。主频 = 外频 × 倍频。<br>外频是指系统的总线频率。</p></li><li><p>地址总线宽度：代表了CPU可访问的物理地址，比方说现在常用的64位机就是拥有64根系统总线，这个表明计算机可以总共访问$2^{64}$个物理地址单元，这绝对足够我们使用。</p></li><li><p>CPU类型<br>现在主流的CPU类型有x86、x64、ARM、moto、Power。<br>按照架构分类可以分为两种CPU。  </p><ol><li><p>非x86处理器：使用RSIC（精简指令集），该种架构价格比较昂贵，但是稳定性好。</p></li><li><p>x86处理器：使用CISC（复杂指令集），该种架构价格便宜，兼容性好，稳定性差。</p></li></ol></li><li><p>内存带宽<br>内存带宽代表了内存和北桥芯片之间的数据传输速率。北桥芯片一般连接了高速设备。<br>内存带宽 = $\frac{内存总线频率 × 数据总线位数}{8}$<br>内存带宽的数量级为GB/s。</p></li><li><p>服务器硬件的种类和家用电脑相差比较大。  </p><ol><li>服务器的硬盘一般可以选择7200rpm、10000rpm、15000rpm，综合性能和稳定性考虑，一般使用10000rpm的硬盘作为服务器硬盘比较合适。</li><li>硬盘制造厂商一般采用Ki、Mi、Gi、Ti等单位作为内存容量的标称单位，这些单位都是$10^n$的形式。</li><li>硬盘接口：IDE、SCSI、SATA、SAS。其中最后两种是目前比较主流的硬盘接口，SATA电脑主要是用于普通家用电脑，SAS接口一般主要用于服务器设备。</li><li>固态硬盘的使用也是比较主流的。</li><li>采用RAID卡技术提升性能和容错率</li><li>网卡采用10Gbps、20Gbps的高端网卡。普通家用网卡为1Gbps。</li><li>采用热拔插技术，一般以硬盘为主，实现带电的更换硬盘操作。一般裸露在机箱外部的设备都是支持热拔插的，例如，硬盘，电源，PCI设备以及风扇等。</li><li>KVM（Keyboard Video Mouse）设备，用作维护人员和服务器的接口。</li><li>PDU（Power Distribution Unit），电源管理单元。</li></ol></li><li><p>储存网络</p><ol><li>DAS 直接连接储存（Direct Attached Storage）硬盘与计算机直连。</li><li>NAS 网络连接储存（Network Attached Storage）不能操作服务器，例如FTP服务器。</li><li>SAN 储存区域网络（Storage Area Network）以块的形式访问。</li></ol></li><li><p>操作系统</p><ol><li>服务器OS：RHEL，CentOS， Windows Server，AIX</li><li>桌面OS：Windows10， WIndows7，MacOS，Fedora</li><li>移动设备：Android，IOS，YunOS</li></ol></li><li><p>开发接口标准</p><ol><li>ABI：Application Binary Interface，是应用软件与操作系统之间的接口。</li><li>API：Application Programming Interface，是应用程序开发的时候调用库的接口。</li><li>POSIX：Portable Operating System Interface</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2020/04/09/di-yi-pian-bo-ke/"/>
      <url>/2020/04/09/di-yi-pian-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>我的名字是张博闻，这是我在<code>Github</code>上写下的第一篇博客，我在<code>Github</code>上部署了一个<code>hexo</code>框架的博客网站。由于初次上手，这个网站的部署花了我比较久的时间，为了使得再次建立网站变得更加方便，我想利用这一篇博文记录一下使用hexo的方法。</p><hr><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>Ubuntu操作系统</li><li>Node.js</li><li>Git</li><li>Hexo</li><li></li></ul><h2 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1. 安装Git"></a>1. 安装Git</h2><p>  使用如下命令安装Git。<br><code>sudo apt-get install git</code></p><h2 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2. 安装Node.js"></a>2. 安装Node.js</h2><p>安装<code>Node.js</code>需要使用<code>nvm</code>(Node Version Manager)。</p><ul><li>安装<code>nodejs</code><br><code>curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -</code><br><code>sudo apt-get install -y nodejs</code></li></ul><h2 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3. 安装Hexo"></a>3. 安装<code>Hexo</code></h2><ul><li>使用如下命令安装Hexo。<br><code>npm install -g hexo-cli</code></li></ul><h3 id="至此我们所有的准备工作就都完成了，接下来便可以进入建站的环节。"><a href="#至此我们所有的准备工作就都完成了，接下来便可以进入建站的环节。" class="headerlink" title="- 至此我们所有的准备工作就都完成了，接下来便可以进入建站的环节。"></a>- 至此我们所有的准备工作就都完成了，接下来便可以进入建站的环节。</h3><hr><h2 id="建立站点"><a href="#建立站点" class="headerlink" title="建立站点"></a>建立站点</h2><h3 id="1-使用hexo-init命令初始化你想使用作为服务器的目录。"><a href="#1-使用hexo-init命令初始化你想使用作为服务器的目录。" class="headerlink" title="1. 使用hexo init命令初始化你想使用作为服务器的目录。"></a>1. 使用<code>hexo init</code>命令初始化你想使用作为服务器的目录。</h3><h3 id="2-使用hexo-g命令生成一个静态网页。"><a href="#2-使用hexo-g命令生成一个静态网页。" class="headerlink" title="2. 使用hexo g命令生成一个静态网页。"></a>2. 使用<code>hexo g</code>命令生成一个静态网页。</h3><h3 id="3-使用hexo-s命令启动服务器，使用-http-localhost-4000-观察网站的运行情况和具体内容。"><a href="#3-使用hexo-s命令启动服务器，使用-http-localhost-4000-观察网站的运行情况和具体内容。" class="headerlink" title="3. 使用hexo s命令启动服务器，使用 http://localhost:4000/观察网站的运行情况和具体内容。"></a>3. 使用<code>hexo s</code>命令启动服务器，使用<code> http://localhost:4000/</code>观察网站的运行情况和具体内容。</h3><h3 id="4-配置生成ssh。"><a href="#4-配置生成ssh。" class="headerlink" title="4. 配置生成ssh。"></a>4. 配置生成<code>ssh</code>。</h3><ul><li>执行如下指令生成一个<code>ssh key</code>。<br><code>ssh-keygen</code></li><li>三次回车之后会产生一个<code>id_rsa.pub</code>文件，文件的内容就是<code>ssh key</code>，使用<code>gedit</code>打开文件，把文件内所有内容复制到剪贴板。</li><li>打开<code>Github</code>，点击右上角头像，选择设置，再选择SSH秘钥选项，再选择添加SSH秘钥，把复制到剪贴板的内容黏贴到文本框中，秘钥名字可以任意选择。  </li><li>添加好之后使用如下命令检查<code>ssh key</code>是否设置成功<br><code>ssh -T git@github.com</code><br>如果出现选择Yes/No时，选择Yes。若出现如下提示即为设置成功。<br><code>Hi dreamgeng! You've successfully authenticated, but GitHub does not provide shell access.</code><br>如果设置不成功，可以使用如下命令，手动设置秘钥位置。<br><code>ssh-add path/to/key</code></li></ul><h3 id="5-设置Github个人信息。"><a href="#5-设置Github个人信息。" class="headerlink" title="5. 设置Github个人信息。"></a>5. 设置Github个人信息。</h3><ul><li>设置邮箱和个人用户名，这是用来记录每一次commit的用户信息的，如果初次使用<code>Github</code>需要设置。</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"github用户名"</span><span class="token function">git</span> config --global user.email <span class="token string">"你注册的邮箱地址"</span></code></pre><ul><li>生成秘钥。<br><code>ssh-keygen -t rsa -C "你注册的邮箱地址"</code></li></ul><h3 id="6-配置部署信息。"><a href="#6-配置部署信息。" class="headerlink" title="6. 配置部署信息。"></a>6. 配置部署信息。</h3><ul><li>在_config.yml文件中，找到Deployment，然后按照如下修改。注意，在冒号后面需要添加空格。</li></ul><pre class=" language-bash"><code class="language-bash">deploy:  type: <span class="token function">git</span>  repo: git@github.com:zbw0520/zbw0520.github.io.git  branch: master</code></pre><p>注意，<code>zbw0520/zbw0520.github.io</code>可以更改为自己网站仓库的名字，并且记得加上<code>.git</code>。</p><ul><li>执行如下最后的部署编译命令。</li></ul><pre class=" language-bash"><code class="language-bash">hexo cleanhexo ghexo d</code></pre><h3 id="7-大功告成。"><a href="#7-大功告成。" class="headerlink" title="7. 大功告成。"></a>7. 大功告成。</h3><ul><li>在浏览器输入你的仓库名称，如<code>zbw0520.github.io</code>，即可观察到网站设置成功。</li><li>注意，如果网站显示404的话，需要等待<code>Github</code>一些时间，大概10分钟左右，便可以观察到结果。如果十分钟后还是不能看到网页，可以输入<code>zbw0520.github.io/index.html</code>查看网页。</li></ul><h3 id="8-撰写博客。"><a href="#8-撰写博客。" class="headerlink" title="8. 撰写博客。"></a>8. 撰写博客。</h3><ul><li>使用如下命令便可以撰写一篇博文了。</li></ul><pre class=" language-bash"><code class="language-bash">hexo new post <span class="token punctuation">[</span>title<span class="token punctuation">]</span>   //替换<span class="token punctuation">[</span>title<span class="token punctuation">]</span>为你个人博文的名称。hexo cleanhexo ghexo d</code></pre>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
            <tag> 业余生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
