<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java中单例设计模式的总结</title>
      <link href="2020/10/14/java-she-ji-mo-shi/"/>
      <url>2020/10/14/java-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul><li>一种设计经验</li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul><li><p>优点</p><ol><li>在内存中只有一个对象，节省内存空间；</li><li>避免频繁的创建销毁对象，提高性能</li><li>避免对共享资源多重占用</li></ol></li><li><p>缺点</p><ol><li>扩展比较困难；</li><li>如果实例化后的对象长期不利用，系统将默认为垃圾进行回收，造成对象状态丢失。</li></ol></li><li><p>适用的设计场景</p><ol><li>创建对象时占用的资源过多，但同时又需要用到该类对象；</li><li>对系统内资源要求统一读写，如读写配置信息；</li><li>当多个实例存在可能引起程序逻辑错误，如号码生成器。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 知识总结 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中继承特点的总结</title>
      <link href="2020/10/13/java-ji-cheng/"/>
      <url>2020/10/13/java-ji-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h2><ul><li>将父类（基类）的属性和方法给予子类（派生类）；</li><li>一种类与类的关系；</li><li>使用已存在的类的定义作为基础建立新的类；</li><li>新类的定义可以增加新的数据或者新的功能，也可以用父类的功能，但不能选择性地继承父类；</li><li>两个类满足”A is a b”的关系是就可以使用继承。</li></ul><h2 id="继承的实现"><a href="#继承的实现" class="headerlink" title="继承的实现"></a>继承的实现</h2><ul><li>利用<code>extends</code>实现继承；</li><li>只能支持单一继承，只有一个父类。</li></ul><pre class=" language-Java"><code class="language-Java">//子类Class Cat extends Animal&#123;&#125;//父类Class Animal&#123;&#125;</code></pre><ul><li>此时父类的所有属性和方法都会在子类中存在</li></ul><h2 id="方法重写和方法重载"><a href="#方法重写和方法重载" class="headerlink" title="方法重写和方法重载"></a>方法重写和方法重载</h2><ul><li><p>方法重写  </p><ol><li>有继承关系的子类中</li><li>方法名相同，参数列表相同，方法返回值相同</li><li>访问修饰符限定范围大于等于父类方法</li><li>方法参数名无关</li></ol></li><li><p>方法重写  </p><ol><li>在同一个类中</li><li>方法名相同，参数列表不同</li><li>方法返回值、访问修饰符任意</li><li>与方法的参数名无关</li></ol></li></ul><h2 id="super关键字的使用"><a href="#super关键字的使用" class="headerlink" title="super关键字的使用"></a><code>super</code>关键字的使用</h2><ul><li><code>super</code>关键字主要是用来调用多参父类构造方法的。在默认情况下，实例化子类的过程中，虚拟机默认调用的是父类的无参构造方法，如果用户与要调用父类的多参构造需要使用<code>super</code>关键字。</li><li>代表父类引用。</li><li>子类对象的构造过程中必须调用其父类的构造方法。</li><li>如果子类的构造方法中没有显示标注，则系统默认调用父类的无参构造方法。</li><li>如果子类构造方法没有显示标注，且父类没有无参构造方法，系统将提示错误。</li><li>使用<code>super</code>调用父类指定构造方法，必须要在子类的构造方法的第一行。</li></ul><pre class=" language-Java"><code class="language-Java">public void Cat()&#123;    super("xxx",18);    System.out.println("这是子类的无参构造方法");&#125;super.print();   //访问父类成员方法super.name;     //访问父类属性super();        //访问父类构造方法</code></pre><ul><li><strong>注意</strong><code>super</code>关键字只能在子类构造方法中使用，且必须位于构造方法的第一行。</li></ul><h2 id="子类实例化时的程序执行顺序问题"><a href="#子类实例化时的程序执行顺序问题" class="headerlink" title="子类实例化时的程序执行顺序问题"></a>子类实例化时的程序执行顺序问题</h2><ul><li>总结一下来说是，父类与静态代码块先行，子类、构造代码块以及构造方法紧随其后；</li><li>父类静态成员<code>-&gt;</code>子类静态成员<code>-&gt;</code>父类对象构造<code>-&gt;</code>子类对象构造。</li></ul><pre class=" language-Java"><code class="language-Java">/***我是父类的静态代码块*我是子类的静态代码块*我是父类的构造代码块*我是父类的多参构造方法*我是子类的构造代码块*我是子类的无参构造方法**/</code></pre><h2 id="this关键字与super关键字的对比"><a href="#this关键字与super关键字的对比" class="headerlink" title="this关键字与super关键字的对比"></a><code>this</code>关键字与<code>super</code>关键字的对比</h2><ul><li><code>this</code>关键字用来调用当前类允许被访问的属性和方法；</li><li><code>super</code>关键字用来调用父类当中允许被访问的属性和方法。</li><li><code>this</code>和<code>super</code>关键字都不能在静态方法中被使用。</li><li><code>this</code>和<code>super</code>不能同时出现在同一个构造方法中，一个关键字只能出现在一个构造方法中。</li></ul><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><table><thead><tr><th>访问修饰符</th><th>本类</th><th>同包</th><th>子类</th><th>其他</th></tr></thead><tbody><tr><td>private</td><td>$\checkmark$</td><td></td><td></td><td></td></tr><tr><td>默认</td><td>$\checkmark$</td><td>$\checkmark$</td><td></td><td></td></tr><tr><td>protected</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\checkmark$</td><td></td></tr><tr><td>public</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\checkmark$</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 知识总结 </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Approximate Computing. A Survey</title>
      <link href="2020/10/12/lun-wen-fan-yi/"/>
      <url>2020/10/12/lun-wen-fan-yi/</url>
      
        <content type="html"><![CDATA[<ul><li><p>尽管半导体科技以及能效设计技术在不断发展，但是计算机系统为了处理不断增加的信息，整体的能耗仍然在以令人担忧的速度不断增长。尤其是，随着计算机系统普及开来，计算机系统就用来与物质世界做交互同时用来处理从不同地方获取到的大量信息。此外，我们还希望它们能够识别不同的语境并且提供一种自然的人类接口。因此，出现了大量的应用，主要包括识别应用、挖掘应用以及综合应用，这些应用构成了从移动端和物联网设备到数据中心之间计算资源的一个重要组成部分。<br>为了能够跟上需要处理的信息发展速度，极大地改善这些新兴出现的设备的能耗效率是很有必要的。幸运的是，这些应用一般来说有一个内在的错误恢复的性质。它们处理一些冗余并且有噪声的数据，这些数据来自于一些非传统的输入，例如，不同的种类的传感器（非精准输入），并且一些相关的算法在本质上通常是随机的（例如，迭代算法）。此外，这些应用通常不需要计算出一些独一无二的或者非常精准的结果（结果一般来说要求是可以接受的而不是精准的）。例如，在多媒体处理中，由于人类有限的感知能力，一些偶然的错误，例如，丢失某一个帧的数据或者说一个小的图像质量损失都很少影响到用户的体验。以数据分析中的一个情况作为另一个例子，考虑有两个不同的分类器，这两个分类器对同一个数据集会产生类似的分类结果。鉴别哪一种分类器用于分类新事物的效果更好是非常困难的。<br>另一方面，随着半导体科技进一步进入了纳米的时代，为了保证没有错误的运算是需要消耗非常多的功率的。这是因为在低电压和不断增长的集成密度的情况下，电路对先进技术节点的参数变化和故障更为敏感。传统的无差错计算为了可接受的误差和错误校正，需要在不同层的设计层次结构中加入防护带宽以及一定的冗余量，这一点导致了巨大的能源开销。<br>受到上述的挑战的激励，一个有前途的解决方案吸引了来自工业界和学术界的目光。通过放宽错误容忍应用的指标和实际之间的等效范围，近似计算故意把可接受的误差引入计算过程并且保证了巨大的能效降低的收益。考虑到传统的Dannards缩放定理（随着MOSFET面积不断变小，由于单位面积的功耗是固定的，因此功耗与MOSFET成比例）说明集成电路生产技术进步带来的功耗收益越来越少，利用近似计算来实现功耗的降低已经越来越重要。<br>近几年来，在不同计算层次中的不同的近似计算技术已经在各种论文中被称述了。此篇文章的目的有两个。第一，我们提出一些现有的近似计算工作的观点并且通过一篇对文献综述巩固现有的一些结果和见解。请注意，我们并不会对文献进行一个完整的综述，而是对技术发展水平的一些关键方面进行阐述。第二，我们很重视开放的挑战并且讨论了一些未来的研究方向。通过与最近的一些综述作对比，我们的分类和组织结构是完全不同的并且我们的视角由于遍布整个计算层次所以也更宽。<br>此文剩下的内容是按照如下进行展开的。近似计算范例部分主要概括了近似计算的范例。在近似软件、近似结构以及近似电路板块，我们调查并且巩固了一些技术，这些技术主要与如下内容相关，近似软件开发，近似结构探索以及近似电路设计，我们对每一个方向的技术都有所覆盖。最后，我们在挑战和未来研究方向板块，提出了一些挑战并且指明了未来在近似计算方向中的研究方向。</p></li><li><p>近似计算范例 </p></li></ul><p>计算已经进入了一个近似的时代，在这个时代中硬件和软件生成和推理估计。导航应用通过GPS传感器的硬件，估计出地图和位置，把这些信息转换为驾驶的方向信息；语音识别把模拟的信号转换为一个最为可能的语句；搜索引擎软件把搜索请求转换为信息。这些复杂的系统需要及其精巧的算法才能够大规模地、尽快地、低功耗地给出足够好的结果，在这一过程中，往往近似计算是唯一一个能够达到上述目标的方式。在这一个板块中，我们简短地来看一下近似计算的范例。<br>对于已经给定的可以容忍一定错误的应用，应用近似计算的一个整体的框架在图1中显示出来。框架中的关键组成部分如下所述。<br><strong>近似内核</strong>。近似内核指的是那些用来实现近似计算以达到减少功耗目的的技术。通常来讲，有两种不同种类的近似计算内核。在硬件层面，我们要么可以用一些不那么精准的但在功效方面表现更好地电路来实现计算或者有意图地减少一些硬件部分的电源电压来在功耗和精准度之间做平衡。在软件层面，我们可以选择性地忽略一些特定的计算或者或者存储器的访问，这些计算或者存储器访问对最终的用来实现相同目标的应用质量没有关键的影响。<br>从软件层面到电路层面的一些代表性的近似计算内核描述在表1中。  </p><p><strong>弹性识别和特征</strong>  即使是一些能够容忍错误的应用，对错误敏感的部分使用一些非精准的计算会引起一些致命性的错误。因此，部署近似计算关键的一步就是去识别哪些弹性错误部件可以被用来使用近似计算。<br>弹性识别对的一种方法是标记应用或者使用精心设计的近似数据类型来表示哪些位置可以用来实现近似计算以及它们会如何影响结果。另外，我们可以把应用分成好几个部之后，来实现每一个部分的敏感度分析。有一部分部件可以被很容易地分类为敏感的或弹性的。对于那些剩下的部分，我们可以通过注入错误和仿真的方法来评估近似计算对他们的影响。如果某些部件在注入错误时，应用崩溃了或者说产生了一些不可接受的结果，那么这个部分就可以被标注为错误敏感的；反之，它就是弹性的。然而，如果仿真不够充分，这种方法也有可能是有风险的因为仿真有可能没能够捕捉到一些情况，在这些情况中，崩溃的数据所产生的的效果没有被立刻显示出来。<br>在弹性识别之后，我们需要描述不同近似方法对于不同弹性部件所产生的影响，那么这通常是通过使用一些仿真技术或者说让部件执行一些代表性的工作。注意，由于实际生产环境中在系统上执行的工作有可能会和仿真的有所不同，为了保证最终的应用质量，去做一些动态质量管理的工作往往是很有必要的。<br><strong>质量管理</strong>  在动态质量管理中，我们评估中间每一步的计算质量（最好是通过应用定制的轻量型检查器）并且决定在运行时的什么时候要使用近似计算方法以及对应的近似模式。<br>SAGE和GREEN在每N次对近似计算内核调用之后立刻检查输出的质量，在这之中，他们对比了近似计算和精准计算之间的质量并且相应地调整了接下来计算需要使用的的近似模式。很显然，通过这样一种质量采样的策略，质量检查得越频繁，最终应用质量的可靠性就越高，但是能耗也随之升高。另一方面，利用这种模式对每一次内核调用都进行监视也是不现实的，因为这种方式违背了近似计算的初衷。<br>上述的质量采样定理有一个重要的问题那就是我们绝无可能保证那些没有被检测到的输出质量的好坏。因此，连续的质量检测是更好的一种方法。毫无疑问，只能使用小开销的检测器，只有这样才不至于使从近似计算中获得的好处消失。受到大型认知性预测工作的启发（例如分支预测和值预测），一些在近似计算中使用的质量预测期被很多文献提出。在[21]中，Ringenburg和他的同事们介绍了一种所谓的模糊记忆的技术，这种技术记录了被检测代码先前的输入和输出并且也通过先前类似输入的记录来预测当前执行的输出内容。近似的质量是通过检测预测结果和实际结果之间的差距，从而被估计出来。Rumba通过观察近似加速器对的输出和输入，从而构建了多种简单的错误预测模型。如果一个很大的近似错误被检测到的话，那么需要进行精准计算来实现对错误的校正。<br>在接下来的板块中，我们将会详细讨论不同计算层次中使用的近似计算方法。  </p><ul><li>近似软件</li></ul><p>一个好的编程语言需要让编程人员变得更加高效。这种编程语言能够让编程人员迅速地表达他们的想法同时也要让编译器和运行时系统能够优化程序的执行过程。编程语言和他们的实施平衡着编程者的效率和系统的有效性。<br>编程语言是通过“抽象”这一方法来实现对两者的平衡的。抽象能够让程序员表达完成一个任务该做什么而不是该怎么做。这种怎么做——或者说是抽象的一种具象——是留给编译器和运行时系统去完成的。<br>简历精巧的应用是非常难得并且需要系统全栈的技术，在这个近似的时代下，这些技巧包括统计学（或者一些其他的意识到近似的推导）以及特定应用层面的知识。许多学者提出抽象这个概念来帮助程序员来完成这项烦人的工作也不足为奇了。这种抽象帮助程序员在程序（例如有近似意识的编程语言）中表达自己的想法，让分析引擎推导程序的正确性（例如有近似意识的分析），并且让编译器产生机器码（例如有近似意识的编译器）。<br>接下来的板块主要描述了最近学术界和工业界在有近似意识的编程语言、分析以及编译器这几个方向上取得的成果。</p><ul><li>有近似计算意识的编程语言</li></ul><p>有近似计算意识的编程语言让程序员能够表达在哪里和有多少随机性能够影响到他们的结果。在1979年，Kozen意识到符号和语义对于那些在执行过程中有随机性的程序是很有必要的。这项早期工作的目标是使用编程语言通过概率结构来确定程序的含义。这项工作给一个简单的概率语言提供了两种语义——一个是给采样建立模型，还有一个是直接计算概率分布——然后还证明了它们是等效的。这个结果表明了接下来的工作可以直接用采样来近似计算概率分布。<br><strong>程序中随机性的表达</strong>  大量的后继研究工作中的语言让程序员能够表达多大的随机性会影响到他们的程序。例如，程序语言比方说Eon，EnerJ以及Rely把近似通过编程语言的符号提供给程序员。考察EnerJ和Rely这两种语言，它们让程序员能够用近似类型的信息来注释他们的程序。在EnerJ中程序员必须显式地把近似类型转换为精确类型，然而在Rely语言中，编译器尝试去从统计角度来推理一个近似的类型怎么转换为其他类型。<br>库函数，比方说Uncertain，提供了一种抽象，这种抽象把近似的数据封装在标准的面向对象编程语言中，并且通过运行时的程序变量来传递数据。当一个程序需要利用近似数据时，Uncertain运行时利用假设检验来作出统计意义上正确地分支决策。<br>有近似意识的编程语言的关键挑战是把这个推理过程尽可能自动化从而程序员不需要理解很多关于近似计算如何会影响他的程序的准确性的细节。<br><strong>通过概率编程进行推断</strong>  大量的工作尝试通过建立一个由Kozen提出的理论结构体的方式来解决这个问题。概率编程语言</p>]]></content>
      
      
      <categories>
          
          <category> 集成电路设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文翻译 </tag>
            
            <tag> 近似计算 </tag>
            
            <tag> 文献综述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中构造方法的总结</title>
      <link href="2020/09/30/java-zhong-gou-zao-fang-fa-de-zong-jie/"/>
      <url>2020/09/30/java-zhong-gou-zao-fang-fa-de-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="构造方法的特征"><a href="#构造方法的特征" class="headerlink" title="构造方法的特征"></a>构造方法的特征</h2><ul><li>构造方法必须与类的名字相同，可以带有和不带有参数，没有返回值;</li><li>构造方法必须有访问修饰符，没有返回值类型;</li><li>只能在对象实例化的时候调用;</li><li>当没有指定构造方法时，系统会自动添加无参的构造方法;</li><li>当有指定构造方法时，无论是有参数还是没有参数的构造方法，都不会自动添加五参数的构造方法;</li><li>一个类中可以有若干个构造方法;</li></ul><pre class=" language-Java"><code class="language-Java">public 构造方法名(可选参数1,可选参数2)&#123;    //初始化代码&#125;</code></pre><h2 id="构造方法使用的注意事项"><a href="#构造方法使用的注意事项" class="headerlink" title="构造方法使用的注意事项"></a>构造方法使用的注意事项</h2><ul><li>构造函数有<strong>两种</strong>办法给新实例化的对象的属性赋值。构造函数内如果要调用实例化的参数属性，需要使用<code>this.属性</code>的形式来调用新实例化的属性；<strong>或者</strong>也可以使用与对象属性名不同的参数名来实现对新实例化对象属性的赋值;</li></ul><pre class=" language-Java"><code class="language-Java">public class Cat&#123;    String name;    int month;    double weight;    String species;&#125;//使用与类的属性名不同的参数名称来实现对新实例化的对象属性的赋值public Cat(String newName, int newMonth, double newWeight, String newSpecies)&#123;    name = newName;    month = newMonth;    weight = newWeight;    species = newSpecies;&#125;</code></pre><h2 id="This关键字的使用"><a href="#This关键字的使用" class="headerlink" title="This关键字的使用"></a><code>This</code>关键字的使用</h2><ul><li><code>This</code>可以调用当且对象当中的属性以及方法，使用<code>This</code>关键字可以实现构造函数给当前属性赋初值，这种方案广泛用于构造函数的赋初值问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 构造函数 </tag>
            
            <tag> 知识总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保研之路以及保研之后的计划</title>
      <link href="2020/09/28/bao-yan-zhi-hou-de-sheng-huo/"/>
      <url>2020/09/28/bao-yan-zhi-hou-de-sheng-huo/</url>
      
        <content type="html"><![CDATA[<h2 id="保研之路的艰辛"><a href="#保研之路的艰辛" class="headerlink" title="保研之路的艰辛"></a>保研之路的艰辛</h2><ul><li>2019-2020学年是充满变化、痛苦与惊喜的一年，在这一年中，我成长了许多，理解了曾经或许不能够理解的人情世故。<br>2019年初，我在虹桥机场踏上了前往欧洲大英帝国的飞机，我记得那是卡塔尔航空公司的客机，当时为了省钱，买了便宜的卡塔尔航空公司的机票。虽然说机票买的是最便宜的，但仍然花费了我将近5000元，这一笔钱就让我心理压力倍增。在英国一年的学费是18955英镑，住宿费和生活费还要另算，大概加起来总共有10000英镑左右，这还是建立在我省吃俭用的基础之上的，可见英国留学一年的消费之高。我是一个把钱看得很重的人，如果能不花父母的钱，我就尽量不花，这是我的原则。但是这一年的英国之行，确实花销特别多，这也是我后期为什么选择中断学习回国的原因之一。<br>在大英帝国的一年过得也很辛苦，虽然中途圣诞节回来了几个星期，但是我仍然觉得心里很累，我不愿意承受这份出国留学的压力，我甚至晚上会做梦，梦见我回了南航，在南航南区吃着13.6一份的砂锅套餐，这简直就是神仙一般的生活。在英国的一年，我除了披萨、牛肉就是一些粗制滥造的食堂菜，让人很是烦躁。但这也没有办法，毕竟是自己选择的路，就算死也要走下去。<br>2020年伊始，新冠病毒在中国武汉华南海鲜市场爆发了，造成了中国将近10万人感染，2000多人死亡。病毒刚开始在中国扩散的时候，我在英国非常担心我父母的情况，有时候甚至会睡不着觉，担心新冠病毒会传播得飞速，最终导致中国大部分城市的沦陷。后来的情况证明了我的考虑是多余的，反倒是国外欧洲这边，开始疯了似的传播。我仍然记得北欧的环保小女孩桑伯格的到来是我们这座城病毒发展的转折点，自从那天之后，布里斯托就开始不断增长了，后来导致了停课。<br>在刚开始停课的时候，我不以为然，我觉得新冠病毒既然在中国传播得不厉害，那意味着在英国也不会怎么传播的，最后可能还会被控制住。我的同伴杜蔚峰劝我早点离开英国，回到中国去。可是，一想到我在英国只呆了3个多月就要回去了就有点不甘心，我想最后赌一把，看看新冠能不能好，如果可以好的话，我就留在英国不回去了。后来的情况证明我错了，我滞留在了英国，后来差点没回来，那时候机票特别难买，我是找了学校的老师认识的票贩子购买的回程机票，那张机票大概花了50000块，又是一大笔支出。不过好在后来学校退回了学费，也能补偿一点损失。我之所以后来会回来，是因为南航管理出国交换的张静老师跟我沟通了中断交流的事宜，我当时感觉如释重负，这非人的国外留学生活我是一分钟都不想再过了，这段时间我是被心理压力和生理压力共同影响，导致我头发掉了不少。好在最后还是回来了，当时我想着要是不能进行学分替代，不能参与保研我也要回来，因为国外的生活的压力我没办法承受。我记得当时我爸妈在和我讨论国外工作帮我买房的事情，我很不想在国外工作，又不想让父母知道真实的情况，于是，不知道怎么回事，我就非常烦躁，我感受到我爸妈也察觉了我的异常，于是没有再和我讨论这个事情。<br>在英国从三月份开始我就停课了，我当时想着得找点事情做，当时已经联系好了中断留学交流的事宜，于是，我不再把工作的重心放在学校的课程上面。当时，我做了个计划，想着回国就是两条路，一是保研，二是考研。我没有考虑工作，因为我爸妈非常坚定地要让我读研究生，我也有读研的意愿，所以工作就不在考虑的范围之内。当时我综合考虑了一下我的情况，保研可能有点困难，原因有两点，一是因为我出国可能不能进行学分替换，如果学分替换不能正常进行，那么保研也就无从谈起；二是因为我绩点有可能不够，后来发现这两点原因都是多虑了。但当时想着不能保研的话我就得考研，这是板上钉钉的事情，没有任何商量的余地，所以我从网上找了考研的复习材料，从三月份就开始准备，我显示准备了数学，当时还没有开始准备政治英语以及专业课，因为我自认为政治到10月份准备也行；英语的话我水平比较高应该问题不大；专业课的话我还没想好目标院校，最好还是先学习数学比较合适。于是我就开始了视频和书结合的复习方法，这段时间的复习的确巩固了一下我的数学基础，虽然之后不会参加考试了，但对我的帮助还是很大，尤其是高等数学和线性代数部分。<br>时间来到了五月份，我回国了，我在虹口区的君亭酒店隔离，隔离这段时间，我作息没有调整过来，过着没黑没夜的生活，基本上是醒着的时候就是在学习，睡着的时候就是在做梦，整个人压力很大，心理状态也不是很好。那段时间是我数学和运维技术突飞猛进的一段时间，两个星期的隔离时间里，我学习了太多知识了。说到运维技术，运维技术这个坑是我在英国的时候挖的，当时在阿里云上买了个服务器，想搭建一个个人博客网站，于是我就在阿里云大学上面学习马哥的运维技术，当时觉得讲得很不错，可能是因为一个人在英国隔离觉得非常寂寞的原因，我觉得视频里的老师讲中国话特别亲切，于是我每天基本上看8~10个小时的运维视频，那段时间，我的运维水平和计算机知识也突飞猛进，后来回国我利用我实习得到的工资购买了以整套运维课程，对我之后的对计算机的理解和网络技术的理解起到了非常重要的作用。<br>回到家的那一天我还记得，是5月22日，是我生日之后的两天，我在隔离酒店里面过了自己的生日，那是我第一次自己一个人过生日，我们家是一个非常和谐的家庭，如果谁过生日的话是一定会买蛋糕庆祝的。之后我在家里面依旧复习着，想着考研之后的各种计划。同时，我还要应付英国的各种乱起八糟的事情，比如课程考试，课程作业提交、学分证明的申请、退学手续的办理以及英国宿舍退宿退钱的办理。那段时间很多事情我都是装在肚子里，没有和任何人说过。这一点很奇怪，我是一个不愿意和他人交流的难处的人，好像就不想让别人知道我现在遇到了困难一样，可能是因为自己是一个比较好胜的人。那段时间我心理压力大到梦里做梦都是非常痛苦悲伤的梦，第二天醒来发现眼角还残留着泪水，枕头湿了一大片，这是我从来没有过得情况。那段时间在家里面，父母的各种要求，我也是尽量满足，虽然我能感受到他们对我回来这件事感到十分高兴，但我仍让克服不了自己心里面的压力。好在这个暑假一晃就过去了，马上就来到了九月…<br>九月是收获的季节，说实话我的确是心里还抱着能够保研的一丝希望的，我硬着头皮问了好几个老师关于这方面问题，得到的基本都是不确定的回答，搞的我迷迷糊糊的，也不知道是不是可以保研。但心里想着已经做了考研的准备，所以也不是很慌张。但是后面想到如果可以保研的话，我的求学之路就可以轻松很多，我就在争取保研这件事上做了很多工作，一开始我跑了教务处，问了这方面的问题，教务处说没有什么问题，只要正常交流的回来保研都是可以进行的，后来导员也是这么回复的。直到有一天，学院里面组织了推免生的情况说明会，我发现里面的邀请名单里面没有我，我就很慌，过去问了导员这方面的情况。后来才了解到我们学院的保研政策是成绩加权，这就意味着如果大三没有成绩的话，就不可能参与保研了。听到这个消息我故作镇定，我还记得这句话就像是一个棒子敲在我头上，让我的耳朵嗡嗡作响，我当时非常沮丧，回到了教室里面，立刻想好了我要考交大。这有几方面的原因，一是交大本身实力很强；二是我想要回到上海上学；三是学校的做法实在是让我觉得恶心，不想再在学校里面呆下去了。我那段时间早上七点就起来学习了，一直干到晚上十一点才回去，干了两天我就有点坚持不住了。交大考研的专业课包含了信号与系统和数字信号处理，信号与系统还好，我有本科基础，但是数字信号处理我没有基础，相当于要从头学起，这对我来说是极大地挑战，我甚至不知道自己是不是可以坚持过这段时间。我自认为是没办法一战考上的，我还做了二战的打算，这件事我还征求了我女朋友的意见，她说没有问题，我说那好，那我就准备二战。<br>后来，过了两天，我实在是有点坚持不下去，我就又动了保研的主意，我显示调查了我们学院负责保研的老师都有谁，发现了刘伟强老师，他是一位非常负责的老师，虽然可能行政工作做的比较多，但是他人很好，我联系了他之后他立刻就帮我了这个忙，通过各种操作，让我保研之路又死灰复燃。可以说他是我人生路上遇到的“贵人”，如果没有他，我也不会在保研之后坐在电脑前面写这篇文章了。之后的事情就变得顺利了起来，我为了能够多一点选择，我还参加了西安电子科技大学的预推免面试，最后也是顺利地通过了预推免，获得了接收函。<br>保研的艰辛之路到这里就结束了。我最后拿到了学校的推免资格，学校也把名单公示在了学院网上，整个保研的过程让人觉得充满了坎坷与痛苦，确实让我成长了许多。  </li></ul><h2 id="保研之后的计划"><a href="#保研之后的计划" class="headerlink" title="保研之后的计划"></a>保研之后的计划</h2><ul><li>我保研之后，按照先前在国外的想法，主要是要学习面向对象的编程、学习算法知识以及学习运维知识，并且按照网上开发工程师的招聘要求进行学习。具体来讲，做到一天学习至少6个小时，其中要学习两个小时的运维，两个小时的算法以及两个小时的编程语言知识。此外，我还要更新我的博客，尽量做到一周三更，分享我个人的生活体验以及学业知识。并且我还希望可以利用这段时间提升一下英语水平，背一下GRE的单词。这段时间来之不易，希望我还可以好好利用起来，充实自己，为下一个阶段的到来做好充足的准备。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数组知识总结</title>
      <link href="2020/09/28/java-xue-xi-bi-ji/"/>
      <url>2020/09/28/java-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="Java数组简介"><a href="#Java数组简介" class="headerlink" title="Java数组简介"></a>Java数组简介</h2><ul><li>数组是一系列<strong>同类型</strong>元素的<strong>有序</strong>集合。</li><li>数组只能存储<strong>固定数量</strong>的元素，即，数组的长度在数组最初创建的时候就确定了，之后不能变动。</li></ul><h2 id="Java数组的特点"><a href="#Java数组的特点" class="headerlink" title="Java数组的特点"></a>Java数组的特点</h2><ul><li>数组是**引用类型</li><li>**的。</li><li>所有的元素都<strong>按照顺序</strong>存储在一块<strong>连续的</strong>内存中。</li><li>数组的每一个元素都要通过他的数字底标访问其元素。</li><li>数组中的元素可以是任意类型的变量。</li><li>数组的最大大小被<code>Integer.MAX_VALUE</code>定义;</li></ul><h2 id="Java数组使用的步骤（三部曲）"><a href="#Java数组使用的步骤（三部曲）" class="headerlink" title="Java数组使用的步骤（三部曲）"></a>Java数组使用的步骤（三部曲）</h2><ol><li>将一个变量<strong>声明</strong>为数组类型（declaration）;</li><li>创建一个数组对象的<strong>实例</strong>（instantiation）;</li><li>用某些值<strong>初始化</strong>数组（initialization）;</li></ol><pre><code>int[] array;    //declarationint array[];    //declarationarray = new int[10] //instantiationint[] numbers = &#123;1, 2, 3, 4&#125;    //instantiation &amp; initializationint[] numbers = new int [10];   //declaration &amp; instantitionfloat[] floatNumbers;   //declaration floatNumbers = new float[] &#123; 1.02f, 0.03f, 4f &#125;  //instantiation and initialization</code></pre><h2 id="Java数组提供的几个实用工具-Utility"><a href="#Java数组提供的几个实用工具-Utility" class="headerlink" title="Java数组提供的几个实用工具(Utility)"></a>Java数组提供的几个实用工具(Utility)</h2><pre><code>Array.length    //return the length of the arrayArray.toString  //return the string of the arrayArray.equals    //compare two different arrays</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 计算机理论 </tag>
            
            <tag> 知识梳理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研线性代数知识点提纲（行列式）</title>
      <link href="2020/07/01/kao-yan-xian-xing-dai-shu-zhi-shi-dian-ti-gang-xing-lie-shi/"/>
      <url>2020/07/01/kao-yan-xian-xing-dai-shu-zhi-shi-dian-ti-gang-xing-lie-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="行列式的性质"><a href="#行列式的性质" class="headerlink" title="行列式的性质"></a>行列式的性质</h3><ol><li>经过转置后行列式的值不变。</li><li>两行或两列互换位置，行列式的值变号。</li><li>某行或某列如有公因子$k$，则可以把$k$提出行列式的记号外。</li><li>如果行列式某行或者某列是两个元素之和，则可以把行列式拆分成两个行列式之和。</li><li>把某行或某列的k倍加到另一行，行列式的值不变。</li></ol><h3 id="行列式的算法"><a href="#行列式的算法" class="headerlink" title="行列式的算法"></a>行列式的算法</h3><ol><li>行列式的余子式和代数余子式的区别是代数余子式有正负，余子式没有正负，都是正的。</li></ol><h3 id="行列式的展开的巧妙算法"><a href="#行列式的展开的巧妙算法" class="headerlink" title="行列式的展开的巧妙算法"></a>行列式的展开的巧妙算法</h3><ol><li>上下三角形行列式的值等于主对角线元素的乘积。</li><li>范德蒙行列式</li><li>爪型行列式</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 电磁场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电磁场知识梳理1（在球坐标和柱坐标下散度旋度公式）</title>
      <link href="2020/06/23/dian-ci-chang-zhi-shi-shu-li-1/"/>
      <url>2020/06/23/dian-ci-chang-zhi-shi-shu-li-1/</url>
      
        <content type="html"><![CDATA[<h2 id="在球坐标和柱坐标下散度旋度公式"><a href="#在球坐标和柱坐标下散度旋度公式" class="headerlink" title="在球坐标和柱坐标下散度旋度公式"></a>在球坐标和柱坐标下散度旋度公式</h2><h3 id="柱坐标下的散度公式"><a href="#柱坐标下的散度公式" class="headerlink" title="柱坐标下的散度公式"></a>柱坐标下的散度公式</h3><p>$$<br>\nabla\cdot\overrightarrow{F}=\frac{\partial(\rho F_\rho)}{\rho\partial\rho}+\frac{\partial F_\phi}{\rho\partial\phi}+\frac{\partial F_z}{\partial z}=\frac{1}{\rho}[\frac{\partial}{\partial\rho},\frac{\partial}{\partial\phi},\frac{\partial}{\partial z}]<br>\begin{bmatrix}<br>    \rho F_\rho\\<br>    F_\phi\\<br>    \rho F_z<br>\end{bmatrix}<br>$$</p><h3 id="柱坐标下的旋度公式"><a href="#柱坐标下的旋度公式" class="headerlink" title="柱坐标下的旋度公式"></a>柱坐标下的旋度公式</h3><p>$$<br>\nabla\times\overrightarrow{F}=\frac{1}{\rho}<br>\begin{bmatrix}<br>    \overrightarrow{e_\rho}&amp;\overrightarrow{\rho e_\phi}&amp;\overrightarrow{e_z}\\<br>    \frac{\partial}{\partial \rho}&amp;\frac{\partial}{\partial\phi}&amp;\frac{\partial}{\partial z}\\<br>    F_\rho&amp;\rho F_\phi&amp;F_z<br>\end{bmatrix}<br>$$</p><h3 id="球坐标系下的散度方程"><a href="#球坐标系下的散度方程" class="headerlink" title="球坐标系下的散度方程"></a>球坐标系下的散度方程</h3><p>$$<br>\nabla\cdot\overrightarrow{F}=\frac{\partial(r^2F_r)}{r^2\partial r}+\frac{\partial(sin\theta F_\theta)}{rsin\theta\partial\theta}+\frac{\partial F_\phi}{rsin\theta\partial\phi}=\frac{1}{r^2sin\theta}[\frac{\partial}{\partial r},\frac{\partial}{\partial\theta},\frac{\partial}{\partial\phi}]<br>\begin{bmatrix}<br>    r^2sin\theta F_r\\<br>    rsin\theta F_\theta\\<br>    rF_\phi<br>\end{bmatrix}<br>$$</p><h3 id="球坐标系下的旋度方程"><a href="#球坐标系下的旋度方程" class="headerlink" title="球坐标系下的旋度方程"></a>球坐标系下的旋度方程</h3><p>$$<br>\nabla\times\overrightarrow{F}=\frac{1}{r^2sin\theta}<br>\begin{bmatrix}<br>    \overrightarrow{e_r}&amp;\rho \overrightarrow{e_\theta}&amp;rsin\theta \overrightarrow{e_\phi}\\<br>    \frac{\partial}{\partial r}&amp;\frac{\partial}{\partial\theta}&amp;\frac{\partial}{\partial\phi}\\<br>    F_r&amp;rF_\theta&amp;rsin\theta F_\phi<br>\end{bmatrix}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 数理知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电磁场 </tag>
            
            <tag> 计算公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研数学知识点总结7（特征值、特征向量）</title>
      <link href="2020/06/22/kao-yan-shu-xue-zhi-shi-dian-zong-jie-7/"/>
      <url>2020/06/22/kao-yan-shu-xue-zhi-shi-dian-zong-jie-7/</url>
      
        <content type="html"><![CDATA[<h2 id="特征值、特征向量"><a href="#特征值、特征向量" class="headerlink" title="特征值、特征向量"></a>特征值、特征向量</h2><p>$A$是一个n阶方阵，如果对于数$\lambda$，存在非零向量$\alpha$，使得</p><p>$$<br>A\alpha=\lambda\alpha(a\neq0)<br>$$</p><p>成立，则称$\lambda$是$A$的<strong>特征值</strong>，$\alpha$是$A$对应于$\lambda$的<strong>特征向量</strong>。</p><h3 id="特征方程、特征多项式、特征矩阵"><a href="#特征方程、特征多项式、特征矩阵" class="headerlink" title="特征方程、特征多项式、特征矩阵"></a>特征方程、特征多项式、特征矩阵</h3><p>由上式可得，$(\lambda E-A)\alpha=0$，因$\alpha\neq0$，所以</p><p>$$<br>\begin{vmatrix}<br>\lambda E-A<br>\end{vmatrix}=<br>\begin{vmatrix}<br>    \lambda-a_{11}&amp;-a_{12}&amp;\dotsb&amp;-a_{1n}\\<br>    -a_{21}&amp;\lambda-a_{22}&amp;\dotsb&amp;-a_{2n}\\<br>    \vdots&amp;\vdots&amp;&amp;\vdots\\<br>    -a_{n1}&amp;-a_{n2}&amp;\dotsb&amp;\lambda-a_{nn}<br>\end{vmatrix}<br>$$</p><h3 id="特征值的性质"><a href="#特征值的性质" class="headerlink" title="特征值的性质"></a><strong>特征值的性质</strong></h3><p>设$A=[a_{ij}]_{m\times n}$，$\lambda_i(i=1,2,\dotsc,n)$是$A$的特征值，则</p><p>$$<br>(1)\sum_{i = 1}^{n}\lambda_i = \sum_{1 = 1}^{\infty}a_{ii};矩阵特征值的和为对角线元素之和<br>$$</p><p>$$<br>(2)\prod_{i=1}^{n}\lambda_i=\left\lvert A\right\rvert;矩阵特征值的积为矩阵的行列式<br>$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维笔记13</title>
      <link href="2020/06/18/yun-wei-bi-ji-13/"/>
      <url>2020/06/18/yun-wei-bi-ji-13/</url>
      
        <content type="html"><![CDATA[<h2 id="运维笔记13"><a href="#运维笔记13" class="headerlink" title="运维笔记13"></a>运维笔记13</h2><h3 id="磁盘分区设置"><a href="#磁盘分区设置" class="headerlink" title="磁盘分区设置"></a>磁盘分区设置</h3><p>磁盘分区设置共分为3个步骤，在此博客中详细叙述。</p><ol><li>创建分区</li><li>创建文件系统</li><li>挂载分区到文件上</li></ol><h4 id="创建分区"><a href="#创建分区" class="headerlink" title="创建分区"></a>创建分区</h4><p>使用<code>fdisk</code>命令可以实现分区操作。<br><code>fdisk -l [device]</code>查看分区。<br><code>fdisk /dev/sdb</code>管理分区。<br>管理分区子命令：  </p><table><thead><tr><th align="center">p</th><th align="center">分区列表</th></tr></thead><tbody><tr><td align="center">t</td><td align="center">更改分区类型</td></tr><tr><td align="center">n</td><td align="center">创建新分区</td></tr><tr><td align="center">d</td><td align="center">删除分区</td></tr><tr><td align="center">v</td><td align="center">校验分区</td></tr><tr><td align="center">u</td><td align="center">转换单位</td></tr><tr><td align="center">w</td><td align="center">保存并推出</td></tr><tr><td align="center">q</td><td align="center">不保存退出</td></tr></tbody></table><p>在创建完分区之后需要同步分区表，使得新分区生效，需要使用<code>partprobe [device]</code>命令。重新同步分区表之后，可以使用<code>cat /proc/partations</code>命令查看系统是否识别了新的分区。<br><strong>注意：</strong> 在此<code>CentOS 6</code>与<code>CentOS 7</code>使用的同步分区命令是不同的，在这里介绍的是适用于<code>CentOS 7</code>的同步命令，如果需要<code>CentOS 6</code>可以查看对应的命令。</p><h4 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h4><p>文件系统是操作系统用于明确存储设备或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。操作系统中负责管理和存储文件信息的软件结构称为文件管理系统，简称文件系统。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研数学知识点总结6（考研中常用的分布）</title>
      <link href="2020/06/18/kao-yan-shu-xue-zhi-shi-dian-zong-jie-6/"/>
      <url>2020/06/18/kao-yan-shu-xue-zhi-shi-dian-zong-jie-6/</url>
      
        <content type="html"><![CDATA[<h2 id="常用分布"><a href="#常用分布" class="headerlink" title="常用分布"></a>常用分布</h2><p>常用的分布，包括离散型随机变量的分布与连续型随机变量的分布与其对应的概率密度函数都在这篇博客当中描述了出来，尤其要注意相关分布的特性以及应用场合，如果可以的话，可以记住分布之间的可转换性。</p><h3 id="离散分布"><a href="#离散分布" class="headerlink" title="离散分布"></a>离散分布</h3><h3 id="0-1-分布"><a href="#0-1-分布" class="headerlink" title="$0-1$分布"></a>$0-1$分布</h3><p><strong>定义：</strong> 如果随机变量$X$有分布律</p><table><thead><tr><th align="center">$X$</th><th align="center">$0$</th><th align="center">$1$</th></tr></thead><tbody><tr><td align="center">$P$</td><td align="center">$1-p$</td><td align="center">$p$</td></tr></tbody></table><p>$0&lt;p&lt;1$则称$X$服从参数为$p$的$0-1$分布，或称X具有$0-1$分布。</p><h3 id="二项分布（有放回的抽样）"><a href="#二项分布（有放回的抽样）" class="headerlink" title="二项分布（有放回的抽样）"></a>二项分布（有放回的抽样）</h3><p><strong>定义：</strong> 如果随机变量$X$有分布律</p><p>$$<br>P{X=k}=C^k_np^kq^{n-k}, k=0, 1, 2, \dotsb, n,<br>$$</p><p>其中$0&lt;p&lt;1, q=1-p, $则称$X$服从参数为n, p的二项分布，记作$X\sim B(n, p).$<br>在$n$重伯努利实验中，如果每次试验成功率为$p(0&lt;p&lt;1)$，则在n<br>次独立重复试验中成功的总次数$X$服从二项分布。<br>当$n=1$时，不难验证二项分布就退化为$0-1$分布，所以$0-1$分布也可以记为$B(1, p)$。  </p><h3 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h3><p><strong>定义：</strong> 如果随机变量$X$的分布律为<br>$$P{X=k}=\frac{\lambda^k}{k!}, k=0, 1, 2, \dotsb, $$<br>其中$\lambda&gt;0$为常数，则称随机变量$X$服从参数为$\lambda$的泊松分布，记为$X\sim P(\lambda)$。<br><strong>注意：</strong> 当二项分布的n很大p很小时，二项分布可以近似看做成泊松分布。</p><hr><h3 id="连续分布"><a href="#连续分布" class="headerlink" title="连续分布"></a>连续分布</h3><hr><h3 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h3><p><strong>定义：</strong> 如果连续型随机变量$X$的概率密度为</p><p>$$<br>f(n) = \begin{cases} \frac{1}{b-a}, &amp; a\leq x \leq b, \ 0, &amp; 其他, \end{cases}<br>$$<br>则称$X$在区间$[a, b]$上服从均匀分布，记作$X\sim U[a, b]$.<br>如果概率密度为<br>$$<br>f(n) = \begin{cases} \frac{1}{b-a}, &amp; a&lt; x &lt; b, \ 0, &amp; 其他, \end{cases}<br>$$<br>则称$X$在区间$(a, b)$上服从均匀分布，记作$X\sim U(a, b)$.</p><h3 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h3><p><strong>定义：</strong> 如果连续型随机变量$X$的概率密度为<br>$$<br>f(n) = \begin{cases}\lambda e^{-\lambda x}, &amp;x&gt;0, \0, &amp;x<br>\leq 0, \lambda &gt;0, \end{cases}<br>$$<br>称$X$服从参数为$\lambda$的指数分布，记作$X\sim E(\lambda)$<br>设$X\sim E(\lambda)$，则$X$的分布函数为<br>$$<br>F(x)=\begin{cases}<br>  1-e^{-\lambda x}, &amp;x&gt;0, \<br>  0, &amp;x\leq 0, \lambda&gt;0,<br>\end{cases}<br>$$</p><h3 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h3><p><strong>定义：</strong> 如果连续型随机变量$X$的概率密度为<br>$$<br>f(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}},-\infty&lt;x&lt;+\infty<br>$$<br>当$\mu,\sigma$为常数且$\sigma&gt;0$，则称$X$服从参数为$\mu,\sigma$的正态分布，记作$X\sim N(\mu,\sigma^2)$<br>当$\mu=0,\sigma^2=1$时，即$X\sim N(0,1)$，称$X$服从标准正态分布，此时用$\varphi(x)$表示$X$的概率密度，即$\varphi(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{x^2}{2}},-\infty&lt;x&lt;+\infty.$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研数学知识点总结5（矩阵）</title>
      <link href="2020/05/20/kao-yan-shu-xue-zhi-shi-dian-zong-jie-5/"/>
      <url>2020/05/20/kao-yan-shu-xue-zhi-shi-dian-zong-jie-5/</url>
      
        <content type="html"><![CDATA[<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="概念-amp-运算"><a href="#概念-amp-运算" class="headerlink" title="概念&amp;运算"></a>概念&amp;运算</h3><ul><li><strong>矩阵的定义</strong>：$m\times n$个数排列成的$m$行$n$列的表格。</li></ul><p>$$\begin{bmatrix}<br>    a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}\\<br>    a_{21}&amp;a_{22}&amp;\cdots&amp;a_{2n}\\<br>    \vdots&amp;\vdots&amp;\cdots&amp;\vdots\\<br>    a_{m1}&amp;a_{m2}&amp;\cdots&amp;a_{mn}<br>\end{bmatrix}\\$$<br>上述称为一个$m\times n$的矩阵，当$m=n$时，称为$n$阶矩阵或$n$阶方阵。</p><ul><li><p>如果一个矩阵所有的元素都是0，则称此矩阵为<strong>零矩阵</strong>，简记0。</p></li><li><p>如果$A$和$B$都是$m\times n$的矩阵，称$A$和$B$为<strong>同型矩阵</strong>。</p></li><li><p>设$A$和$B$为同型矩阵，如果$a_{ij}=b_{ij}(\forall i=1,2,\cdots ,m;\forall j=1,2,\cdots,m)$,则称$A=B$。</p></li><li><p>设$A=[a_{ij}]$为n阶方阵，其所有元素构成的行列式称为方阵$A$的行列式，记为$\left\lvert A\right\rvert$。</p></li><li><p><strong>注意</strong>:</p><ol><li><p>仅方阵才有行列式$\left\lvert A\right\rvert$。</p></li><li><p>$A=0$与$\left\lvert A\right\rvert=0$不要混淆。</p><p>$$A=\begin{bmatrix}<br>   1&amp;2\\<br>   2&amp;4<br>\end{bmatrix}\\ \neq0，但是\left\lvert A\right\rvert=0$$</p></li></ol></li><li><p><strong>矩阵的运算法则</strong></p><ol><li>同型矩阵的<strong>加法</strong>： $A+B=[a_{ij}+b{ij}]$。矩阵的加法相当于对应元素相加，且满足<strong>交换律</strong>、<strong>结合律</strong>。</li><li>矩阵的<strong>数乘</strong>：$kA=[ka_{ij}]$。矩阵的数乘相当于单独乘以每一个元素，且满足<strong>交换律</strong>、<strong>结合律</strong>。</li><li>矩阵的<strong>乘法</strong>：假设$A$矩阵是$m\times s$的矩阵，$B$矩阵是$s\times n$的矩阵（A的列数必须与B的行数相等），则$AB=C$，其中$C$矩阵为$m\times n$的矩阵，且满足$c_{ij}=a_{i1}b_{1j}+a_{i2}b_{2j}+\cdots+a_{is}b_{sj}$（行与列点积）。乘法满足<strong>结合律</strong>，<strong>分配律</strong>，但<strong>不满足交换律</strong>。</li><li>与<strong>单位矩阵</strong>$E$相乘：$AE=A$。</li><li><strong>转置</strong>：设$[a_{ij}]_{m\times n}$，将这个矩阵行列互换，得到矩阵$A^T$，新矩阵为原矩阵的转置矩阵。记作$A=A^T$。<ul><li>$(A+B)^T=A^T+B^T$</li><li>$(kA)^T=kA^T$</li><li>$(AB)^T=B^TA^T$</li><li>$(A^T)^T=A$</li></ul></li></ol></li><li><p><strong>注意</strong>：</p><ol><li>$AB\neq BA$矩阵乘法没有交换律。</li><li>$AB=0\nRightarrow A=0或b=0$。</li><li>$AB=AC且A\neq 0 \nRightarrow B=C$。</li></ol></li><li><p><strong>对角矩阵</strong>的运算：</p><ul><li>对角矩阵的定义：只有在主对角线上有值，其余位置全为0的矩阵称为对角矩阵。</li></ul></li></ul><p>$$\begin{bmatrix}<br>    a_1&amp;0&amp;0\\<br>    0&amp;a_2&amp;0\\<br>    0&amp;0&amp;a_3<br>\end{bmatrix}<br>\begin{bmatrix}<br>    b1&amp;0&amp;0\\<br>    0&amp;b_2&amp;0\\<br>    0&amp;0&amp;b_3<br>\end{bmatrix}=<br>\begin{bmatrix}<br>    a_1b_1&amp;0&amp;0\\<br>    0&amp;a_2b_2&amp;0\\<br>    0&amp;0&amp;a_2b_3<br>\end{bmatrix}\\$$</p><ul><li><p><strong>注意</strong>：</p><ol><li>$\wedge_1\wedge_2=\wedge_2\wedge_1$满足<strong>交换律</strong>。</li><li>n个对角矩阵等于对角矩阵元素的n次方。<br>$$\begin{bmatrix}<br> a_1\\<br> &amp;a_2\\<br> &amp;&amp;a_3<br>\end{bmatrix}^n=<br>\begin{bmatrix}<br> a_1^n\\<br> &amp;a_2^n\\<br> &amp;&amp;a_3^n<br>\end{bmatrix}\\$$</li><li>对角矩阵求逆等于对角矩阵个元素求倒数。<br>$$\begin{bmatrix}<br> a_1\\<br> &amp;a_2\\<br> &amp;&amp;a_3<br>\end{bmatrix}^{-1}=<br>\begin{bmatrix}<br> \frac{1}{a_1}\\<br> &amp;\frac{1}{a_2}\\<br> &amp;&amp;\frac{1}{a_3}<br>\end{bmatrix}\\$$</li></ol></li></ul><h3 id="伴随矩阵"><a href="#伴随矩阵" class="headerlink" title="伴随矩阵"></a>伴随矩阵</h3><ul><li>定义：假设$A$是n阶方阵，$A$的伴随矩阵为$A^\ast$</li></ul><p>$$A^\ast=\begin{bmatrix}<br>    A_{11}&amp;A_{21}&amp;\cdots&amp;A_{n1}\\<br>    A_{12}&amp;A_{22}&amp;\cdots&amp;A_{n2}\\<br>    \vdots&amp;\vdots&amp;\cdots&amp;\vdots\\<br>    A_{1n}&amp;A_{2n}&amp;\cdots&amp;A_{nn}<br>\end{bmatrix}\\其中，A_{ij}为第i行第j列的代数余子式。$$</p><ul><li><p>性质：</p><ul><li>$AA^\ast=A^\ast A=\left\lvert A\right\rvert E$</li><li>$(kA)^\ast=k^{n-1}A^\ast$</li><li>$(A^\ast)^T=(A^T)^\ast$</li><li>$\left\lvert A^\ast\right\rvert=\left\lvert A\right\rvert^{n-1}$</li><li>$(A^\ast)^\ast=\left\lvert A\right\rvert^{n-2}A$</li><li>$A^{-1}=\left\lvert A\right\rvert^{-1}A^\ast,A^\ast=\left\lvert A\right\rvert A^{-1}$</li><li>$(A^\ast)^{-1}=(A^{-1})^\ast=\left\lvert A\right\rvert^{-1}A$</li></ul></li><li><p>注意：</p></li></ul><p>$$r(A^\ast)=\begin{cases}<br>    n,&amp;r(A)=n\\<br>    1,&amp;r(A)=n-1\\<br>    0,&amp;r(A)&lt;n-1<br>\end{cases}\\$$</p><h3 id="可逆矩阵"><a href="#可逆矩阵" class="headerlink" title="可逆矩阵"></a>可逆矩阵</h3><ul><li><p>定义：假设$A$是$n$阶矩阵，如果存在$n$阶矩阵B，使$AB=BA=E$成立，则称$A$是<strong>可逆矩阵</strong>，$B$是$A$的<strong>逆矩阵</strong>，记作$A^{-1}=B$。</p></li><li><p>定理1：如果$A$可逆，则$A$的<strong>逆矩阵唯一</strong>。</p></li><li><p>定理2：设$A、B$均为$n$阶方阵，且$AB=E$，则$BA=E$。</p></li><li><p>定理3：$A$矩阵可逆$\Leftrightarrow \left\lvert A\right\rvert\neq0$。</p></li><li><p>性质</p><ol><li>如果$A$可逆，则$A^{-1}$也可逆，且$(A^{-1})^{-1}=A$。</li><li>如果$A$可逆，且$k\neq 0$，则$kA$可逆，且$(kA)^{-1}=k^{-1}A^{-1}$。</li><li>如果$A、B$均可逆，则$AB$也可逆，且$(AB)^{-1}=B^{-1}A^{-1}$，特别地，$(A^2)^{-1}=(A^{-1})^2,(A^n)^{-1}=(A^{-1})^n$。</li><li>如果$A$可逆，则$A^T$也可逆，且$(A^T)^{-1}=(A^{-1})^T$。</li><li>二阶矩阵的逆矩阵求法：主对角线互换，副对角线变号。</li></ol></li><li><p><strong>注意</strong>：</p><ol><li>如果$A$可逆，则$\left\lvert A^{-1}\right\rvert=\left\lvert A\right\rvert^{-1}$。</li><li>当$A、B、A+B$都可逆时，$(A+B)^{-1}\neq A^{-1}+B^{-1}$（处理这个矩阵的时候要利用单位矩阵变形）。</li></ol></li><li><p>求逆矩阵的方法</p><ol><li>定义法。</li><li>使用伴随矩阵求逆矩阵。</li><li>使用初等行变换求逆矩阵。$(A|E)\longrightarrow(E|A^{-1})$。</li><li>使用分块矩阵求逆矩阵。<br>$$\begin{bmatrix}<br>   A&amp;0\\<br>   0&amp;B<br>\end{bmatrix}^{-1}=<br>\begin{bmatrix}<br>   A^{-1}&amp;0\\<br>   0&amp;B^{-1}<br>\end{bmatrix}或<br>\begin{bmatrix}<br>   0&amp;A\\<br>   B&amp;0<br>\end{bmatrix}^{-1}=<br>\begin{bmatrix}<br>   0&amp;B^{-1}\\<br>   A^{-1}&amp;0<br>\end{bmatrix}\\$$</li></ol></li></ul><h3 id="初等变换与初等矩阵"><a href="#初等变换与初等矩阵" class="headerlink" title="初等变换与初等矩阵"></a>初等变换与初等矩阵</h3><ul><li><p>矩阵的初等行（列）变换</p><ol><li>用$k\neq 0$乘第$A$行中的每一个元素（倍乘）。</li><li>互换$A$中的两行元素（互换）。</li><li>把某行的元素的$k$倍加到另一行上（倍加）。</li></ol></li><li><p>初等矩阵</p><ul><li>单位矩阵经过一次初等变换所得的矩阵称为初等矩阵。</li><li>初等矩阵$P$左乘$A$，$PA$是$A$作一次与$P$同样的行变换（左乘行变换）。</li><li>初等矩阵$P$右乘$A$，$PA$是$A$作一次与$P$同样的列变换（右乘列变换）。</li></ul></li><li><p>初等矩阵的逆矩阵</p><ul><li><p>倍加矩阵的逆矩阵还是初等矩阵（倍加）</p><p>$$\begin{bmatrix}<br>1&amp;0&amp;X\\<br>0&amp;1&amp;0\\<br>0&amp;0&amp;1<br>\end{bmatrix}^{-1}=<br>\begin{bmatrix}<br>1&amp;0&amp;-X\\<br>0&amp;1&amp;0\\<br>0&amp;0&amp;1<br>\end{bmatrix}\\$$</p></li><li><p>互换矩阵的逆矩阵是其本身</p><p>$$\begin{bmatrix}<br>0&amp;1&amp;0\\<br>1&amp;0&amp;0\\<br>0&amp;0&amp;1<br>\end{bmatrix}^{-1}=<br>\begin{bmatrix}<br>0&amp;1&amp;0\\<br>1&amp;0&amp;0\\<br>0&amp;0&amp;1<br>\end{bmatrix}\\$$</p></li><li><p>倍乘矩阵的逆矩阵还是倍乘矩阵</p><p>$$\begin{bmatrix}<br>1&amp;0&amp;0\\<br>0&amp;k&amp;0\\<br>0&amp;0&amp;1<br>\end{bmatrix}^{-1}=<br>\begin{bmatrix}<br>1&amp;0&amp;0\\<br>0&amp;\frac{1}{k}&amp;0\\<br>0&amp;0&amp;1<br>\end{bmatrix}\\$$</p></li><li><p>可逆矩阵$A$总可以表示为若干初等矩阵的乘积。</p></li></ul></li><li><p>行阶梯矩阵</p><ol><li>如果有零行，则零行一定在矩阵的底部。</li><li>每个非零行的主元（即该行最左边的第一个非零元）所在的列下面是零。</li><li>行最简：一个阶梯矩阵，如果还满足：非零行的主元都是1，且主元所在列的其他元素都是零，则称该阶梯矩阵行最简。</li></ol></li><li><p>矩阵等价</p><ul><li>如果矩阵$A$可以通过若干次初等变换得到$B$,就称矩阵$A$和$B$等价。</li><li>等价的充要条件：两个矩阵秩相等。$A\cong B\Longleftrightarrow r(A)=r(B)$</li></ul></li></ul><h3 id="分块矩阵"><a href="#分块矩阵" class="headerlink" title="分块矩阵"></a>分块矩阵</h3><ul><li><p>分块运算</p><ol><li><p>加法</p><p>$$\begin{bmatrix}<br>   A_1&amp;A_2\\<br>   A_3&amp;A_4<br>\end{bmatrix}+<br>\begin{bmatrix}<br>   B_1&amp;B_2\\<br>   B_3&amp;B_4<br>\end{bmatrix}=<br>\begin{bmatrix}<br>   A_1+B_1&amp;A_2+B_2\\<br>   A_3+B_3&amp;A_4+B_4<br>\end{bmatrix}\\$$</p></li><li><p>乘法</p><p>$$\begin{bmatrix}<br>   A&amp;B\\<br>   C&amp;D<br>\end{bmatrix}\cdot<br>\begin{bmatrix}<br>   X&amp;Y\\<br>   Z&amp;W<br>\end{bmatrix}=<br>\begin{bmatrix}<br>   AX+BZ&amp;AY+BW\\<br>   CX+DZ&amp;CY+DW<br>\end{bmatrix}\\$$</p></li><li><p>转置</p><p>$$\begin{bmatrix}<br>   A&amp;B\\<br>   C&amp;D<br>\end{bmatrix}^T=<br>\begin{bmatrix}<br>   A^T&amp;C^T\\<br>   B^T&amp;D^T<br>\end{bmatrix}\\$$</p></li><li><p>连乘</p><p>$$\begin{bmatrix}<br>   A&amp;0\\<br>   0&amp;B<br>\end{bmatrix}^n=<br>\begin{bmatrix}<br>   A^n&amp;0\\<br>   0&amp;B^n<br>\end{bmatrix}\\$$</p></li><li><p>求逆</p><p>$$\begin{bmatrix}<br>   A&amp;0\\<br>   0&amp;B<br>\end{bmatrix}^{-1}=<br>\begin{bmatrix}<br>   A^{-1}&amp;0\\<br>   0&amp;B^{-1}<br>\end{bmatrix}或<br>\begin{bmatrix}<br>   0&amp;A\\<br>   B&amp;0<br>\end{bmatrix}^{-1}=<br>\begin{bmatrix}<br>   0&amp;B^{-1}\\<br>   A^{-1}&amp;0<br>\end{bmatrix}\\$$</p></li></ol></li></ul><h3 id="方阵的行列式"><a href="#方阵的行列式" class="headerlink" title="方阵的行列式"></a>方阵的行列式</h3><ol><li>$\left\lvert A^T\right\rvert=\left\lvert A\right\rvert$</li><li>$\left\lvert kA\right\rvert=k^n\left\lvert A\right\rvert$</li><li>$\left\lvert AB\right\rvert=\left\lvert A\right\rvert\left\lvert B\right\rvert$</li><li>$\left\lvert A^2\right\rvert=\left\lvert A\right\rvert^2$</li><li>$\left\lvert A^\ast\right\rvert=\left\lvert A\right\rvert^{n-1}$</li><li>$\left\lvert A^{-1}\right\rvert=\left\lvert A\right\rvert^{-1}$</li><li>$$\begin{bmatrix}<br>   A&amp;0\\<br>   \ast&amp;B<br>   \end{bmatrix}=<br>   \begin{bmatrix}<br>   A&amp;\ast\\<br>   0&amp;B<br>   \end{bmatrix}=\left\lvert A\right\rvert\left\lvert B\right\rvert\\$$</li><li>$$\begin{bmatrix}<br>   0&amp;A\\<br>   B&amp;\ast<br>   \end{bmatrix}=<br>   \begin{bmatrix}<br>   \ast&amp;A\\<br>   B&amp;0<br>   \end{bmatrix}=(-1)^{mn}\left\lvert A\right\rvert\left\lvert B\right\rvert\\$$</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 考研数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研数学知识点总结4（行列式）</title>
      <link href="2020/05/19/kao-yan-shu-xue-zhi-shi-dian-zong-jie-4/"/>
      <url>2020/05/19/kao-yan-shu-xue-zhi-shi-dian-zong-jie-4/</url>
      
        <content type="html"><![CDATA[<h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><h3 id="行列式的概念"><a href="#行列式的概念" class="headerlink" title="行列式的概念"></a>行列式的概念</h3><ul><li><strong>行列式</strong>是一个数，是不同行不同列乘积的代数和。</li></ul><p>$$\begin{vmatrix}<br>    a&amp;b\\<br>    c&amp;d<br>\end{vmatrix}=ad-bc$$<br>$$\begin{vmatrix}<br>    a_1&amp;a_2&amp;a_3\\<br>    a_4&amp;a_5&amp;a_6\\<br>    a_7&amp;a_8&amp;a_9<br>\end{vmatrix}=a_1b_2c_3+a_2b_3c_1+a_3b_1c_2\\<br>-a_3b_2c_1-a_2b_1c_3-a_1b_3c_2$$</p><ul><li><strong>排列的定义</strong>：由1~n组成的有序数组称为n阶排列，通常用$\Sigma_{i=1}^nj_i$表示n阶排列。</li><li><strong>逆序的定义</strong>：一个排列中，如果一个大的数排在小的数前面，则称这两个数构成一个逆序。</li><li>一个排列中的逆序总数称为排列的<strong>逆序数</strong>，用$\tau(j_1,j_2,…,j_3)$表示$j_1,j_2,…,j_3$的逆序数。</li><li><strong>奇排列偶排列的定义</strong>：如果一个排列的逆序数是偶数，则称排列为偶排列，否则称为奇排列。</li></ul><h3 id="行列式的性质"><a href="#行列式的性质" class="headerlink" title="行列式的性质"></a>行列式的性质</h3><ol><li>经过转置之后行列式的值不变。<strong>（转置值不变）</strong></li></ol><p>$$\left\lvert A^T\right\rvert = \left\lvert A\right\rvert $$</p><ol start="2"><li><p>行列式两行互换，行列式的值变号。特别地，两行相同行列式的值为0。<strong>（互换行变号）</strong></p></li><li><p>某行有公因数k，可把k提出行列式外。特别地，某行全为0，行列式的值为0。<strong>（可提公因数）</strong></p></li><li><p>如果某行元素是两个数之和，可把行列式拆成两个行列式之和。<strong>（行列式可拆）</strong></p></li></ol><p>$$\begin{vmatrix}<br>    a_{11}+b_{1}&amp;a_{12}+b_{2}&amp;a_{13}+b_{3}\\<br>    a_{21}&amp;a_{22}&amp;a_{23}\\<br>    a_{31}&amp;a_{32}&amp;a_{33}<br>\end{vmatrix}=<br>\begin{vmatrix}<br>    a_{11}&amp;a_{12}&amp;a_{13}\\<br>    a_{21}&amp;a_{22}&amp;a_{23}\\<br>    a_{31}&amp;a_{32}&amp;a_{33}<br>\end{vmatrix}+<br>\begin{vmatrix}<br>    b_{1}&amp;b_{2}&amp;b_{3}\\<br>    a_{21}&amp;a_{22}&amp;a_{23}\\<br>    a_{31}&amp;a_{32}&amp;a_{33}<br>\end{vmatrix}<br>$$</p><ol start="5"><li>某行的k倍加到1另一行上行列式的值不变。</li></ol><h3 id="行列式的展开公式"><a href="#行列式的展开公式" class="headerlink" title="行列式的展开公式"></a>行列式的展开公式</h3><ul><li><p><strong>余子式：</strong>$a_{ij}$的余子式是去掉第$i$行第$j$列后得到的矩阵，记为$M_{ij}$。</p></li><li><p><strong>代数余子式：</strong>$A_{ij}=(-1)^{i+j}a_{ij}$。</p></li><li><p><strong>通过代数余子式计算行列式：</strong>$\left\lvert A\right\rvert=a_{11}A_{11}+a_{12}A_{12}+…+a_{1n}A_{1n}$</p></li><li><p><strong>重要公式：</strong></p><ol><li><p>上下三角矩阵的值是主对角线元素的乘积。</p><p>$$\begin{vmatrix}<br>   a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}\\<br>   &amp;a_{22}&amp;\cdots&amp;a_{2n}\\<br>   &amp;&amp;\ddots&amp;\vdots\\<br>   &amp;&amp;&amp;a_{nn}<br>\end{vmatrix}=<br>\begin{vmatrix}<br>   a_{11}\\<br>   a_{21}&amp;a_{22}\\<br>   \vdots&amp;\vdots&amp;\ddots\\<br>   a_{n1}&amp;a_{n2}&amp;\cdots&amp;a_{nn}<br>\end{vmatrix}=<br>a_{11}a_{22}\cdots a_{nn}$$</p></li><li><p>上下反三角矩阵的值是副对角线元素的乘积加上或不加符号。</p><p>$$\begin{vmatrix}<br>   a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}\\<br>   a_{21}&amp;\cdots&amp;a_{2(n-1)}\\<br>   \vdots&amp;\cdot\\<br>   a_{n1}<br>\end{vmatrix}=<br>\begin{vmatrix}<br>   &amp;&amp;&amp;a_{1n}\\<br>   &amp;&amp;a_{2(n-1)}&amp;a_{2n}\\<br>   &amp;\cdot&amp;\vdots&amp;\vdots\\<br>   a_{n1}&amp;a_{n2}&amp;\cdots&amp;a_{nn}<br>\end{vmatrix}=<br>(-1)^{\frac{n(n-1)}{2}}a_{11}a_{22}\cdots a_{nn}$$</p></li><li><p>拉普拉斯公式三角（有零在角上时可以使用该公式）</p><p>$$\begin{vmatrix}<br>   A&amp;0\\<br>   \ast&amp;B<br>\end{vmatrix}=<br>\begin{vmatrix}<br>   A&amp;\ast\\<br>   0&amp;B<br>\end{vmatrix}=<br>\begin{vmatrix}<br>   A<br>\end{vmatrix}<br>\begin{vmatrix}<br>   B<br>\end{vmatrix}$$</p></li><li><p>拉普拉斯公式反三角（其中m为A方阵阶数，n为B方阵阶数）</p><p>$$\begin{vmatrix}<br>   0&amp;A\\<br>   B&amp;\ast<br>\end{vmatrix}=<br>\begin{vmatrix}<br>   \ast&amp;A\\<br>   B&amp;0<br>\end{vmatrix}=(-1)^{mn}<br>\begin{vmatrix}<br>   A<br>\end{vmatrix}<br>\begin{vmatrix}<br>   B<br>\end{vmatrix}$$</p></li><li><p>范德蒙矩阵</p><p>$$\begin{vmatrix}<br>   1&amp;1&amp;\cdots&amp;1\\<br>   x_1&amp;x_2&amp;\cdots&amp;x_n\\<br>   x_1^2&amp;x_2^2&amp;\cdots&amp;x_n^2\\<br>   \vdots&amp;\vdots&amp;\vdots&amp;\vdots\\<br>   x_1^{n-1}&amp;x_2^{n-1}&amp;\cdots&amp;x_n^{n-1}<br>\end{vmatrix}=<br>\prod_{1\le j&lt;i\le n}(x_i-x_j)\\<br>所有大的数减小的数的差的乘积。$$</p></li><li><p>爪型行列式</p><p>$$形如，<br>\begin{vmatrix}<br>   x&amp;x&amp;x&amp;x\\<br>   x&amp;x&amp;0&amp;0\\<br>   x&amp;0&amp;x&amp;0\\<br>   x&amp;0&amp;0&amp;x<br>\end{vmatrix}\\<br>的行列式为爪型行列式。$$</p><ul><li>运算方法为，将第一行（列）的所有元素消去，利用上（下）三角法则运算。</li></ul></li></ol></li></ul><h2 id="克拉默法则"><a href="#克拉默法则" class="headerlink" title="克拉默法则"></a>克拉默法则</h2><ul><li><p>如果方程的系数行列式$D=\left\lvert A\right\rvert\neq 0$，则方程存在唯一解，且，</p><p>$$x_1=\frac{D_1}{D}, x_2=\frac{D_2}{D}, \cdots, x_n=\frac{D_n}{D}\\$$</p><p>其中，$D_i$为将第$i$列替代为常数项列$b_1,b_2,\cdots,b_n$后的行列式。</p></li><li><p><strong>推论1</strong>：如果齐次方程组的系数行列式不为0，则方程组只有一组零解</p></li><li><p><strong>推论2</strong>：如果齐次方程组有非零解，则它的系数行列式必为0。</p><p><strong>注</strong>：齐次方程组：常数项系数为0的方程组称为齐次方程组</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 考研数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维笔记12</title>
      <link href="2020/05/06/yun-wei-bi-ji-12/"/>
      <url>2020/05/06/yun-wei-bi-ji-12/</url>
      
        <content type="html"><![CDATA[<h1 id="运维笔记11"><a href="#运维笔记11" class="headerlink" title="运维笔记11"></a>运维笔记11</h1><h2 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h2><ul><li><p>可以通过如下命令获取帮助</p><ul><li><code>whatis</code></li><li><code>command --help</code></li><li><code>man and info</code></li><li><code>/usr/share/doc/</code></li><li><code>Red Hat documentation</code></li></ul></li></ul><h2 id="whatis命令"><a href="#whatis命令" class="headerlink" title="whatis命令"></a><code>whatis</code>命令</h2><ul><li><p>显示命令的简短描述</p></li><li><p>使用数据库</p></li><li><p>刚安装后不可以立刻使用</p></li><li><p><code>makewhatis | mandb</code>制作数据库</p></li><li><p>使用实例：</p><ul><li><code>whatis cal</code>或<code>man -f cal</code></li></ul></li></ul><h2 id="命令帮助"><a href="#命令帮助" class="headerlink" title="命令帮助"></a>命令帮助</h2><ul><li><p>内部命令：<code>help COMMAND</code>或<code>man bash</code></p></li><li><p>外部命令：</p><ul><li><code>COMMAND --help</code>或<code>COMMAND -h</code></li><li>使用手册<code>manual</code>：<code>man COMMAND</code></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维笔记10</title>
      <link href="2020/05/06/yun-wei-bi-ji-11/"/>
      <url>2020/05/06/yun-wei-bi-ji-11/</url>
      
        <content type="html"><![CDATA[<h1 id="运维笔记11"><a href="#运维笔记11" class="headerlink" title="运维笔记11"></a>运维笔记11</h1><h2 id="bash的快捷键"><a href="#bash的快捷键" class="headerlink" title="bash的快捷键"></a>bash的快捷键</h2><ul><li><code>Ctrl + a</code>光标移到命令行首，相当于<code>Home</code></li><li><code>Ctrl + e</code>光标移到命令行尾，相当于<code>End</code></li><li><code>Ctrl + f</code>光标向右移动一个字符</li><li><code>Ctrl + b</code>光标向左移动一个字符</li><li><code>Alt + f</code>光标向右移动一个单词尾</li><li><code>Alt + f</code>光标向左移动一个单词首</li><li><code>Ctrl + xx</code>光标在命令行首和光标之间移动</li><li><code>Ctrl + u</code>从光标处删除至命令行首</li><li><code>Ctrl + k</code>从光标处删除至命令行尾</li><li><code>Alt + r</code>删除当前整行</li></ul><h2 id="bash的快键键"><a href="#bash的快键键" class="headerlink" title="bash的快键键"></a>bash的快键键</h2><ul><li><code>Ctrl + l</code>清屏，相当于clear命令</li><li><code>Ctrl + o</code>执行当前命令，并重新显示本命令</li><li><code>Ctrl + s</code>组织屏幕删除，锁定</li><li><code>Ctrl + q</code>允许屏幕输出</li><li><code>Ctrl + c</code>终止命令</li><li><code>Ctrl + z</code>挂起命令</li></ul><h2 id="bash的快捷键-1"><a href="#bash的快捷键-1" class="headerlink" title="bash的快捷键"></a>bash的快捷键</h2><ul><li><code>Ctrl + w</code> 从光标处向左删除至单词首</li><li><code>Alt + d</code> 从光标处向右删除至单词尾</li><li><code>Ctrl + d</code> 删除光标处的一个字符</li><li><code>Ctrl + h</code> 删除光标前的一个字符</li><li><code>Ctrl + y</code> 将删除的字符粘贴至光标后</li><li><code>Alt + c</code> 从光标处开始向右更改为首字母大写的单词</li><li><code>Alt + u</code> 从光标处开始，将右边一个单词更改为大写</li><li><code>Alt + l</code> 从光标处开始，将右边一个单词更改为小写</li><li><code>Ctrl + t</code> 交换光标处和之前的字符位置</li><li><code>Alt + t</code> 交换光标处和之前的单词位置</li><li><code>Alt + N</code> 提示输入指定字符后，重复显示该字符N次</li><li>注意： Alt组合快捷键经常和其它软件冲突</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研数学知识点总结3（导数）</title>
      <link href="2020/04/23/kao-yan-shu-xue-zhi-shi-dian-zong-jie-3/"/>
      <url>2020/04/23/kao-yan-shu-xue-zhi-shi-dian-zong-jie-3/</url>
      
        <content type="html"><![CDATA[<h2 id="导数与微分的概念"><a href="#导数与微分的概念" class="headerlink" title="导数与微分的概念"></a>导数与微分的概念</h2><ol><li><p>导数的概念</p><ul><li>导数的定义</li><li>左导数的定义</li><li>右导数的定义</li><li>定理：函数在$x_0$处可导的充分必要条件</li><li>区间上可导与导函数的定义</li></ul></li><li><p>微分的概念</p><ul><li>微分的定义</li><li>定理函数在$x_0$处可微的充要条件</li></ul></li><li><p>导数与微分的几何意义</p><ul><li>导数的几何意义</li><li>微分的几何意义</li></ul></li></ol><ul><li>连续、可导以及可微之间的关系</li></ul><h2 id="导数公式与求导法则"><a href="#导数公式与求导法则" class="headerlink" title="导数公式与求导法则"></a>导数公式与求导法则</h2><ol><li><p>基本初等函数的导数公式</p><ul><li>C</li><li>$x^a$</li><li>$a^x$</li><li>$e^x$</li><li>$log_ax$</li><li>$ln\left\lvert x\right\rvert$</li><li>$sinx$</li><li>$cosx$</li><li>$tanx$</li><li>$cotx$</li><li>$secx$</li><li>$cscx$</li><li>$arcsinx$</li><li>$arccosx$</li><li>$arctanx$</li><li>$arccotx$</li></ul></li><li><p>求导法则</p><ul><li>有理运算法则</li><li>复合函数求导法</li><li>隐函数求导法</li><li>反函数的导数</li><li>参数方程求导法</li><li>对数求导法</li></ul></li></ol><h2 id="高阶导数"><a href="#高阶导数" class="headerlink" title="高阶导数"></a>高阶导数</h2><ol><li><p>高阶导数的概念</p><ul><li>高阶导数的定义</li><li>函数在x处n阶可导，则函数在x的某一个领域内必定具有一切低于n阶的导数</li></ul></li><li><p>常用的高阶求导公式（4个）</p><ul><li>$(sinx)^{(n)}$</li><li>$(cosx)^{(n)}$</li><li>$(u\pm v)^{(n)}$</li><li>$(uv)^{(n)}$</li></ul></li></ol><h2 id="导数的应用"><a href="#导数的应用" class="headerlink" title="导数的应用"></a>导数的应用</h2><ol><li>导数的几何意义（求切线法线）</li><li>相关变化率</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 考研数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研数学知识点总结2（连续）</title>
      <link href="2020/04/23/kao-yan-shu-xue-zhi-shi-dian-zong-jie-2/"/>
      <url>2020/04/23/kao-yan-shu-xue-zhi-shi-dian-zong-jie-2/</url>
      
        <content type="html"><![CDATA[<h2 id="连续性的概念"><a href="#连续性的概念" class="headerlink" title="连续性的概念"></a>连续性的概念</h2><ol><li>连续的定义（两个）（连续性是研究函数在某点的极限值与该点数值之间的关系）</li><li>左连续定义</li><li>右连续定义</li><li>函数在$x_0$处连续的充要条件</li><li>函数的开区间和闭区间上连续的定义</li></ol><h2 id="间断点及其分类"><a href="#间断点及其分类" class="headerlink" title="间断点及其分类"></a>间断点及其分类</h2><ol><li><p>间断点的定义</p></li><li><p>间断点的分类</p><ul><li><p>第一类间断点的定义</p><ol><li>可去间断点的定义</li><li>跳跃间断点</li></ol></li><li><p>第二类间断点的定义（答题可以直接答第二类间断点）</p><ol><li>无穷间断点</li><li>振荡间断点</li></ol></li></ul></li></ol><h2 id="连续性的运算与性质"><a href="#连续性的运算与性质" class="headerlink" title="连续性的运算与性质"></a>连续性的运算与性质</h2><ol><li>定理：两个函数在$x_0$连续，则和差积商也连续</li><li>定理：复合函数的内外函数若均连续，则符合函数也连续</li><li>基本初等函数在其定义域内都是连续的</li><li>初等函数在其定义区间内都是连续的</li></ol><h2 id="闭区间上连续函数的性质"><a href="#闭区间上连续函数的性质" class="headerlink" title="闭区间上连续函数的性质"></a>闭区间上连续函数的性质</h2><p>下列定理均要求函数在闭区间内连续</p><ol><li><p>最值定理</p></li><li><p>有界性定理</p></li><li><p>介值定理</p><ul><li>推论最大值最小值定理</li></ul></li><li><p>零点定理（应用：证明跟的存在性）</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 考研数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研数学知识点总结1（极限）</title>
      <link href="2020/04/23/kao-yan-shu-xue-zhi-shi-dian-zong-jie-1/"/>
      <url>2020/04/23/kao-yan-shu-xue-zhi-shi-dian-zong-jie-1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、极限的概念"><a href="#一、极限的概念" class="headerlink" title="一、极限的概念"></a>一、极限的概念</h2><ol><li><p>数列的极限定义（$\varepsilon -N$）</p></li><li><p>函数的极限</p><ul><li>自变量趋于无穷大时函数的极限（$\varepsilon -X$）</li><li>自变量趋于有限值时函数的极限（$\varepsilon -\delta$）（要求的是去心邻域，即函数值可以在这一点没有定义）</li><li>左极限定义（$\varepsilon -\delta$）</li><li>右极限定义（$\varepsilon -\delta$）</li><li>定理：函数极限存在的充要条件</li></ul></li></ol><h2 id="二、极限的性质"><a href="#二、极限的性质" class="headerlink" title="二、极限的性质"></a>二、极限的性质</h2><ol><li><p>有界性</p></li><li><p>保号性</p><ul><li>注意如果 $f(x)&gt;0$，只能推得 $limf(x)\geq0$，但是 $limf(x)&gt;0$ 却可以推得 $f(x)&gt;0$。可以从极限的定义考虑这个问题。</li></ul></li><li><p>极限值与无穷小量之间的关系</p></li></ol><h2 id="三、极限存在的准则"><a href="#三、极限存在的准则" class="headerlink" title="三、极限存在的准则"></a>三、极限存在的准则</h2><ol><li>夹逼准则</li><li>单调有界准则</li></ol><h2 id="四、无穷小量"><a href="#四、无穷小量" class="headerlink" title="四、无穷小量"></a>四、无穷小量</h2><ol><li><p>无穷小量的概念</p></li><li><p>无穷小量的比较</p><ul><li>高阶</li><li>低阶</li><li>同阶</li><li>等价</li><li>无穷小阶的定义</li></ul></li><li><p>无穷小的性质</p><ul><li>有限个无穷小的和仍然是无穷小</li><li>有限个无穷小的积仍然是无穷小</li><li>无穷小量与有界量的积仍然是无穷小</li></ul></li></ol><h2 id="无穷大量"><a href="#无穷大量" class="headerlink" title="无穷大量"></a>无穷大量</h2><ol><li><p>无穷大量的概念</p></li><li><p>常用的一些无穷大量的比较（五个无穷大量的比较）</p></li><li><p>无穷大量的性质</p><ul><li>两个无穷大量的积仍然是无穷大量</li><li>无穷大量与有界变量之和仍然是无穷大量</li></ul></li><li><p>无穷大量与无界变量的关系（回顾无穷大量与无界变量定义的区别）</p></li><li><p>无穷大量与无穷小量的关系</p></li></ol><h2 id="求极限（7种方法-8种方法）"><a href="#求极限（7种方法-8种方法）" class="headerlink" title="求极限（7种方法/8种方法）"></a>求极限（7种方法/8种方法）</h2><ol><li><p>利用基本极限求极限</p></li><li><p>利用等价无穷小求极限</p></li><li><p>利用有理运算法则求极限</p><ul><li>如果两个函数的极限存在，他们的和差积的极限也存在，如果位于分母的函数极限不为零，那么商也存在。</li><li>存在 $\pm$ 不存在 $=$ 不存在，其他牵扯到极限不存在的函数的运算结果均为不一定。</li></ul></li><li><p>利用洛必达法则求极限</p><p> 使用条件：</p><ul><li>（易错）$lim_{x \to x_0}f(x)=lim_{x \to x_0}g(x)=0(\infty)$</li><li>$f(x)$ 和 $g(x)$ 在 $x_0$ 的某个去心邻域内可导，且 $g(x) \neq 0$</li><li>（易错）$lim_{x \to x_0}\frac{f’(x)}{g’(x)}$ 存在</li></ul></li><li><p>利用泰勒公式求极限（带<code>Peano</code>余项的泰勒公式）</p><ul><li>四个常用泰勒公式（$e^x,sinx,cosx,ln(1+x)$）</li></ul></li><li><p>利用夹逼准则求极限</p></li><li><p>利用单调有界性准则求极限</p><ul><li>证明单调有界（极限存在）之后使用两边取极限</li></ul></li><li><p>利用定积分定义求极限</p><ul><li>提可爱因子$\frac{1}{n}$。</li></ul></li><li><p>利用拉格朗日中值定理求极限</p><ul><li>出现两个相同形式的函数的差的时候可以使用拉格朗日中值定理。</li><li>尤其是复杂函数的差可以考虑用拉格朗日中值定理，例如，根式的差，指数函数的差，三角函数的差，反三角函数的差</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 考研数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研数学易错点总结</title>
      <link href="2020/04/23/kao-yan-shu-xue-yi-cuo-dian-zong-jie/"/>
      <url>2020/04/23/kao-yan-shu-xue-yi-cuo-dian-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-函数与数列的极限的定义"><a href="#第一章-函数与数列的极限的定义" class="headerlink" title="第一章 函数与数列的极限的定义"></a>第一章 函数与数列的极限的定义</h2><ul><li>数列的极限趋向于无穷默认趋向于正无穷$\lim_{x \to \infty} a_n=\lim_{x \to +\infty} a_n$。</li><li>函数在某一点极限存在的充分必要条件为函数在该点的左右极限存在且相等，即$\lim_{x \to x_0^{-1}} {f(x)}=\lim_{x \to x_0^{+1}} {f(x)}=A$。</li><li>函数在某一点极限存在不一定需要函数在该点有定义。对于$\lim_{x \to x_0} {f(x)}$，其定义为函数需要在$x_0$的去心邻域内有定义，所以函数在$x_0$处可以没有定义，但极限依然可以存在。</li><li>函数的极限$\lim_{x \to \infty}{f(x)}$的极限需要考虑两个情况，因为$x\rightarrow\infty$中并没有指明$x\rightarrow+\infty$还是$x\rightarrow-\infty$，所以两个情况都需要考虑。特别的，遇到$\lim_{x \to \infty} {e^x}$以及$\lim_{x \to \infty} {arctan(x)}$需要特别考虑。</li></ul><h2 id="第一章-函数与数列极限的性质"><a href="#第一章-函数与数列极限的性质" class="headerlink" title="第一章 函数与数列极限的性质"></a>第一章 函数与数列极限的性质</h2><ul><li>有界性<ul><li>数列如果收敛（极限存在的另一种说法），那么数列一定有界（定义证明）；但是函数有界不一定收敛（举反例$\lim_{x \to +\infty}{sinx}$）。</li></ul></li><li>保号性<ul><li>注意保号性里面数列极限如果$&gt;0$，可以推出数列从某个点开始的无穷多项也$&gt;0$；但是如果数列从某个点开始的极限$&gt;0$，只能推出数列的极限$\geqslant0$。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数理知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识梳理 </tag>
            
            <tag> 考研数学 </tag>
            
            <tag> 高等数学 </tag>
            
            <tag> 极限连续函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维笔记10</title>
      <link href="2020/04/23/yun-wei-bi-ji-10/"/>
      <url>2020/04/23/yun-wei-bi-ji-10/</url>
      
        <content type="html"><![CDATA[<h1 id="运维笔记9"><a href="#运维笔记9" class="headerlink" title="运维笔记9"></a>运维笔记9</h1><h2 id="命令行历史"><a href="#命令行历史" class="headerlink" title="命令行历史"></a>命令行历史</h2><ul><li>保存你输入的命令历史。可以用它来重复执行命令。</li><li>登录shell时，会读取历史文件中记录下的命令<code>~/.bash_history</code>。</li><li>登录进入shell后新执行的命令只会记录在缓存中；这些命令会在用户退出之后追加到命令历史文件<code>~/.bash_history</code>中。</li></ul><h2 id="命令行历史回溯命令与快捷键"><a href="#命令行历史回溯命令与快捷键" class="headerlink" title="命令行历史回溯命令与快捷键"></a>命令行历史回溯命令与快捷键</h2><ul><li><p>重复之前一个命令，有四种办法</p><ul><li>重复前一个命令使用上下方向键。</li><li>按<code>!!</code>并回车执行</li><li>输入<code>!-1</code>并回车执行</li><li>按<code>Ctrl+p</code>并回车执行。</li></ul></li><li><p><code>!:0</code>执行前一条命令（去除参数）</p></li><li><p><code>Ctrl+n</code>显示当前历史中的下一条命令，但不执行</p></li><li><p><code>Ctrl+j</code>执行当前命令</p></li><li><p><code>Ctrl+r</code>来在命令历史中搜索命令</p></li><li><p><code>Ctrl+g</code>从历史搜索模式退出</p></li><li><p><code>!n</code>执行<code>history</code>命令输出对应序号n的命令</p></li><li><p><code>!-n</code>执行history历史中倒数第n个命令</p></li></ul><h2 id="命令行历史的高级功能"><a href="#命令行历史的高级功能" class="headerlink" title="命令行历史的高级功能"></a>命令行历史的高级功能</h2><ul><li><code>!string</code>重复前一个以<code>string</code>开头的命令</li><li><code>!?string</code>重复前一个包含<code>string</code>的命令</li><li><code>!string:p</code>仅打印命令历史，而不执行</li><li><code>!$:p</code>打印输出<code>!$</code>（上一条命令的最后一个参数）的内容</li><li><code>!*:p</code>打印输出<code>!*</code>（上一条命令的所有参数）的内容</li><li><code>^string</code>删除上一条命令中的第一个<code>string</code></li><li><code>^string1^string2</code>将上一条命令中的第一个<code>string1</code>更换为<code>string2</code></li><li><code>!:gs/string1/string2</code>将上一条命令中所有的<code>string1</code>都替换为<code>string2</code></li><li>要重新调用前一个命令中最后一个参数<ul><li><code>!$</code>表示前一个命令中的最后一个参数</li><li><code>Esc+.</code>（点击<code>Esc</code>键后松开，然后点击<code>.</code>键）</li><li><code>Alt+.</code>（按住Alt键的同时点击<code>.</code>键）</li></ul></li></ul><h2 id="调用历史参数"><a href="#调用历史参数" class="headerlink" title="调用历史参数"></a>调用历史参数</h2><ul><li><code>command !^</code> 利用上一个命令的第一个参数做<code>command</code>的参数</li><li><code>command !$</code> 利用上一个命令的最后一个参数做<code>command</code>的参数</li><li><code>command !*</code> 利用上一个命令的全部参数做<code>command</code>的参数</li><li><code>command !:n</code> 利用上一个命令的第n个参数做<code>command</code>的参数</li><li><code>command !n:^</code> 调用第<code>n</code>条命令的第一个参数</li><li><code>command !n:$</code> 调用第<code>n</code>条命令的最后一个参数</li><li><code>command !n:m</code> 调用第<code>n</code>条命令的第<code>m</code>个参数</li><li><code>command !n:*</code> 调用第<code>n</code>条命令的所有参数</li></ul><h2 id="命令history"><a href="#命令history" class="headerlink" title="命令history"></a>命令<code>history</code></h2><ul><li><code>history [-c] [-d offset] [n]</code></li><li><code>history -anrw [filename]</code></li><li><code>history -ps arg [arg...]</code><ul><li><code>-c</code>: 清空命令历史</li><li><code>-d offset</code>: 删除历史中指定的第offset个命令</li><li><code>n</code>: 显示最近的n条历史</li><li><code>-a</code>: 追加本次会话新执行的命令历史列表至历史文件</li><li><code>-r</code>: 读历史文件附加到历史列表</li><li><code>-w</code>: 保存历史列表到指定的历史文件</li><li><code>-n</code>: 读历史文件中未读过的行到历史列表</li><li><code>-p</code>: 展开历史参数成多行，但不存在历史列表中</li><li><code>-s</code>: 展开历史参数成一行，附加在历史列表后</li></ul></li></ul><h2 id="命令历史相关环境变量"><a href="#命令历史相关环境变量" class="headerlink" title="命令历史相关环境变量"></a>命令历史相关环境变量</h2><ul><li><p><code>HISTSIZE</code>：命令历史记录的条数</p></li><li><p><code>HISTFILE</code>：指定历史文件，默认为<code>~/.bash_history</code></p></li><li><p><code>HISTFILESIZE</code>：命令历史文件记录历史的条数</p></li><li><p><code>HISTTIMEFORMAT = &quot;%F %T&quot;</code>：显示时间</p></li><li><p><code>HISTIGNORE = &quot;str1:str2*...&quot;</code>：忽略str1命令，str2开头的历史</p></li><li><p>控制命令历史的记录方式：</p><p>环境变量：<code>HISTCONTROL</code></p><ul><li><code>ignoredups</code>：默认，忽略重复的命令，连续且相同为“重复”</li><li><code>ignorespace</code>：忽略所有以空白开头的命令</li><li><code>ignoreboth</code>：相当于<code>ignoredups</code>，<code>ignorespace</code>的组合</li><li><code>erasedups</code>：删除重复命令</li></ul></li><li><p><code>export</code> 变量名 = “值”</p></li><li><p>存放在<code>/etc/profile</code>或<code>~/.bash_profile</code></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维笔记9</title>
      <link href="2020/04/21/yun-wei-bi-ji-9/"/>
      <url>2020/04/21/yun-wei-bi-ji-9/</url>
      
        <content type="html"><![CDATA[<h1 id="运维笔记9"><a href="#运维笔记9" class="headerlink" title="运维笔记9"></a>运维笔记9</h1><h2 id="日期与时间"><a href="#日期与时间" class="headerlink" title="日期与时间"></a>日期与时间</h2><ul><li><p>Linux的两种时钟</p><ol><li>系统时钟：由Linux内核通过CPU的工作频率计时</li><li>硬件时钟：主板</li></ol></li><li><p>相关命令</p><ol><li><p><code>date</code> 显示和设置系统时间</p><ul><li><code>date +%s</code></li><li><code>date -d @1509536033</code></li></ul></li><li><p><code>hwclock</code>, <code>clock</code>：显示硬件时钟</p><ul><li><code>-s</code>, <code>--hctosys</code>以硬件时钟为准，校正系统时钟</li><li><code>-w</code>, <code>--systohc</code> 以系统时钟为准， 校正硬件时钟</li></ul></li></ol></li><li><p>时区</p><p>  打开配置文件<code>/etc/localtime</code>，修改内容</p></li><li><p>显示日历</p><p>  使用命令<code>cal -y</code></p></li></ul><h2 id="开机重启命令"><a href="#开机重启命令" class="headerlink" title="开机重启命令"></a>开机重启命令</h2><ul><li><p>关机</p><ol><li><code>halt</code>，表示关机不断电</li><li><code>poweroff</code>，表示关机并断电</li></ol></li><li><p>重启</p><p>  <code>reboot</code>命令可以重启计算机，<code>-f</code>命令表示强制重启，不调用<code>shutdown</code>；<code>-p</code>命令表示切断电源</p></li><li><p>关机或重启</p><p>  <code>shutdown</code>命令可以在不同的配置下完成重启和关机工作</p><pre><code>- `-r`，表示重新启动- `-h`，表示关机- `-c`，表示取消</code></pre></li></ul><h2 id="用户登录信息查看命令"><a href="#用户登录信息查看命令" class="headerlink" title="用户登录信息查看命令"></a>用户登录信息查看命令</h2><ul><li><code>whoami</code>，显示当前登录的有效用户</li><li><code>who</code>，显示系统当前所有的登录回话</li><li><code>w</code>，显示系统当前所有的登录回话以及所做的操作</li></ul><h2 id="screen投屏命令的操作"><a href="#screen投屏命令的操作" class="headerlink" title="screen投屏命令的操作"></a><code>screen</code>投屏命令的操作</h2><ul><li><p>创建新的screen会话</p><p>  使用命令，<code>screen –S [SESSION]</code></p></li><li><p>加入已有的screen会话</p><p>  使用命令，<code>screen –x [SESSION]</code></p></li><li><p>退出并关闭screen会话</p><p>  使用命令，<code>exit</code></p></li><li><p>剥离当前screen会话</p><p>  使用快捷键，<code>CTRL+a,d</code></p></li><li><p>显示所有已经打开的<code>screen</code>会话</p><p>  使用命令，<code>screen -ls</code></p></li><li><p>恢复某<code>screen</code>会话</p><p>  使用命令，<code>screen -r [SESSION]</code></p></li></ul><h2 id="echo命令使用的解释"><a href="#echo命令使用的解释" class="headerlink" title="echo命令使用的解释"></a><code>echo</code>命令使用的解释</h2><ul><li><p>语法，<code>echo [-neE][字符串]</code></p></li><li><p>说明：echo会将输入的字符串送往标准输出。输出的字符以空白字符隔开，并在最后加上换行符</p></li><li><p>选项</p><ul><li><code>-E</code>（默认）不支持转义字符<code>\</code>功能</li><li><code>-n</code>不自动换行</li><li><code>-e</code>启用转义字符<code>\</code>功能</li></ul></li><li><p>显示变量</p><ul><li><code>echo &quot;$VAR_NAME&quot;</code>，使用双引号时，变量会替换，弱引用，即变量没有办法被识别</li><li><code>echo &#39;$VAR_NAME&#39;</code>，使用单引号时，变量不会替换，强引用，即变量可以被识别</li></ul></li></ul><h2 id="命令行扩展、被括起来的集合"><a href="#命令行扩展、被括起来的集合" class="headerlink" title="命令行扩展、被括起来的集合"></a>命令行扩展、被括起来的集合</h2><ul><li><p>命令行扩展：<code>$()</code>或<code>``</code></p><ul><li><p>把一个命令的输出打印给另一个命令的参数（有点类似重定向或者管道）</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">"This system's name is <span class="token variable"><span class="token variable">$(</span><span class="token function">hostname</span><span class="token variable">)</span></span>"</span>This system's name is server1.example.com<span class="token keyword">echo</span> <span class="token string">"i am <span class="token variable"><span class="token variable">`</span><span class="token function">whoami</span><span class="token variable">`</span></span> "</span>i am root</code></pre></li></ul></li><li><p>符号扩展；<code>&#123;&#125;</code></p><ul><li><p>打印重复字符串的简化形式</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token function">file</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;1,3,5&amp;#125; #结果为： file1 file3 file5</span><span class="token function">rm</span> -f <span class="token function">file</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;1,3,5&amp;#125;</span><span class="token keyword">echo</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;1..10&amp;#125;</span><span class="token keyword">echo</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;a..z&amp;#125;</span><span class="token keyword">echo</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;000..20..2&amp;#125;</span></code></pre></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维笔记8</title>
      <link href="2020/04/18/yun-wei-bi-ji-8/"/>
      <url>2020/04/18/yun-wei-bi-ji-8/</url>
      
        <content type="html"><![CDATA[<h1 id="运维笔记8"><a href="#运维笔记8" class="headerlink" title="运维笔记8"></a>运维笔记8</h1><h2 id="Shell命令的种类"><a href="#Shell命令的种类" class="headerlink" title="Shell命令的种类"></a><code>Shell</code>命令的种类</h2><ul><li><p>外部命令</p><p>  可以利用<code>type</code>命令来查看命令是否为内部命令，外部命令储存在磁盘上，载入需要比较长的时间。</p></li><li><p>内部命令</p><p>  <code>enable</code>命令可以用来查看内部命令，内部命令在系统上电之后就被自动载入内存，所以执行速度快。</p></li></ul><h2 id="命令的格式"><a href="#命令的格式" class="headerlink" title="命令的格式"></a>命令的格式</h2><ul><li><p><code>COMMAND [OPTIONS...] [ARGUMENTS...]</code></p><ol><li><p>选项：用于启用或关闭命令的某个或某些功能。</p><ul><li>短选项：<code>-c</code> 例如：<code>-l</code>，<code>-h</code></li><li>长选项：<code>--word</code> 例如：<code>--all</code>，<code>--human-readable</code></li></ul></li><li><p>参数：命令的作用对象，比如文件名用户名等</p></li></ol></li><li><p>注意</p><ol><li>多个选项以及多参数和命令之间使用空白字符分割</li><li>取消和结束命令执行：<code>Ctrl+c</code>，<code>Ctrl+d</code></li><li>多个命令可以使用<code>;</code>号隔开</li><li>一个命令可以用<code>\</code>分成多行</li></ol></li></ul><h2 id="管理内部命令的办法"><a href="#管理内部命令的办法" class="headerlink" title="管理内部命令的办法"></a>管理内部命令的办法</h2><ul><li><code>enable</code>命令可以用来管理内部命令。</li><li><code>enable -n [command]</code>命令可以用来禁用该命令。</li><li><code>enable [command]</code>命令可以用来恢复命令，是命令使能。</li><li><code>enable -n</code>可以用来查看所有被禁用的命令。</li></ul><h2 id="系统执行命令的过程（按照如下顺序执行）"><a href="#系统执行命令的过程（按照如下顺序执行）" class="headerlink" title="系统执行命令的过程（按照如下顺序执行）"></a>系统执行命令的过程（按照如下顺序执行）</h2><ol><li><p>检查别名<code>alias</code>内部是否有和输入命令相同的命令，有的话使用该命令。否则进行下一步。</p><ul><li><p><code>alias [name]=[&quot;command&quot;]</code>可以用来定义命令的别名<code>alias</code>。使用这种方法定义别名<code>alias</code>仅仅是暂时性的，如果重新登录或者重启系统，该别名会失效，如果想要使别名<code>alias</code>永久有效，需要使用下面的操作。</p></li><li><p>如果想要使别名<code>alias</code>永久性生效，需要将别名写入<code>/etc/.bashrc</code>文件中，这个会设置所有用户的别名，如果仅仅想要设置特定用户的别名，需要在该用户的家目录下寻找<code>.bashrc</code>文件，将别名写入该文件。</p></li><li><p>如果要使得这个文件的修改立刻生效，有如下几种方法</p><ol><li>重启终端或者重启系统。</li><li>使用<code>source .bashrc</code>或<code>. .bashrc</code>命令可以使得配置文件生效。其中<code>source</code>命令与<code>.</code>命令等价。</li></ol></li><li><p>使用<code>unalias</code>命令可以删除别名。</p></li><li><p>使用<code>\[aliasname]</code>可以忽略别名。</p></li></ul></li><li><p>判断命令是否为内部命令，否则执行下一步。</p></li><li><p>判断hash表里是否有该命令，有的话按照hash表找到命令所在位置，执行命令，否则进行下一步。</p><ul><li>使用<code>hash</code>命令可以查看命令的缓存情况，并可以查看命令的命中次数，即缓存的命中率，利用了存储器的局部性原理。</li><li>使用<code>hash -d [command]</code>命令可以删除hash表里面的命令。</li><li>使用<code>hash -r</code>命令可以删除hash表中所有的命令。</li><li>hash表中记录了外部命令所在的路径。</li></ul></li><li><p>判断是否命令存储在外存中，否则执行下一步。其中<code>$PATH</code>记录了命令在外存中的位置。</p></li><li><p>发送命令找不到提示。</p></li></ol><h2 id="命令的等待、命令的终止与单行多命令的写法"><a href="#命令的等待、命令的终止与单行多命令的写法" class="headerlink" title="命令的等待、命令的终止与单行多命令的写法"></a>命令的等待、命令的终止与单行多命令的写法</h2><ul><li><p>多命令写在单行内</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>command1<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">[</span>command2<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">[</span>command3<span class="token punctuation">]</span></code></pre></li><li><p>命令终止</p><p>  可以使用快捷键<code>ctrl + c</code>或者<code>ctrl + d</code>。</p></li><li><p>命令的等待</p><p>  可以使用<code>sleep [n]</code>命令来等待，<code>n</code>表示等待的时间，以秒为单位。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维笔记7</title>
      <link href="2020/04/14/yun-wei-bi-ji-7/"/>
      <url>2020/04/14/yun-wei-bi-ji-7/</url>
      
        <content type="html"><![CDATA[<h1 id="运维笔记7"><a href="#运维笔记7" class="headerlink" title="运维笔记7"></a>运维笔记7</h1><h2 id="操作系统与配置信息查看相关命令"><a href="#操作系统与配置信息查看相关命令" class="headerlink" title="操作系统与配置信息查看相关命令"></a>操作系统与配置信息查看相关命令</h2><ul><li><p>查看当前系统版本</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> /etc/centos-release</code></pre></li><li><p>查看当前系统内核版本命令</p><pre class=" language-bash"><code class="language-bash"><span class="token function">uname</span> -r</code></pre></li><li><p>查看各项电脑硬件信息</p><ol><li><p>查看CPU信息</p><pre class=" language-bash"><code class="language-bash">lscpu</code></pre></li><li><p>查看内存信息</p><pre class=" language-bash"><code class="language-bash"><span class="token function">free</span> -h<span class="token function">cat</span> /proc/meminfo</code></pre></li><li><p>查看硬盘信息</p><pre class=" language-bash"><code class="language-bash">lsblk</code></pre></li><li><p>查看网卡信息</p><pre class=" language-bash"><code class="language-bash">mii-tool <span class="token punctuation">[</span>接口名<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#mii-tool ens33 or mii-tool eth0</span></code></pre></li></ol></li><li><p>查看用户信息</p><pre class=" language-bash"><code class="language-bash"><span class="token function">who</span> <span class="token comment" spellcheck="true">#查看所有用户信息</span><span class="token function">who</span> am i <span class="token comment" spellcheck="true">#查看当前登录的用户信息</span></code></pre></li><li><p>查询当前使用的shell类型</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token variable">$SHELL</span></code></pre></li></ul><h2 id="常用系统设置"><a href="#常用系统设置" class="headerlink" title="常用系统设置"></a>常用系统设置</h2><ul><li><p>设置网络开机自动连接</p><pre class=" language-bash"><code class="language-bash">nmcli connection modify ens33 connection.autoconnection <span class="token function">yes</span></code></pre></li><li><p>更改并查看ip信息</p><pre class=" language-bash"><code class="language-bash">vim /etc/sysconfig/network-scripts/ifcfg-eth0 <span class="token comment" spellcheck="true">#打开网卡设置文件后更改内部信息即可</span><span class="token function">service</span> network restart <span class="token comment" spellcheck="true">#重启网络服务</span></code></pre></li><li><p>设置motd文件，更改登录初始界面</p><pre class=" language-bash"><code class="language-bash">vim /etc/motd</code></pre><pre class=" language-bash"><code class="language-bash">                   _ooOoo_                  o8888888o                  88<span class="token string">" . "</span>88                  <span class="token punctuation">(</span><span class="token operator">|</span> -_- <span class="token operator">|</span><span class="token punctuation">)</span>                  O\  <span class="token operator">=</span>  /O               ____/`---<span class="token string">'\____             .'</span>  \\<span class="token operator">|</span>     <span class="token operator">|</span>//  `.            /  \\<span class="token operator">||</span><span class="token operator">|</span>  <span class="token keyword">:</span>  <span class="token operator">||</span><span class="token operator">|</span>//  \           /  _<span class="token operator">||</span><span class="token operator">||</span><span class="token operator">|</span> -:- <span class="token operator">||</span><span class="token operator">||</span><span class="token operator">|</span>-  \           <span class="token operator">|</span>   <span class="token operator">|</span> \\\  -  /// <span class="token operator">|</span>   <span class="token operator">|</span>           <span class="token operator">|</span> \_<span class="token operator">|</span>  <span class="token string">''</span>\---/<span class="token string">''</span>  <span class="token operator">|</span>   <span class="token operator">|</span>           \  .-\__  <span class="token variable"><span class="token variable">`</span>-<span class="token variable">`</span></span>  ___/-. /         ___`. <span class="token keyword">.</span><span class="token string">'  /--.--\  `. . __      ."" '</span><span class="token operator">&lt;</span>  `.___\_<span class="token operator">&lt;</span><span class="token operator">|</span><span class="token operator">></span>_/___.<span class="token string">'  >'</span><span class="token string">""</span><span class="token keyword">.</span>     <span class="token operator">|</span> <span class="token operator">|</span> <span class="token keyword">:</span>  <span class="token variable"><span class="token variable">`</span>- \<span class="token variable">`</span></span><span class="token keyword">.</span><span class="token punctuation">;</span><span class="token variable"><span class="token variable">`</span>\ _ /<span class="token variable">`</span></span><span class="token punctuation">;</span><span class="token keyword">.</span><span class="token variable"><span class="token variable">`</span>/ - <span class="token variable">`</span></span> <span class="token keyword">:</span> <span class="token operator">|</span> <span class="token operator">|</span>     \  \ <span class="token variable"><span class="token variable">`</span>-.   \_ __\ /__ _/   .-<span class="token variable">`</span></span> /  /<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token variable"><span class="token variable">`</span>-.____<span class="token variable">`</span></span>-.___\_____/___.-`____.-<span class="token string">'======                   `=---='</span></code></pre></li></ul><pre><code>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^           佛祖保佑       永不死机           心外无法       法外无心```</code></pre><ul><li><p>设置提示符样式和颜色</p><ul><li><p>更改<code>PS1</code>变量内容</p><pre class=" language-bash"><code class="language-bash">PS1<span class="token operator">=</span><span class="token string">"\[\e[1;5;41;33m\][\u@\h \W]\\$\[\e[0m\]"</span></code></pre></li><li><p><code>PS1</code>变量含义</p><pre class=" language-bash"><code class="language-bash">\e \033            \u 当前用户名\h 主机名简称       \H 主机名\w 当前工作目录     \W 当前工作目录名\t 24小时时间格式   \T 12小时时间格式\<span class="token operator">!</span> 命令历史数       \# 开机后的命令历史数</code></pre></li></ul></li><li><p>设置系统开机自动登录功能</p><ol><li><p>打开<code>GDM</code>配置文件</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> gedit /etc/gdm/custom.conf</code></pre></li><li><p>增加如下条目</p><pre class=" language-bash"><code class="language-bash">AutomaticLoginEnable<span class="token operator">=</span>trueAutomaticLogin<span class="token operator">=</span>add_your_username_here</code></pre></li><li><p>重启系统</p></li></ol></li><li><p>关闭防火墙</p><ol><li><p>在CentOS7上执行如下命令可以关闭防火墙</p><pre class=" language-bash"><code class="language-bash">systemctl stop firewalld <span class="token comment" spellcheck="true">#关闭服务</span>systemctl disable firewalld <span class="token comment" spellcheck="true">#设置开机不启动</span></code></pre></li><li><p>在CentOS6上执行如下命令可以关闭防火墙</p><pre class=" language-bash"><code class="language-bash"><span class="token function">service</span> iptables stop <span class="token comment" spellcheck="true">#关闭服务</span><span class="token function">chkconfig</span> iptables off <span class="token comment" spellcheck="true">#设置开机不启动</span></code></pre></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维笔记6</title>
      <link href="2020/04/14/yun-wei-bi-ji-6/"/>
      <url>2020/04/14/yun-wei-bi-ji-6/</url>
      
        <content type="html"><![CDATA[<h1 id="运维笔记6"><a href="#运维笔记6" class="headerlink" title="运维笔记6"></a>运维笔记6</h1><h2 id="终端（terminal）的分类"><a href="#终端（terminal）的分类" class="headerlink" title="终端（terminal）的分类"></a>终端（terminal）的分类</h2><ul><li><p>设备终端（terminal）</p><p>  鼠标、键盘、显示器</p></li><li><p>物理终端（/dev/console）</p><p>  控制台（console）</p></li><li><p>虚拟终端（tty：teletypewriters，/dev/tty# #为1~6）</p><p>  tty可以有多个，可以使用快捷键<code>ctrl + alt + f[1-6]</code>来切换终端。</p></li><li><p>图形终端（/dev/tty7）</p><ul><li>图形终端可以通过<code>startx</code>命令启用，使用这个命令启动的图形终端实际上并没有新建图形终端，而是启动了xwindows的软件。</li><li>在CentOS6中新建图形终端可以使用快捷键<code>ctrl + alt + f7</code>来启动图形终端。</li><li>在CentOS7中，图形终端在哪个虚拟终端启动，就位于哪个虚拟终端。</li></ul></li><li><p>串行终端（/dev/ttys#）</p><ul><li>ttys</li></ul></li><li><p>伪终端（pty：pseudo-tty，/dev/pts/#）</p><ul><li>图形终端</li></ul></li><li><p>查看当前图形设备命令</p><ul><li>使用命令<code>tty</code>便可以查看当前的终端设备。</li></ul></li><li><p>切换终端命令</p><ul><li>使用命令<code>chvt</code>可以切换终端。</li></ul></li></ul><h2 id="交互式接口"><a href="#交互式接口" class="headerlink" title="交互式接口"></a>交互式接口</h2><ul><li><p>GUI：Graphic User Interface 基于X协议</p><ul><li>X protocol，Window Manager，Desktop。Desktop：GNOME，KDE，XFCE（图形库，gtk，qt）</li></ul></li><li><p>CLI：Command Line Interface</p><ul><li>Shell程序：sh、csh、tcsh、ksh、bash、zsh</li></ul></li></ul><h2 id="系统的7个运行级别（runlevel）"><a href="#系统的7个运行级别（runlevel）" class="headerlink" title="系统的7个运行级别（runlevel）"></a>系统的7个运行级别（runlevel）</h2><ul><li><p>运行级别0</p><ul><li>系统停机状态，系统默认运行级别不能设为0，否则不能正常启动。</li></ul></li><li><p>运行级别1</p><ul><li>单用户工作状态，root权限，用于系统维护，禁止远程登录。</li></ul></li><li><p>运行级别2</p><ul><li>多用户状态(没有NFS)。</li></ul></li><li><p>运行级别3</p><ul><li>完全的多用户状态(有NFS)，登陆后进入控制台命令行模式。</li></ul></li><li><p>运行级别4</p><ul><li>系统未使用，保留。</li></ul></li><li><p>运行级别5</p><ul><li>X11控制台，登陆后进入图形GUI模式。</li></ul></li><li><p>运行级别6</p><ul><li>系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动。</li></ul></li><li><p>运行级别的切换</p><ul><li><p>使用如下命令可以切换。</p><pre class=" language-bash"><code class="language-bash">init n <span class="token comment" spellcheck="true">#init 3切换字符终端，init 5切换图形终端。</span></code></pre></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维笔记5</title>
      <link href="2020/04/13/yun-wei-bi-ji-5/"/>
      <url>2020/04/13/yun-wei-bi-ji-5/</url>
      
        <content type="html"><![CDATA[<h1 id="运维笔记5"><a href="#运维笔记5" class="headerlink" title="运维笔记5"></a>运维笔记5</h1><h2 id="设置Linux系统本地时间，使用ntp服务器设置"><a href="#设置Linux系统本地时间，使用ntp服务器设置" class="headerlink" title="设置Linux系统本地时间，使用ntp服务器设置"></a>设置Linux系统本地时间，使用ntp服务器设置</h2><ul><li><p>使用ntp服务器设置可以精确设置时间，并且在时区设置正确地情况下，保证时间的正确性。</p></li><li><p>使用ntp服务器设置系统时间需要使用如下命令。</p><pre class=" language-bash"><code class="language-bash">ntpdate <span class="token punctuation">[</span>serverIP<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#ntpdate 130.88.202.49 this server is in UK</span></code></pre></li><li><p><code>ntpdate</code>命令仅仅是更新了系统时间（date），如果需要更新硬件时间（clock），还需要使用如下命令</p><pre class=" language-bash"><code class="language-bash">clock -w <span class="token comment" spellcheck="true">#this command could set hardware time using os time</span></code></pre></li><li><p>如果需要通过硬件时间来设置软件时间，则可以使用如下命令</p><pre class=" language-bash"><code class="language-bash">clock -s <span class="token comment" spellcheck="true">#this command could set os time using hardware time</span></code></pre></li><li><p>设置时区的方法</p><ul><li><p>使用如下命令可以查看时区设置</p><pre class=" language-bash"><code class="language-bash">timedatectl</code></pre></li><li><p>使用如下命令可以设置时区</p><pre class=" language-bash"><code class="language-bash">timedatectl set-timezone Europe/London</code></pre></li></ul></li></ul><h2 id="更改主机名（hostname）的方法"><a href="#更改主机名（hostname）的方法" class="headerlink" title="更改主机名（hostname）的方法"></a>更改主机名（hostname）的方法</h2><ul><li><p>在CentOS中可以永久性更改主机名（hostname），也可以非永久性更改主机名。</p><ol><li><p>非永久性更改主机名</p><ul><li><p>使用hostname命令来更改主机名（hostname），但是重新启动电脑之后会失效，命令如下。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">hostname</span> <span class="token punctuation">[</span>主机名<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#hostname CentOS7</span></code></pre></li></ul></li><li><p>永久性更改主机名</p><ul><li><p>在CentOS6和CentOS7中使用的方法是不同的。在CentOS6中，我们使用如下命令找到配置文件<code>network</code>，并用vim打开。</p><pre class=" language-bash"><code class="language-bash">vim /etc/sysconfig/network</code></pre></li><li><p>打开文件之后，添加如下条目到文件中,即可永久性设置CentOS6主机名。</p><pre class=" language-bash"><code class="language-bash">HOSTNAME<span class="token operator">=</span><span class="token punctuation">[</span>hostname<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#HOSTNAME=centos6.localdomain</span></code></pre></li><li><p>在CentOS7中我们可以使用如下命令打开主机名设置文件。</p><pre class=" language-bash"><code class="language-bash">vim /etc/hostname</code></pre></li><li><p>在内部添加如下条目即可永久性设置CentOS7主机名。</p><pre class=" language-bash"><code class="language-bash">HOSTNAME<span class="token operator">=</span><span class="token punctuation">[</span>hostname<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#HOSTNAME=centos7.localdomain</span></code></pre></li></ul></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维笔记4</title>
      <link href="2020/04/13/yun-wei-bi-ji-4/"/>
      <url>2020/04/13/yun-wei-bi-ji-4/</url>
      
        <content type="html"><![CDATA[<h1 id="运维笔记4"><a href="#运维笔记4" class="headerlink" title="运维笔记4"></a>运维笔记4</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><ul><li>在使用SSH连接的时候，我发现登录等待提示输入密码的时间特别久，并且会出现一段时间之后掉线的情况，于是我上网搜索了如何解决这一问题，找到了解决方案，现在记录在这里。</li></ul><h2 id="如何解决PUTTY-secureCRT等SSH软件连接虚拟机一段时间之后掉线的问题"><a href="#如何解决PUTTY-secureCRT等SSH软件连接虚拟机一段时间之后掉线的问题" class="headerlink" title="如何解决PUTTY,secureCRT等SSH软件连接虚拟机一段时间之后掉线的问题"></a>如何解决PUTTY,secureCRT等SSH软件连接虚拟机一段时间之后掉线的问题</h2><ul><li>在使用虚拟机的时候，点击编辑-&gt;虚拟网络编辑器-&gt;更改设置-&gt;仅主机模式-&gt;DHCP设置里，修改默认租用时间，可以任意修改，这个可以解决虚拟机SSH连接情况下，一段时间后掉线的问题。</li></ul><h2 id="如何解决PUTTY-secureCRT等SSH软件连接虚拟机卡顿的现象。"><a href="#如何解决PUTTY-secureCRT等SSH软件连接虚拟机卡顿的现象。" class="headerlink" title="如何解决PUTTY,secureCRT等SSH软件连接虚拟机卡顿的现象。"></a>如何解决PUTTY,secureCRT等SSH软件连接虚拟机卡顿的现象。</h2><ul><li>修改配置文件设置，配置文件路径为<code>/etc/ssh/sshd_config</code>,修改内部两条内容如下，即可解决该问题。</li></ul><pre class=" language-bash"><code class="language-bash">GSSAPIAuthentication noUseDNS no</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维常用命令大集合</title>
      <link href="2020/04/13/yun-wei-chang-yong-ming-ling-da-ji-he/"/>
      <url>2020/04/13/yun-wei-chang-yong-ming-ling-da-ji-he/</url>
      
        <content type="html"><![CDATA[<h1 id="运维常用命令大集合"><a href="#运维常用命令大集合" class="headerlink" title="运维常用命令大集合"></a>运维常用命令大集合</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>在学习CentOS运维技术的时候，每次学习都会遇到特别多的命令，为了方便后期记忆学习，将这些命令整理在这里。</p><h2 id="命令集合"><a href="#命令集合" class="headerlink" title="命令集合"></a>命令集合</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">alias</span> <span class="token comment" spellcheck="true">#别名设置</span>authconfig<span class="token function">basename</span> <span class="token comment" spellcheck="true">#基名</span><span class="token function">cat</span> /etc/centos-release <span class="token comment" spellcheck="true">#print centos version info</span><span class="token function">cal</span> <span class="token comment" spellcheck="true">#print calendar</span><span class="token function">cd</span>  <span class="token comment" spellcheck="true">#change dir</span>chagechfnchshchpasswdclock <span class="token comment" spellcheck="true">#print hardware clock</span><span class="token function">cp</span> <span class="token comment" spellcheck="true">#copy command</span><span class="token function">clear</span> ctrl+L <span class="token comment" spellcheck="true">#clear session command</span><span class="token function">date</span> <span class="token comment" spellcheck="true">#print software clock</span><span class="token function">dd</span> <span class="token comment" spellcheck="true">#convert and copy file</span><span class="token function">dirname</span> <span class="token comment" spellcheck="true">#目录名</span><span class="token function">df</span> <span class="token comment" spellcheck="true">#reporting file system disk space usage</span><span class="token function">du</span> <span class="token comment" spellcheck="true">#estimated amount of disk space used by given files or directories</span><span class="token keyword">exit</span> <span class="token comment" spellcheck="true">#quit session or logout</span><span class="token function">enable</span> <span class="token comment" spellcheck="true">#enable builtin command</span><span class="token keyword">echo</span> <span class="token variable">$SHELL</span> <span class="token comment" spellcheck="true">#show which bash is used</span><span class="token function">file</span> <span class="token comment" spellcheck="true">#print file type analyze the file type</span>finger <span class="token comment" spellcheck="true">#查询个人信息</span>getent <span class="token comment" spellcheck="true">#查看条目 shadow passwd group gshadow</span>grpck<span class="token function">groupadd</span><span class="token function">groupmod</span><span class="token function">groupdel</span><span class="token function">groups</span>groupmemsgpasswdhalt <span class="token comment" spellcheck="true">#stop operating but without power off</span><span class="token function">hash</span> <span class="token comment" spellcheck="true">#check the command stored in cache and corresponding hit time</span><span class="token function">help</span> <span class="token comment" spellcheck="true">#literal meaning</span>hexdump <span class="token comment" spellcheck="true">#display  file contents in hexadecimal, decimal, octal, or ascii</span><span class="token function">history</span> <span class="token comment" spellcheck="true">#print command history</span><span class="token function">hostname</span> <span class="token comment" spellcheck="true">#print hostname if you want to change hostname you should do it in /etc/hostname(centos7) /etc/hostname(centos6)</span><span class="token function">iconv</span> <span class="token comment" spellcheck="true">#字符编码转换</span>info <span class="token comment" spellcheck="true">#find help info in this </span>init 3 5 0 6 <span class="token comment" spellcheck="true">#set runlevel</span><span class="token function">id</span> -u <span class="token comment" spellcheck="true">#print current user id</span><span class="token function">logout</span> ctrl+d <span class="token comment" spellcheck="true">#literal meaning</span>ll <span class="token comment" spellcheck="true">#ll == ls -l</span>lsblk <span class="token comment" spellcheck="true">#list info on block device</span><span class="token function">ls</span> <span class="token comment" spellcheck="true">#list file</span><span class="token function">lsof</span> <span class="token comment" spellcheck="true">#列出被进程打开的文件</span>lscpu <span class="token comment" spellcheck="true">#print cpu info</span>lsb_release -a <span class="token comment" spellcheck="true">#check os info (centos6)</span><span class="token function">ln</span> <span class="token comment" spellcheck="true">#构造硬链接</span><span class="token function">ln</span> -s <span class="token comment" spellcheck="true">#构造软链接</span>localectl  <span class="token comment" spellcheck="true">#设置显示字符集和语言</span><span class="token function">man</span> <span class="token comment" spellcheck="true">#find manual help</span>mandb <span class="token comment" spellcheck="true">#makewhatis 安装库</span>mii-tool <span class="token punctuation">[</span>interfacename<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#print info on interface eth0(centos6) ens33(centos7)</span>nmcli connection modify ens33 connection.autoconnect <span class="token function">yes</span> <span class="token comment" spellcheck="true">#set auto internet connect after booting</span><span class="token function">mv</span> <span class="token comment" spellcheck="true">#移动文件</span><span class="token function">nano</span> <span class="token comment" spellcheck="true">#file editor</span>newgrp <span class="token comment" spellcheck="true">#临时切换主组</span>newusers <span class="token comment" spellcheck="true">#批量创建用户 </span>ntpdate    <span class="token comment" spellcheck="true">#网络时间协议服务器ntp</span>poweroff <span class="token comment" spellcheck="true">#关机</span><span class="token function">ps</span> <span class="token comment" spellcheck="true">#show process</span><span class="token function">pwd</span> <span class="token comment" spellcheck="true">#print current working dir</span>pwck<span class="token function">reboot</span> <span class="token comment" spellcheck="true">#重启</span><span class="token function">rename</span> <span class="token comment" spellcheck="true">#重新命名文件</span>reset <span class="token comment" spellcheck="true">#重置当前窗口</span><span class="token function">rm</span> <span class="token comment" spellcheck="true">#删除文件</span><span class="token function">rmdir</span> <span class="token comment" spellcheck="true">#删除文件夹</span>runlevel <span class="token comment" spellcheck="true">#running mode</span>rpm -ivh <span class="token comment" spellcheck="true">#install software</span>rz <span class="token comment" spellcheck="true">#传输文件</span><span class="token function">screen</span> <span class="token comment" spellcheck="true">#投屏软件，需要安装 rpm -ivh [安装光盘挂载点]</span><span class="token function">shutdown</span> <span class="token comment" spellcheck="true">#关机</span><span class="token function">sleep</span> <span class="token comment" spellcheck="true">#等待 sleep [n] 等待n秒</span>startx <span class="token comment" spellcheck="true">#use GUI</span><span class="token function">stat</span> <span class="token comment" spellcheck="true">#可以看到文件的三个时间 ctime, atime, mtime</span>sosreport <span class="token comment" spellcheck="true">#红帽信息收集包</span>source<span class="token operator">==</span>. <span class="token comment" spellcheck="true">#make config. file take effect</span><span class="token function">su</span> <span class="token comment" spellcheck="true">#带-号完全切换，不带-号不完全切换</span>sz <span class="token function">file</span> <span class="token comment" spellcheck="true">#传输文件</span>tree <span class="token comment" spellcheck="true">#树型显示目录内容</span><span class="token function">type</span> <span class="token comment" spellcheck="true">#show command type</span><span class="token function">tty</span> <span class="token comment" spellcheck="true">#session</span>timedatectl <span class="token comment" spellcheck="true">#print system time info</span><span class="token function">touch</span> <span class="token comment" spellcheck="true">#create file</span><span class="token function">unalias</span> <span class="token comment" spellcheck="true">#cancel alias</span><span class="token function">uname</span> -r <span class="token comment" spellcheck="true">#print kernel info</span><span class="token function">useradd</span><span class="token function">usermod</span><span class="token function">userdel</span>vipwvigr<span class="token keyword">.</span> .bashrc <span class="token comment" spellcheck="true">#make .bashrc file take effect</span>w <span class="token comment" spellcheck="true">#print terminal and user info</span><span class="token function">which</span> <span class="token comment" spellcheck="true">#show the full path of command</span><span class="token function">whereis</span> <span class="token comment" spellcheck="true">#locate the binary, source, and manual page files for a command</span><span class="token function">who</span> <span class="token comment" spellcheck="true">#show who is log on</span><span class="token function">whoami</span> <span class="token comment" spellcheck="true">#print effective userid</span>whatis <span class="token comment" spellcheck="true">#查看帮助</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">#可以分割多条命令，在一行内执行多条命令</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维笔记3</title>
      <link href="2020/04/12/yun-wei-bi-ji-3/"/>
      <url>2020/04/12/yun-wei-bi-ji-3/</url>
      
        <content type="html"><![CDATA[<h1 id="运维笔记3（Linux系统安装）"><a href="#运维笔记3（Linux系统安装）" class="headerlink" title="运维笔记3（Linux系统安装）"></a>运维笔记3（Linux系统安装）</h1><h2 id="Linux系统与Windows系统的区别"><a href="#Linux系统与Windows系统的区别" class="headerlink" title="Linux系统与Windows系统的区别"></a>Linux系统与Windows系统的区别</h2><ul><li>Windows系统中磁盘分区用盘符，Linux使用目录名。</li><li>Windows中的硬盘资源被认为是各自独立的。</li><li>Windows中的根目录用反斜线<code>\</code>表示，而Linux中用正斜线<code>/</code>表示。</li><li>Windows中有多少个盘符就多少个根目录，Linux中只有一个根目录。</li><li>Linux中挂载的概念是指将设备分配一个目录名。</li></ul><h2 id="Linux目录含义"><a href="#Linux目录含义" class="headerlink" title="Linux目录含义"></a>Linux目录含义</h2><ul><li><code>/usr</code>目录中存放了大量的系统文件。</li><li><code>/home</code>目录中存放了用户的信息。</li><li><code>/boot</code>目录用来存放启动文件。</li><li><code>/tmp</code>目录用来存放临时文件。</li><li><code>/var/log</code>用来存放日志。</li><li><code>/dev</code>目录中存放了各种硬件信息。</li><li><code>/dev/sda or /sdb or ...</code>表示磁盘的分区。</li></ul><h2 id="Linux分区概述"><a href="#Linux分区概述" class="headerlink" title="Linux分区概述"></a>Linux分区概述</h2><ul><li>分区策略：MBR策略，GPT策略。</li><li>分区的分类：主分区（1–4），扩展分区，逻辑分区。</li><li>主分区：一个硬盘上最多只能有4个主分区，主分区是最小的单位，不可以进行分割，活动状态只能有一个。</li><li>扩展分区：最多一个，要划分成更小的逻辑分区 1–4。</li><li>逻辑分区：分区号从5开始</li><li>只有将分区挂载到文件夹之后才能使用。</li></ul><h2 id="Linux分区规划"><a href="#Linux分区规划" class="headerlink" title="Linux分区规划"></a>Linux分区规划</h2><ul><li><code>/boot</code>可以单独放一个分区，用来存放启动文件，一般大小设置为1G。</li><li><code>/</code>根分区，一般大小为50G。</li><li><code>/data</code>分区，专门设置为了学习用的分区，实际生产中可以不加入这个分区，这里设置为30G。</li><li><code>swap</code>分区，这里采用了虚拟内存技术，为了防止内存不足的情况发生，虚拟内存大小一般为实际内存的2倍左右。</li></ul><h2 id="VMWARE中网络适配器三种模式详解"><a href="#VMWARE中网络适配器三种模式详解" class="headerlink" title="VMWARE中网络适配器三种模式详解"></a>VMWARE中网络适配器三种模式详解</h2><ul><li>仅主机模式：虚拟机只能在电脑内部进行通信，即只和其他本地虚拟机和Windows主机相连。</li><li>NAT模式：虚拟机可以和外部机器通信，但外部机器无法与之相连。</li><li>桥接模式：可以正常访问外部网络。</li></ul><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol><li>下载相应的光盘文件，下载完成之后验证，使用<code>sha1sum</code>与云盘上的信息做对比，这是Linux特有的工具。</li><li>创建分区。设置标准分区，默认文件系统，并且按照之前的分区规划设置分区。</li><li>设置root用户名称密码。</li><li>按照提示进行接下来的操作即可。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维笔记2</title>
      <link href="2020/04/12/yun-wei-bi-ji-2/"/>
      <url>2020/04/12/yun-wei-bi-ji-2/</url>
      
        <content type="html"><![CDATA[<h1 id="运维笔记2（Linux服务器简介）"><a href="#运维笔记2（Linux服务器简介）" class="headerlink" title="运维笔记2（Linux服务器简介）"></a>运维笔记2（Linux服务器简介）</h1><h2 id="Linux的哲学思想"><a href="#Linux的哲学思想" class="headerlink" title="Linux的哲学思想"></a>Linux的哲学思想</h2><ul><li>一切都是文件</li><li>小型，单一用途的程序</li><li>链接程序，完成复杂任务</li><li>避免过多的令人困惑的图形界面</li><li>配置数据储存在文本中</li></ul><h2 id="Linux机器架构（自顶向下）"><a href="#Linux机器架构（自顶向下）" class="headerlink" title="Linux机器架构（自顶向下）"></a>Linux机器架构（自顶向下）</h2><hr><ul><li>APP（Userspace）</li><li>OS（Kernelspace）</li><li>虚拟层（Kernelspace）</li><li>硬件层</li></ul><hr><ul><li>虚拟化技术使得一个服务器可以搭载多个系统</li><li>应用软件如果需要访问硬件资源需要经过Kernel</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统笔记1（操作系统概述）</title>
      <link href="2020/04/10/cao-zuo-xi-tong-bi-ji-1/"/>
      <url>2020/04/10/cao-zuo-xi-tong-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统笔记1（操作系统概述）"><a href="#操作系统笔记1（操作系统概述）" class="headerlink" title="操作系统笔记1（操作系统概述）"></a>操作系统笔记1（操作系统概述）</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>操作系统作为计算机的应用程序和硬件沟通的接口，保证了计算机能够正常运行各种程序，并且保证了程序不会因为硬件的不同而要改变程序内部的代码。为了之后的学习，在这里再开一个新坑，用来记录学习操作系统的心得。</p><h2 id="操作系统概览"><a href="#操作系统概览" class="headerlink" title="操作系统概览"></a>操作系统概览</h2><ul><li>定义：用于管理计算机硬件和软件的软件。提供了用户与硬件交互的接口。</li><li>产生原因：不能直接操作计算机硬件，设备种类繁多复杂，为了统一接口，研制出来了操作系统，使得更多人可以使用计算机。</li><li>好处：用户无需面向硬件编程，即操作系统实现了对硬件资源的抽象。</li></ul><h2 id="操作系统的相关概念"><a href="#操作系统的相关概念" class="headerlink" title="操作系统的相关概念"></a>操作系统的相关概念</h2><ul><li><p>并发性 VS 并行性</p><ol><li>并行性：两个或多个事件可以在同一个时刻发生，即多道程序同时运行。</li><li>并发性：两个或多个事件可以在同一段时间段内发生，即多道程序交替运行。</li></ol></li><li><p>共享性<br>主存被多个程序同时使用，计算机中存在两种共享性。</p><ol><li>互斥共享<br>当资源被程序A使用时，其他程序想要使用只能等待。</li><li>同时访问<br>某一资源在同一段时间内可以被多个程序共享。</li></ol></li><li><p>虚拟性<br>把物理实体转化为多个逻辑实体，虚拟的技术主要由时分复用技术和空分复用技术。</p><ol><li><p>时分复用技术：资源在时间上进行复用，不同的程序并发使用。  </p><ul><li>虚拟处理器技术  <ol><li>借助多道程序设计技术（并发多线程技术）</li><li>为每一个程序建立进程。</li><li>多个程序分时复用处理器。  </li></ol></li><li>虚拟设备技术<ol><li>物理设备虚拟为为多个逻辑设备。</li><li>每个程序占用一个逻辑设备。</li><li>多个程序通过逻辑设备并发访问。</li></ol></li></ul></li><li><p>空分复用技术：资源在不同空间中被复用。</p><ul><li>虚拟磁盘技术<ol><li>物理磁盘虚拟为逻辑磁盘（CDE盘）</li></ol></li><li>虚拟内存技术<ol><li>在逻辑上扩大了储存容量。</li><li>使用比实际内存更大的容量。</li><li>大大提升了编程效率。</li></ol></li></ul></li></ol></li><li><p>异步性<br>  在多道程序的环境下，允许多个进程并发执行，进程在使用资源时可能需要等待或者放弃，会存在进程的不可预知性。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运维笔记1</title>
      <link href="2020/04/09/yun-wei-bi-ji-1/"/>
      <url>2020/04/09/yun-wei-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<h1 id="运维笔记1（计算机知识简介）"><a href="#运维笔记1（计算机知识简介）" class="headerlink" title="运维笔记1（计算机知识简介）"></a>运维笔记1（计算机知识简介）</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>我的名字是张博闻，这是我的运维笔记。运维技术作为支撑性技术，需要Linux操作系统技术，服务器架构技术以及计算机网络技术等，是一个综合性比较强的技术领域。我对运维技术比较感兴趣，最近闲暇时间也比较多，就打算开一个新坑，记录一下自己的运维技术学习过程。</p><h2 id="运维涉及的技术"><a href="#运维涉及的技术" class="headerlink" title="运维涉及的技术"></a>运维涉及的技术</h2><ul><li>web应用：Apache、nginx</li><li>数据库管理软件：MySQL、Oracle</li><li>阿里巴巴提出的去IOE策略：去除IBM、Oracle、EMC</li><li>文件共享技术：WFS、SAMBA、FTP</li><li>中间件应用：TOMCAT</li><li>日志服务：RSYSLOG</li><li>监控：ZABBIX</li><li>版本控制软件：Git</li><li>虚拟机：KVM、DOCKER、K8S</li><li>邮件服务：SENDMAIL</li><li>域控制器：DM（Domain Control）、AD</li></ul><h2 id="服务器的分类"><a href="#服务器的分类" class="headerlink" title="服务器的分类"></a>服务器的分类</h2><ol><li>塔式服务器<br>类似于个人台式机，使用的比较少</li><li>刀片式服务器<br>在机箱中加入卡片式服务器，实现高性能计算，用得比较少</li><li>机架式服务器<br>用得比较广泛，并且大小的规格统一，高度统一用单位U来表示，1个U约等于5cm。主流的机箱一般都是1U、2U以及4U。机箱的宽度也是固定的，统一为19英寸（48.26cm）。深度的规格不固定，一般有600mm、800mm以及1000mm，为了防止机箱装不进机柜，一般采用1000mm的机柜。交换机路由器机柜一般可以选600mm。</li></ol><h2 id="服务器的硬件组成"><a href="#服务器的硬件组成" class="headerlink" title="服务器的硬件组成"></a>服务器的硬件组成</h2><ul><li><p>整体配置上来讲与家用电脑很类似，硬盘是可以拆卸式的。这样设计的目的是因为硬盘长期运行容易发生损坏，将硬盘外置可以便于更换。</p></li><li><p>主频，外频和倍频的概念。<br>主频是指CPU的实际运行频率。主频 = 外频 × 倍频。<br>外频是指系统的总线频率。</p></li><li><p>地址总线宽度：代表了CPU可访问的物理地址，比方说现在常用的64位机就是拥有64根系统总线，这个表明计算机可以总共访问$2^{64}$个物理地址单元，这绝对足够我们使用。</p></li><li><p>CPU类型<br>现在主流的CPU类型有x86、x64、ARM、moto、Power。<br>按照架构分类可以分为两种CPU。  </p><ol><li><p>非x86处理器：使用RSIC（精简指令集），该种架构价格比较昂贵，但是稳定性好。</p></li><li><p>x86处理器：使用CISC（复杂指令集），该种架构价格便宜，兼容性好，稳定性差。</p></li></ol></li><li><p>内存带宽<br>内存带宽代表了内存和北桥芯片之间的数据传输速率。北桥芯片一般连接了高速设备。<br>内存带宽 = $\frac{内存总线频率 × 数据总线位数}{8}$<br>内存带宽的数量级为GB/s。</p></li><li><p>服务器硬件的种类和家用电脑相差比较大。  </p><ol><li>服务器的硬盘一般可以选择7200rpm、10000rpm、15000rpm，综合性能和稳定性考虑，一般使用10000rpm的硬盘作为服务器硬盘比较合适。</li><li>硬盘制造厂商一般采用Ki、Mi、Gi、Ti等单位作为内存容量的标称单位，这些单位都是$10^n$的形式。</li><li>硬盘接口：IDE、SCSI、SATA、SAS。其中最后两种是目前比较主流的硬盘接口，SATA电脑主要是用于普通家用电脑，SAS接口一般主要用于服务器设备。</li><li>固态硬盘的使用也是比较主流的。</li><li>采用RAID卡技术提升性能和容错率</li><li>网卡采用10Gbps、20Gbps的高端网卡。普通家用网卡为1Gbps。</li><li>采用热拔插技术，一般以硬盘为主，实现带电的更换硬盘操作。一般裸露在机箱外部的设备都是支持热拔插的，例如，硬盘，电源，PCI设备以及风扇等。</li><li>KVM（Keyboard Video Mouse）设备，用作维护人员和服务器的接口。</li><li>PDU（Power Distribution Unit），电源管理单元。</li></ol></li><li><p>储存网络</p><ol><li>DAS 直接连接储存（Direct Attached Storage）硬盘与计算机直连。</li><li>NAS 网络连接储存（Network Attached Storage）不能操作服务器，例如FTP服务器。</li><li>SAN 储存区域网络（Storage Area Network）以块的形式访问。</li></ol></li><li><p>操作系统</p><ol><li>服务器OS：RHEL，CentOS， Windows Server，AIX</li><li>桌面OS：Windows10， WIndows7，MacOS，Fedora</li><li>移动设备：Android，IOS，YunOS</li></ol></li><li><p>开发接口标准</p><ol><li>ABI：Application Binary Interface，是应用软件与操作系统之间的接口。</li><li>API：Application Programming Interface，是应用程序开发的时候调用库的接口。</li><li>POSIX：Portable Operating System Interface</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="2020/04/09/di-yi-pian-bo-ke/"/>
      <url>2020/04/09/di-yi-pian-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>我的名字是张博闻，这是我在<code>Github</code>上写下的第一篇博客，我在<code>Github</code>上部署了一个<code>hexo</code>框架的博客网站。由于初次上手，这个网站的部署花了我比较久的时间，为了使得再次建立网站变得更加方便，我想利用这一篇博文记录一下使用hexo的方法。</p><hr><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><p>Ubuntu操作系统</p></li><li><p>Node.js</p></li><li><p>Git</p></li><li><p>Hexo</p></li><li><h2 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1. 安装Git"></a>1. 安装Git</h2><p>使用如下命令安装Git。<br><code>sudo apt-get install git</code></p></li></ul><h2 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2. 安装Node.js"></a>2. 安装Node.js</h2><p>安装<code>Node.js</code>需要使用<code>nvm</code>(Node Version Manager)。</p><ul><li>安装<code>nodejs</code><br><code>curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -</code><br><code>sudo apt-get install -y nodejs</code></li></ul><h2 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3. 安装Hexo"></a>3. 安装<code>Hexo</code></h2><ul><li>使用如下命令安装Hexo。<br><code>npm install -g hexo-cli</code>  </li></ul><h3 id="至此我们所有的准备工作就都完成了，接下来便可以进入建站的环节。"><a href="#至此我们所有的准备工作就都完成了，接下来便可以进入建站的环节。" class="headerlink" title="- 至此我们所有的准备工作就都完成了，接下来便可以进入建站的环节。"></a>- 至此我们所有的准备工作就都完成了，接下来便可以进入建站的环节。</h3><hr><h2 id="建立站点"><a href="#建立站点" class="headerlink" title="建立站点"></a>建立站点</h2><h3 id="1-使用hexo-init命令初始化你想使用作为服务器的目录。"><a href="#1-使用hexo-init命令初始化你想使用作为服务器的目录。" class="headerlink" title="1. 使用hexo init命令初始化你想使用作为服务器的目录。"></a>1. 使用<code>hexo init</code>命令初始化你想使用作为服务器的目录。</h3><h3 id="2-使用hexo-g命令生成一个静态网页。"><a href="#2-使用hexo-g命令生成一个静态网页。" class="headerlink" title="2. 使用hexo g命令生成一个静态网页。"></a>2. 使用<code>hexo g</code>命令生成一个静态网页。</h3><h3 id="3-使用hexo-s命令启动服务器，使用-http-localhost-4000-观察网站的运行情况和具体内容。"><a href="#3-使用hexo-s命令启动服务器，使用-http-localhost-4000-观察网站的运行情况和具体内容。" class="headerlink" title="3. 使用hexo s命令启动服务器，使用 http://localhost:4000/观察网站的运行情况和具体内容。"></a>3. 使用<code>hexo s</code>命令启动服务器，使用<code> http://localhost:4000/</code>观察网站的运行情况和具体内容。</h3><h3 id="4-配置生成ssh。"><a href="#4-配置生成ssh。" class="headerlink" title="4. 配置生成ssh。"></a>4. 配置生成<code>ssh</code>。</h3><ul><li>执行如下指令生成一个<code>ssh key</code>。<br><code>ssh-keygen</code></li><li>三次回车之后会产生一个<code>id_rsa.pub</code>文件，文件的内容就是<code>ssh key</code>，使用<code>gedit</code>打开文件，把文件内所有内容复制到剪贴板。</li><li>打开<code>Github</code>，点击右上角头像，选择设置，再选择SSH秘钥选项，再选择添加SSH秘钥，把复制到剪贴板的内容黏贴到文本框中，秘钥名字可以任意选择。  </li><li>添加好之后使用如下命令检查<code>ssh key</code>是否设置成功<br><code>ssh -T git@github.com</code><br>如果出现选择Yes/No时，选择Yes。若出现如下提示即为设置成功。<br><code>Hi dreamgeng! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code><br>如果设置不成功，可以使用如下命令，手动设置秘钥位置。<br><code>ssh-add path/to/key</code>  <h3 id="5-设置Github个人信息。"><a href="#5-设置Github个人信息。" class="headerlink" title="5. 设置Github个人信息。"></a>5. 设置Github个人信息。</h3></li><li>设置邮箱和个人用户名，这是用来记录每一次commit的用户信息的，如果初次使用<code>Github</code>需要设置。<pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"github用户名"</span><span class="token function">git</span> config --global user.email <span class="token string">"你注册的邮箱地址"</span></code></pre></li><li>生成秘钥。<br><code>ssh-keygen -t rsa -C &quot;你注册的邮箱地址&quot;</code><h3 id="6-配置部署信息。"><a href="#6-配置部署信息。" class="headerlink" title="6. 配置部署信息。"></a>6. 配置部署信息。</h3></li><li>在_config.yml文件中，找到Deployment，然后按照如下修改。注意，在冒号后面需要添加空格。<pre class=" language-bash"><code class="language-bash">deploy:type: <span class="token function">git</span>repo: git@github.com:zbw0520/zbw0520.github.io.gitbranch: master</code></pre>注意，<code>zbw0520/zbw0520.github.io</code>可以更改为自己网站仓库的名字，并且记得加上<code>.git</code>。</li><li>执行如下最后的部署编译命令。<pre class=" language-bash"><code class="language-bash">hexo cleanhexo ghexo d</code></pre><h3 id="7-大功告成。"><a href="#7-大功告成。" class="headerlink" title="7. 大功告成。"></a>7. 大功告成。</h3></li><li>在浏览器输入你的仓库名称，如<code>zbw0520.github.io</code>，即可观察到网站设置成功。</li><li>注意，如果网站显示404的话，需要等待<code>Github</code>一些时间，大概10分钟左右，便可以观察到结果。如果十分钟后还是不能看到网页，可以输入<code>zbw0520.github.io/index.html</code>查看网页。<h3 id="8-撰写博客。"><a href="#8-撰写博客。" class="headerlink" title="8. 撰写博客。"></a>8. 撰写博客。</h3></li><li>使用如下命令便可以撰写一篇博文了。<pre class=" language-bash"><code class="language-bash">hexo new post <span class="token punctuation">[</span>title<span class="token punctuation">]</span>   //替换<span class="token punctuation">[</span>title<span class="token punctuation">]</span>为你个人博文的名称。hexo cleanhexo ghexo d</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
            <tag> 业余生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
